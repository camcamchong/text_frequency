text
"international forum of educational technology & society
a k-6 computational thinking curriculum framework: implications for teacher
knowledge
author(s): charoula angeli, joke voogt, andrew fluck, mary webb, margaret cox, joyce
malyn-smith and jason zagami
source: journal of educational technology & society , vol. 19, no. 3 (july 2016), pp. 47-57
published by: international forum of educational technology & society
stable url: https://www.jstor.org/stable/10.2307/jeductechsoci.19.3.47
references
linked references are available on jstor for this article:
https://www.jstor.org/stable/10.2307/jeductechsoci.19.3.47?seq=1&cid=pdfreference#references_tab_contents
you may need to log in to jstor to access the linked references.
jstor is a not-for-profit service that helps scholars, researchers, and students discover, use, and build upon a wide
range of content in a trusted digital archive. we use information technology and tools to increase productivity and
facilitate new forms of scholarship. for more information about jstor, please contact support@jstor.org.
your use of the jstor archive indicates your acceptance of the terms & conditions of use, available at
https://about.jstor.org/terms
international forum of educational technology & society is collaborating with jstor to digitize,
preserve and extend access to journal of educational technology & society
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
angeli, c., voogt, j., fluck, a., webb, m., cox, m., malyn-smith, j., & zagami, j. (2016). a k-6 computational thinking
curriculum framework: implications for teacher knowledge. educational technology & society, 19 (3), 47–57.
47 issn 1436-4522 (online) and 1176-3647 (print). this article of the journal of educational technology & society is available under creative commons cc-by-nd-nc
3.0 license (https://creativecommons.org/licenses/by-nc-nd/3.0/). for further queries, please contact journal editors at ets-editors@ifets.info.
a k-6 computational thinking curriculum framework: implications for
teacher knowledge
charoula angeli1*
, joke voogt2
, andrew fluck3
, mary webb4
, margaret cox4
, joyce
malyn-smith5 and jason zagami6
1university of cyprus, cyprus // 2university of amsterdam, the netherlands // 3university of tasmania, australia //
4king’s college london, uk // 5education development center, usa // 6griffith university, australia //
cangeli@ucy.ac.cy // j.m.voogt@uva.nl // andrew.fluck@utas.edu.au // mary.webb@kcl.ac.uk // mj.cox@kcl.ac.uk
// jmsmith@edc.org // j.zagami@griffith.edu.au
*corresponding author
abstract
adding computer science as a separate school subject to the core k-6 curriculum is a complex issue with
educational challenges. the authors herein address two of these challenges: (1) the design of the curriculum
based on a generic computational thinking framework, and (2) the knowledge teachers need to teach the
curriculum. the first issue is discussed within a perspective of designing an authentic computational thinking
curriculum with a focus on real-world problems. the second issue is addressed within the framework of
technological pedagogical content knowledge explicating in detail the body of knowledge that teachers need to
have to be able to teach computational thinking in a k-6 environment. an example of how these ideas can be
applied in practice is also given. while it is recognized there is a lack of adequate empirical evidence in terms of
the effectiveness of the frameworks proposed herein, it is expected that our knowledge and research base will
dramatically increase over the next several years, as more countries around the world add computer science as a
separate school subject to their k-6 curriculum.
keywords
computational thinking curriculum, pedagogical content knowledge, technological pedagogical content knowledge,
teacher preparation, k-6
introduction
in a world in which digital technology plays an important role in carrying out essential daily-life tasks, it is
imperative individuals have the education, knowledge, and skills to critically understand the technological systems
they use, as well as to be able to troubleshoot and problem solve when things go wrong (wing, 2006; czerkawski,
2015; national research council, 2010). czerkawski (2015) argues the knowledge that individuals need to have in
order to competently respond to the challenges of the 21st century goes beyond the acquisition of mere skills with
immediate application, to knowledge with long-term value that will enable them to understand the basics of
computer structures and practices. in essence, the society needs citizens who understand the true affordances of
computers in terms of what they can and cannot do, so they themselves become effective authors/creators of
computational tools. wing (2006) broadened the idea of computation, and proposed that computational thinking
should be considered as a basic skill taught across the curriculum. she defined computational thinking as the thought
process of formulating and solving problems with the use of computers. according to wing (2006), the teaching of
computational thinking, as a basic skill across the school curriculum, will enable k-12 students to learn abstract,
algorithmic and logical thinking, and be prepared to solve complex and open-ended problems.
how do we then prepare our students to develop the knowledge they need to survive and effectively cope with the
technological challenges of the 21st century? as many educators strongly argued, this educational goal can be
achieved by integrating computer science as a distinct discipline and a school subject in the k-12 curriculum (barr &
stephenson, 2011; fluck, webb, cox, angeli, malyn-smith, voogt, & zagami, 2016; goode, chapman, & margolis,
2012; hazzan, lapidot, & ragonis, 2011; tucker, deek, jones, mccowan, stephenson, & verno, 2003). fluck et al.
(2016) stated that there is a strong case for integrating computer science in the k-12 curriculum with arguments from
both the educational and economic sectors. succinctly, the educational case asserts that computer science: (a)
develops and promotes a unique way of thinking about problems, namely computational thinking, that uses the
power of logic, algorithm, abstraction, and precision; (b) empowers individuals to create new artifacts and to move
from being consumers of technology to producers of technology; and (c) redefines the way learners think about other
disciplines, and, this can have a major impact on teaching practices, such as, for example, interdisciplinary teaching
in school. the economic case stresses the critical shortage of applicants in it-related jobs, especially in europe,
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
48
while at the same time the european commission predicts that major european countries, such as uk, will need an
additional 500,000 it professionals by 2015 (husing & korte, 2010).
adding computer science as a separate school subject to the core k-12 curriculum is, however, a complex issue that
involves many legislative, administrative, political, and educational challenges. the latter are the focal point of this
paper. in particular, there are two major educational challenges related to: (a) what computer science content to teach
across different educational levels, and (b) what body of knowledge do teachers need to have to be able to teach the
computer science curriculum. over the years, a variety of computer science curricula, representing different views
about what is important to teach in computer science and when, have been proposed in the literature and or enacted
in different countries, such as uk, usa, austria, germany, mongolia, israel, greece, cyprus, and recently australia.
well-known efforts in the united states are, amongst others, the computer science principles, exploring computer
science, beauty and joy of computing, project lead the way (pltw), and code.org. computer science principles is
part of a larger national effort in the united states, namely the cs 10k project that aims to develop effective high
school computing curricula enacted in 10,000 high schools taught by 10,000 well-prepared teachers by 2016.
computer science principles constitutes a framework of standards from which high school computer science courses
can be built (astrachan & briggs, 2012). the framework is specified through a set of six computational thinking
practices (i.e., connecting computing, developing computational artifacts, analyzing problems and artifacts,
abstracting, communicating, and collaborating), and a set of seven big ideas of computer science (i.e., creativity,
abstraction, data and information, algorithms, programming, internet, and global impact), and has been adopted by
several high schools in the united states for developing computer science courses, such as the beauty and joy of
computing, code.org, and pltw (astrachan & briggs, 2012; desjardins, 2015). the beauty and joy of computing
course focuses on the big ideas of computing, and its main objective is to expose students to the beauty and joy of
programming by engaging them in meaningful projects using the snap! programming language. similarly, code.org
is a high school course with lessons and programming projects around the seven big ideas of computing as well,
whereas, the pltw uses python as its primary programming environment to expose students to different
computational thinking projects.
analogously, in various other countries similar initiatives have also been undertaken for introducing computer
science to high school students (van diepen, perrenet, & zwaneveld, 2011; micheuz, 2008; furber, 2012).
undoubtedly, during the last two decades, a lot of work has been done by the computer science education community
in promoting computer science as a school subject in secondary education. unfortunately, the same conclusion
cannot be reached about the status of computer science in the elementary school curriculum (grades k-6,
approximately from 6 to 12 years old).
a number of computer science education researchers have written about their concerns in regards to teaching
computer science in k-6 (e.g., armoni, 2012). these concerns are primarily linked to the incompatibility between
abstraction, an essential process in computer science, and children’s weakness to understand abstraction because of
their very young age. armoni (2012) explained that abstraction is an inherent component of computer science that is
always encapsulated during the process of thinking about and automating a solution to a problem. from a piagetian
perspective, children before the age of seven cannot really understand concrete logic, whereas children between
seven and eleven years old can solve problems that apply to concrete objects, but not problems that apply to abstract
concepts or phenomena. conversely, gibson (2012) argued that high school is too late for exposing students to
computer science for the first time, and stated that early exposure during kindergarten is necessary. in his research,
gibson (2012) found that young children can think abstractly when concrete reference systems are used to situate
their thinking.
recently, there has been much impetus in bringing computer science experiences to elementary school children
(kumar, 2014). kumar (2014) wrote about the proliferation of app development startup companies that have targeted
“early childhood computing education as the next emerging frontier” (p. 52), and about formal deliberative
initiatives for developing computer science curricula for k-6 students. succinctly, we acknowledge the effort by
prottsman (2014) who reported on the development of the thinkersmith curriculum in 2011, which introduced a
stand-alone set of unplugged activities for k-8 specifically designed to provide students with strong computer
science foundations without using computers. lessons in this curriculum, such as binary baubles, used materials
found in games and crafts to teach authentic computer science concepts. in 2013, code.org expanded on what
thinkersmith created, and offered a 20-hour unplugged curriculum for grades k-8. after the wide adoption of this
curriculum, in 2015 code.org developed further the existing 20-hour unplugged curriculum, which now includes
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
49
more than 55 lessons. cs unplugged, another unplugged computer science (cs) approach proposed by bell, witten,
fellows, adams, and mckenzie (2015), is a collection of activities that teach computational thinking through
engaging games and puzzles that use cards, string, crayons and lots of physical movement. students learn about
binary numbers and algorithms without using computer programming.
clearly, early computing education is now at the forefront, and, studies toward this line of research are urgently
needed in order to develop an informed body of knowledge about learning and teaching computer science in k-6.
accordingly, the authors propose a curriculum framework with a focus on promoting computational thinking skills
for ages 6 to 12. while computational thinking is just one element of computer science, albeit an important one
(fluck et al., 2016), the authors suggest a curriculum for k-6 with an explicit focus on computational thinking,
before covering more theoretical and applied concepts of computer science in secondary education. particularly, this
study sought to address the following questions: (a) what computational thinking skills should a curriculum promote
in k-6? and (b) what knowledge do teachers need to have to be able to teach a computational thinking curriculum in
k-6?
a definition of computational thinking
while the concept of computational thinking in education can be traced back to the work of seymour papert (papert,
1980), wing’s (2006) article has rekindled the interest for promoting computational thinking in k-12. other efforts
aiming at developing a definition for computational thinking include, among others, the national academy of
sciences workshop (national research council, 2010), the initiative undertaken by furber (2012), and workshops
organized by the computer science teachers association (csta) and the international society for technology in
education (iste).
succinctly, the 2010 national research council’s report differentiated computational thinking from computer
literacy, computer programming, and computer applications (i.e., games), and broadened the term to include core
concepts from the discipline of computer science, such as abstraction, decomposition, pattern generalization,
visualization, problem-solving, and algorithmic thinking.
similarly, furber (2012) offered a concise definition of computational thinking as “the process of recognizing aspects
of computation in the world that surrounds us, and applying tools and techniques from computer science to
understand and reason about both natural and artificial systems and processes” (p. 29).
csta and iste, in collaboration with leaders from higher education, industry, and k-12 education, developed an
operational definition of computational thinking as a problem-solving process that includes, but is not limited to, the
following elements: (a) formulating problems in a way that enables us to use a computer and other tools to help
solve them; (b) logically organizing and analyzing data; (c) representing data through abstractions, such as, models
and simulations; (d) automating solutions through algorithmic thinking (i.e., a series of ordered steps); (e)
identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and
effective combination of steps and resources; and (f) generalizing and transferring this problem-solving process to a
wide variety of problems.
despite the fact that currently there is not one unanimous definition of computational thinking, it seems fair to
conclude that, based on the literature reviewed in this study, researchers have come to accept that computational
thinking is a thought process that utilizes the elements of abstraction, generalization, decomposition, algorithmic
thinking, and debugging (detection and correction of errors). abstraction is the skill of removing characteristics or
attributes from an object or an entity in order to reduce it to a set of fundamental characteristics (wing, 2011). while
abstraction reduces complexity by hiding irrelevant detail, generalization reduces complexity by replacing multiple
entities that perform similar functions with a single construct (thalheim, 2000). abstraction and generalization are
often used together as abstracts are generalized through parameterization to provide greater utility. decomposition is
the skill of breaking complex problems into simpler ones (national research council, 2010). algorithmic thinking is
a problem-solving skill related to devising a step-by-step solution to a problem and differs from coding (i.e., the
technical skills required to use a programming language) (selby, 2014). additionally, algorithmic notions of
sequencing (i.e., planning an algorithm, which involves putting actions in the correct sequence), and algorithmic
notions of flow of control (i.e., the order in which individual instructions or steps in an algorithm are evaluated) are
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
50
also considered important elements of computational thinking (selby, 2014). debugging is the skill to recognize
when actions do not correspond to instructions, and the skill to fix errors (selby, 2014).
table 1 shows the elements of computational thinking as these have been discussed and defined in this section.
accordingly, this conceptual framework is the one that was adopted for developing the computational thinking
curriculum framework for k-6 presented in the next section.
table 1. the elements of computational thinking
element definition
1. abstraction the skill to decide what information about an entity/object to keep and what to ignore
(wing, 2011).
2. generalization the skill to formulate a solution in generic terms so that it can be applied to different
problems (selby, 2014).
3. decomposition the skill to break a complex problem into smaller parts that are easier to understand
and solve (national research council, 2010; wing, 2011).
4. algorithms
a. sequencing
b. flow of control
the skill to devise a step-by-step set of operations/actions of how to go about solving
a problem (selby, 2014).
the skill to put actions in the correct sequence (selby, 2014).
the order in which instructions/actions are executed (selby, 2014).
5. debugging the skill to identify, remove, and fix errors (selby, 2014).
a computational thinking curriculum framework for k-6
based on the five computational thinking skills shown in table 1, a computational thinking curriculum framework is
developed and presented in table 2. table 2 shows indicators of competence for all five computational thinking
skills, namely, abstraction, generalization, decomposition, algorithmic thinking, and debugging, in a progression
from simple to complex across the educational levels of k-2, 3-4, and 5-6. succinctly, the framework aims at
engaging children in thinking and problem solving by developing a solution to a problem, automating the solution
through algorithmic thinking, and generalizing this solution to new problems when common patterns are identified or
recognized. in essence, the framework aims at introducing students of a very young age to the thinking processes of
computational thinking so they become competent to learn more advanced theoretical and practical topics of
computer science in secondary education. in addition, the framework targets the development of all five
computational thinking skills across all k-6 levels, albeit at different levels of competence, through the use of
examples and tasks that are within the reach of children either with or without external support (external reference
systems). it is noted that the boundaries specified for each level may possibly vary from school to school and from
classroom to classroom. by the same token, it is also expected that refinements to the curriculum framework will be
ongoing once data become available from pilot offerings of different curricula, aligned with the proposed framework,
in diverse contexts.
table 2. a computational thinking curriculum framework for k-6
skill grade level (age level)
k-2 (ages 6 to 8) 3-4 (ages 9 to 10) 5-6 (ages 11 to 12)
abstraction  with the use of external
reference systems, create a
model/representation* to solve a
problem (i.e., using specific
directional language - forward,
left turn, right turn, back - and
turns of a given degree (90, 180,
270, 360), children create a path
and write instructions to enable
others to follow the path, or
children design a mat based on a
story, and have their bee-bot
 create a
model/representation to
solve a problem (i.e.,
create an object and
assign properties to it
during an activity of
digital game design and
creation).
 create a new
model/representation
to solve a problem
(i.e., create a
simulation using
scratch).
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
51
follow the path from the
narrative).
generalization  identify common patterns
between older and newer
problem-solving tasks, and use
sequences of instructions
previously employed, to solve a
new problem (i.e., use a
sequence of instructions from an
older path, to program the beebot to follow a new path that
includes the older path).
 remix and reuse (by
extending if needed)
resources that were
previously created.
 remix and reuse (by
extending if needed)
resources that were
previously created.
decomposition  break a complex task into a
series of simpler subtasks (i.e.,
break a longer path into a series
of smaller paths that the bee-bot
can follow).
 break a complex task
into simpler subtasks.
 develop a solution by
assembling together
collections of smaller
parts.
 break a complex task
into simpler subtasks.
 develop a solution by
assembling together
collections of smaller
parts.
algorithmic
thinking
 define a series of steps for a
solution.
 put instructions in the correct
sequence.
 define a series of steps
for a solution.
 put instructions in the
correct sequence.
 repeat the sequence
several times (iteration).
 define a series of steps
for a solution.
 put instructions in the
correct sequence.
 repeat the sequence
several times
(iteration).
 make decisions based
on conditions.
 store, retrieve, and
update variables.
 formulate
mathematical and
logical expressions.
debugging  recognize when instructions do
not correspond to actions.
 remove and fix errors.
 recognize when
instructions do not
correspond to actions.
 remove and fix errors.
 recognize when
instructions do not
correspond to actions.
 remove and fix errors.
note. *model/representation = can be conceptual, mathematical, mechanical, textual, graphical, etc.
curriculum design issues: a focus on a holistic design approach
the framework presented in table 2 constitutes a general framework that can be used to develop various
computational thinking programs, courses, or modules in k-6. the curriculum framework is conceptualized in a
generic form to allow teachers the freedom and agency to adapt and customize the framework as they see fit for their
own classrooms and students. according to van den akker (2010), this enactment perspective, where teachers create
their own curriculum realities, is increasingly replacing the fidelity perspective on implementation where teachers
faithfully follow curricular prescriptions from external sources. accordingly, this trend “puts even more emphasis on
teachers as key people in curriculum change” (van den akker, 2010, p. 185), underlining the utmost importance of
relevant teacher preparation. in view of that, the authors herein propose the holistic design approach as one method
that teachers can use to enact the computational thinking framework proposed in this paper.
a holistic design approach attempts to “deal with complexity without losing sight of the separate elements and the
interconnections between those elements” (van merriënboer & kirschner, 2007, p. 6). it is the opposite of an
atomistic design where complex contents and tasks are reduced to simpler elements, promoting this way content
compartmentalization and fragmentation. compartmentalization and fragmentation support the separation of a whole
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
52
into small, distinct, and often isolated parts. for example, teachers teach children to think computationally by
teaching them abstraction, then decomposition, followed by generalization, algorithmic thinking, and debugging. it is
doubtful if in the end children will have the opportunity to practice the whole complex skill (computational thinking,
in this case) in its entirety, and doubtful if they will ever learn to think computationally. on the other hand, a holistic
design approach aims at eliminating compartmentalization and fragmentation by focusing on whole complex and
authentic learning tasks, without losing sight of the individual elements that make up the complex whole. thus, with
this approach, if implemented correctly by the teacher, children learn to think computationally to solve a problem,
and also learn all other constituent and interconnected pieces of knowledge (theoretical and or practical) that are
directly related with the computational thinking task. we support the holistic design approach for teaching
computational thinking and emphasize here two design steps in the process, namely, (a) the design of problemsolving tasks with a focus on real-life issues, and (b) the sequencing of problem-solving tasks from simple to
complex. we do acknowledge that more design steps exist in the literature.
with regard to the first design step, it is argued that the sources of the computational thinking curriculum ought to be
problems, issues, and concerns directly related to life itself. a curriculum of this kind will result in usable knowledge
- that is, knowledge that can be applied directly in the context of real life, problems and concerns at hand - and not in
inert knowledge (voogt, fisser, good, mishra, & yadav, 2015; webb, fluck, cox, angeli-valanides, malyn-smith,
voogt, & zagami, 2015). educational researchers have found that a curriculum that is focused on problem solving
around real-world problems can result in greater intellectual curiosity, motivation, improved attitude toward
schooling, and higher achievement in college (wolf & brandt, 1998). consequently, a curriculum designed around
real-life problems can be a way to make computational thinking relevant to students’ lives, and, thus, a way to keep
them interested in the subject matter. ultimately, this may end up in increasing substantially the number of students
who will eventually pursue computer science as their major field of study later in college.
from an implementation point of view, a curriculum designed around real-life problems demands a wider range of
content, simply because authentic real-world problems are usually multidisciplinary in nature. as a consequence, a
curriculum from this perspective poses new demands on teaching often requiring close collaboration among teachers
with different content expertise. it should be noted that real-life problem-solving tasks constitute challenging design
endeavors, and, a curriculum designer may approach the design process through the means of rapid prototyping
before designing an entire educational program, course, or module.
with regard to the sequencing of the problem-solving tasks, a sequence from simple whole tasks to more complex
whole tasks is recommended. it is made clear that each problem-solving task, irrespective of complexity, engages the
learner in whole-task problem-solving experiences. in the context of computational thinking, this means that each
learning task, simple or complex, confronts the learner with all or almost all of the constituent computational
thinking skills for a real-life computational thinking experience. all tasks are meaningful, authentic, and relevant to
children’s life. a sequence of tasks constitutes the backbone of the computational thinking curriculum. it is also
evident that children may need guidance and support as they start working on more challenging tasks. support may
be provided in the form of external reference systems to help students gradually develop abstractions. students may
also need guidance with the problem-solving process itself.
the knowledge that teachers need to teach the curriculum
as gal-ezer and stephenson (2010) stated, having a curriculum is important, but preparing teachers to teach the
curriculum is also critical. amongst computer science teacher educators, the framework of pedagogical content
knowledge (pck) has been highly regarded as an appropriate framework for defining the knowledge teachers need
to have to be able to teach computer science (e.g., hubwieser, magenheim, mühling, & ruf, 2013; saeli, 2012).
succinctly, pck refers to a body of knowledge, which is highly context sensitive, cannot be conceptualized in
isolation from teachers’ classroom and teaching experiences, and is beyond and above a simple synthesis of
knowledge of subject matter and pedagogy (shulman, 1986; shulman, 1987). pck is an amalgam of knowledge that
“embodies the aspects of content most germane to its teachability” (shulman, 1986, p. 9), and refers to the
transformation of content into forms that are understandable to learners. according to van driel and berry (2012),
having a good pck means that teachers have several representations of the most commonly taught topics within a
certain subject. the more representations teachers have at their disposal and the better they recognize learning
difficulties, the more effectively they can deploy their pck (van driel & berry, 2012).
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
53
within the domain of computer science, a number of computer science education researchers attempted to define
pck for computer science, either in general ways (hubwieser et al., 2013; saeli, perrenet, jochems, & zwaneveld,
2011; stephenson, gal-ezer, haberman, & verno, 2005) or more specific ways (saeli, 2012). saeli et al. (2011)
concentrated on the teaching of programming in secondary education, and provided a general conceptualization of
pck for the domain of programming in terms of its constituent elements (i.e., what to teach about computer
programming, how to teach programming, and what are learners’ difficulties in programming). in a following study,
saeli (2012) was able to provide a more specific conceptualization of pck for the domain of programming in the
context of secondary education, which included details about each constituent knowledge base. in terms of the
content to be taught, she mentioned loops, data structures, arrays, problem-solving skills, decomposition, parameters,
and algorithms amongst others. regarding teachers’ pedagogical knowledge she mentioned offering a simple
programming language to better facilitate students’ effort to learn the syntax of the language, and choosing several
worthy problems to solve. lastly, she identified learners’ difficulties about different programming concepts, such as
loops, arrays, variables, and general problem-solving skills.
in the early 2000s, though, a number of educational researchers undertook systematic efforts for extending and
enriching the concept of pck by adding technology knowledge as another essential category of teachers’
knowledge base (angeli & valanides, 2005; koehler & mishra, 2008; niess, 2005). from this perspective, the
introduction of technology knowledge in the existing framework of pck successfully expanded pck to tpck -
that is, technological pedagogical content knowledge (angeli & valanides, 2005; angeli & valanides, 2009;
koehler & mishra, 2008; niess, 2005). a conceptualization of the framework of tpck is proposed by angeli and
valanides (2005; 2009) as shown in figure 1. according to figure 1, tpck is conceptualized as a unique body of
knowledge that is formed by the contribution of five distinct knowledge bases, namely, content knowledge,
pedagogical knowledge, knowledge of learners, knowledge of the educational context, and technology knowledge
(angeli & valanides, 2005; angeli & valanides, 2009). this body of knowledge grows when teachers are engaged
systematically in useful educational practices, either in their own classrooms or teacher professional development
programs.
figure 1. technological pedagogical content knowledge (adopted from angeli & valanides, 2005)
tpck is an important body of knowledge for the field of computer science, because technology is at the center of the
computer science domain, either, as a means in itself (i.e., to learn to use the technology as a goal), or as a means for
achieving or teaching something else (i.e., to use technology in order to solve a problem or to teach a computer
science concept). for the purposes of this study, the authors provide a conceptualization of tpck for the construct of
computational thinking, as it is defined in table 1, in order to better explain what teachers need to know to be able to
teach a computational thinking course aligned with the framework proposed in table 2.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
54
analytically, content knowledge (ck) is defined as knowledge about computational thinking (ckct
). this includes
knowledge and understanding about the skills of abstraction (including modeling), denoted as ckct(a)
,
generalization, denoted as ckct(g)
, decomposition, designated as ckct(d), algorithmic thinking, designated as
ck
ct(algo)
, and debugging, denoted as ck
ct(debug)
. ck
ct(algo)
includes knowledge of several computational thinking
concepts, such as, data, processing, information, sequencing, loops, parallel processing, events, conditions, operators,
variables, and dataflow of control.
learner knowledge for computational thinking (lkct
) includes knowledge about learners’ difficulties in (a)
developing abstractions that are beyond of any particular programming language or tool, denoted as lk
ct(a)
, (b)
generalizing from one solution to another by identifying common patterns, denoted as lkct(g)
, (c) decomposing
complex problems to simpler ones, designated as lkct(d)
, (d) thinking algorithmically to solve a problem (including
difficulties in understanding relevant concepts, such as sequencing, loops, flow of control, conditions, etc.), denoted
as lk
ct(algo)
, and (e) debugging, denoted as lkct(debug).
pedagogical knowledge for computational thinking (pkct
) includes the general pedagogical knowledge applicable to
all other content domains (i.e., the use of questions to promote understanding, use of examples, explanation,
demonstration), in addition to knowledge about subject-specific pedagogical practices pertinent to computational
thinking. pkct
is defined in terms of the following teaching tactics: (a) model how to problem solve or think about a
problem in iterative and incremental ways, (b) present or explain a solution to a problem in terms of a series of steps,
(c) model decision making based on conditions, (d) do something based on (and expanding) what others or you have
done (reuse and remix), (e) show how a complex problem can be decomposed into simpler problems and develop a
solution in increments, (f) show how to design a model before writing a computer program for solving the problem,
and (g) try things out as you go and make revisions based on what happens.
technology knowledge for computational thinking (tkct
) includes knowledge and skills about how to (a)
operate/use a variety of technologies, (b) invent new technologies/tools, (c) solve a task using technical processes,
methods, and tools, and (d) learn and adapt to new technologies.
context knowledge for computational thinking (cxct
) is defined from the point of view explicated by porrashernández and salinas-amescua (2013) who proposed to regard context knowledge along two important
dimensions, namely (a) scope (macro, mezzo, and micro level context) and (b) actor (students’ and teachers’ inner
and external context). macro context is defined by social, political, technological, and economic conditions at a
global level that influence the value and worth of adding computer science and computational thinking to the school
curriculum. mezzo context is defined by the social, cultural, political, organizational, and economic conditions
settled in the local community and the educational institution about the value of computational thinking in children’s
lives. finally, micro context is the level that deals with in-class conditions for learning (e.g., available resources for
computational thinking, available technologies, norms and policies, beliefs, expectations, teachers’ and students’
goals about computational thinking). in addition, porras-hernández and salinas-amescua (2013) argued that in order
to comprehend teachers’ uses of technology, it is important to consider teachers’ and students’ (actors’) unique
characteristics, as they are brought in the context as separate objects of knowledge with internal (e.g., students’
needs, preferences, misconceptions, learning difficulties, prior knowledge, teachers’ self-efficacy, pedagogical
beliefs) and external contexts (e.g., ethnicity, culture, community, and socioeconomic background).
lastly, tpck for computational thinking (tpckct
) is defined as knowing how to: (1) identify a range of creative
and authentic computational thinking projects; (2) identify a range of technologies with an appropriate set of
affordances in terms of providing the necessary technological means for practicing/teaching the whole range of
computational thinking skills with each project; and (3) use the affordances of technology to transform ckct
and
pkct
using representations that make the overall computational thinking experience comprehensible for all learners.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
55
the question that naturally arises at this point is: “what form should teacher preparation take, so that teachers
develop their tpckct
competencies adequately?” in the next section, we provide preliminary research evidence
from a teacher education course on preparing teachers how to teach computational thinking.
teacher preparation in developing tpck competencies for computational thinking
in the fall of 2015, fifteen elementary school teachers pursuing a master’s degree in instructional technology were
enrolled in a course on learning how to teach computational thinking in their k-6 classrooms. all teachers were
unfamiliar with computational thinking and had no prior experiences with computer programming. the teachers
participated in 13 three-hour weekly meetings. the participants were engaged in hands-on design activities with the
scratch computer programming environment. the learning-by-design approach, which has been shown to be
effective in contemporary teacher development studies (mckenney, kali, markauskaite, & voogt, 2015), was used in
the course to engage teachers in designing models of different problem situations before constructing computer
programs for solving the problems.
the course instructor initially engaged the teachers in authentic problem solving by asking them to think about the
city/town they were living and identify ways of how people’s lives in those places could be improved. the teachers
explained their thinking about possible improvements and then the instructor asked them to think about how computers
could be used for solving some of the problems they identified. a brainstorming activity resulted in ten different ideas
that constituted the real-life tasks that the course instructor used to teach the teachers about computational thinking. the
ten tasks were sequenced from simple to complex based on the involvedness of the solution.
for each problem, teachers were taught how to create a model first before writing a computer program for solving the
problem. creating a model proved to be extremely difficult for the teachers and often times they asked their
instructor for help. early attempts in creating models resulted in models containing lots of unnecessary information,
but, gradually teachers, with the help of the course instructor learned that models are abstractions of something free
from inessential detail. the teachers were taught how to create models through a process that was explicitly taught to
them and involved identification of the important entities of the model, their characteristics (parameters in the
model), and relationships, either quantitative or qualitative, between the parameters of the entities. the teachers
showed commitment in developing the best models they could possibly create, and, often times they exhibited lots of
creative ideas of how to make them better.
in regards to teaching teachers computer programming, the course instructor used systematically the following
pedagogical strategies: (a) decide what sprites are needed for your project, (b) decide what scripts are needed for
your project, (c) organize the scripts in meaningful ways for you and others, (d) develop some code, try it out, then
develop some more, (e) test and debug, and (f) build or extend on existing projects or ideas. during the programming
tasks, computational concepts such as, data, processing, information, sequencing, loops, parallel processing, events,
conditions, operators, variables, and dataflow of control, were explicitly explained and illustrated with lots of
programming examples. teachers had no difficulties with understanding programming concepts, even though they
found the concepts of variables and conditional logic more challenging than the others.
concluding remarks
in conclusion, the authors in this paper presented a computational thinking curriculum framework for designing a
curriculum for k-6, an area of research that is still in its infancy, described design guidelines for enacting the
curriculum framework, and defined tpckct
as the body of knowledge that teachers need to have to be able to teach
the curriculum in k-6. in addition, the authors provided an example of a teacher preparation course that was
specifically designed to promote teachers’ tpckct
. it is recognized that more empirical evidence in the form of rich
educational cases is needed in terms of further investigating the effectiveness of the frameworks proposed herein in a
variety of contexts. it is expected that with the gradual adoption of computer science as a distinct school subject in
the k-6 curriculum of countries around the world, our knowledge and research base regarding the issues discussed in
this paper will dramatically expand over the next several years.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
56
references
angeli, c., & valanides, n. (2005). preservice teachers as ict designers: an instructional design model based on an expanded
view of pedagogical content knowledge. journal of computer-assisted learning, 21(4), 292-302.
angeli, c., & valanides, n. (2009). epistemological and methodological issues for the conceptualization, development, and
assessment of ict-tpck: advances in technological pedagogical content knowledge (tpck). computers & education, 52, 154-
168.
armoni, m. (2012). teaching cs in kindergarten: how early can the pipeline begin? acm inroads, 3(4), 18-19.
astrachan, o., & briggs, a. (2012). the cs principles project. acm inroads, 3(2), 38-42.
barr, v., & stephenson, c. (2011). bringing computational thinking to k-12: what is involved and what is the role of the
computer science education community? acm inroads, 2(1), 48-54.
bell, t. c., witten, i. h., fellows, m. r., adams, r., & mckenzie, j. (2015). cs unplugged: an enrichment and extension
programme for primary-aged students. retrieved from http://csunplugged.org/wpcontent/uploads/2015/03/csunplugged_os_2015_v3.1.pdf
czerkawski, b. (2015). computational thinking in virtual learning environments. in proceedings of e-learn: world conference
on e-learning in corporate, government, healthcare, and higher education 2015 (pp. 993-997). chesapeake, va: association
for the advancement of computing in education (aace).
desjardins, m. (2015). creating ap® cs principles: let many flowers bloom. acm inroads, 6(4), 60-66.
fluck, a., webb, m., cox, m., angeli, c., malyn-smith, j., voogt, j., & zagami, j. (2016). arguing for computer science in the
school curriculum. educational technology and society, 19(3), 38-46.
furber, s. (2012). shut down or restart? the way forward for computing in uk schools. london, uk: the royal society.
gal-ezer, j., & stephenson, c. (2010). computer science teacher preparation is critical. acm inroads, 1(1), 61-66.
gibson, j. p. (2012, july). teaching graph algorithms to children of all ages. in proceedings of the 17th annual sigcse
conference on innovation and technology in computer science education (iticse’12) (pp. 34–39). new york, ny: acm.
goode, j., chapman, g., & margolis, j. (2012). beyond curriculum: the exploring computer science program. acm
inroads, 3(2), 47-53.
hazzan, o., lapidot, t., & ragonis, n. (2011). guide to teaching computer science: an activity-based approach. london, uk:
springer.
hubwieser, p., magenheim, j., mühling, a., & ruf, a. (2013, august). towards a conceptualization of pedagogical content
knowledge for computer science. in proceedings of the ninth annual international acm conference on international computing
education research (pp. 1-8). new york, ny: acm.
husing, t., & korte, w. b. (2010). evaluation of the implementation of the communication of the european commission: e-skills
for the 21st century. bonn, germany: empirica. retrieved from http://hdl.voced.edu.au/10707/323186
koehler, m. j., & mishra p. (2008). introducing tpck. in aacte committee on innovation and technology (eds.), handbook
of technological pedagogical content knowledge (tpck) for educators (pp. 3–29). new york, ny: routledge.
kumar, d. (2014). digital playgrounds for early computing education. acm inroads, 5(1), 20-21.
mckenney, s., kali, y., markauskaite, l., & voogt, j. (2015). teacher design knowledge for technology enhanced learning: an
ecological framework for investigating assets and needs. instructional science, 43(2), 181-202.
micheuz, p. (2008). some findings on informatics education in austrian academic secondary schools. informatics in education,
7(2), 221-236.
national research council. (2010). committee for the workshops on computational thinking: report of a workshop on the scope
and nature of computational thinking. washington, dc: national academy press. doi:10.17226/12840
niess m. l. (2005). preparing teachers to teach science and mathematics with technology: developing a technology pedagogical
content knowledge. teaching and teacher education, 21, 509–523.
papert, s. (1980). mindstorms: children, computers, and powerful ideas. new york, ny: basic books, inc.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
57
porras-hernández, l. h., & salinas-amescua, b. (2013). strengthening tpack: a broader notion of context and the use of
teacher's narratives to reveal knowledge construction. journal of educational computing research, 48(2), 223-244.
prottsman, k. (2014). computer science for the elementary classroom. acm inroads, 5(4), 60-63.
saeli, m. (2012). teaching programming for secondary school: a pedagogical content knowledge based approach (unpublished
doctoral dissertation). technische universiteit eindhoven, netherlands.
saeli, m., perrenet, j., jochems, w. m., & zwaneveld, b. (2011). teaching programming in secondary school: a pedagogical
content knowledge perspective. informatics in education, 10(1), 73-88.
selby, c. c. (2014). how can the teaching of programming be used to enhance computational thinking skills? (unpublished
doctoral dissertation). university of southampton, southampton, uk.
shulman, l. s. (1986). those who understand: knowledge growth in teaching. educational researcher, 15, 4–14.
shulman, l. s. (1987). knowledge and teaching: foundations of the new reform. harvard educational review, 57, 1-23.
stephenson, c., gal-ezer, j., haberman, b., & verno, a. (2005). the new educational imperative: improving high school
computer science education. new york, ny: computer science teachers association (csta).
thalheim, b. (2000). fundamentals of entity-relationship modeling. new york, ny: springer.
tucker, a. b., deek, f., jones, j., mccowan, d., stephenson, c., & verno, a. (2003). a model curriculum for k-12 computer
science. new york, ny: acm/computer science teachers association.
van diepen, n., perrenet, j., & zwaneveld, b. (2011). which way with informatics in high schools in the netherlands? the dutch
dilemma. informatics in education, 10(1), 123-148.
van driel, j. h., & berry, a. (2012). teacher professional development focusing on pedagogical content knowledge. educational
researcher, 41(1), 26-28.
van den akker, j. (2010). building bridges: how research may improve curriculum policies and classroom practices. in beyond
lisbon 2010: perspectives from research and development for education policy in europe (pp. 177-195). aarau, switzerland:
cidree.
van merriënboer, j. v., & kirschner, p. a. (2007). ten steps to complex learning: a systematic approach to four-component
instructional design. mahwah, nj: lawrence erlbaum.
voogt, j., fisser, p., good, j., mishra, p., & yadav, a. (2015). computational thinking in compulsory education: towards an
agenda for research and practice. education and information technologies, 20(4), 715-728.
webb, m., fluck, a., cox, m., angeli-valanides, c., malyn-smith, j., voogt, j., & zagami, j. (2015). curriculum: advancing
understanding of the roles of computer science/informatics in the curriculum. in k-w lai (ed.), edusummit 2015 summary
report (pp. 60-68). retrieved from http://www.curtin.edu.au/edusummit/local/docs/edusummit2015-ebook.pdf
wing, j. (2006). computational thinking. communications of the acm, 49(3), 33-35.
wing, j. m. (2011, march). computational thinking. retrieved from
https://csta.acm.org/curriculum/sub/currfiles/wingctprez.pdf
wolf, p., & brandt, r. (1998). what do we know from brain research? educational leadership, 56(3), 8-13.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt"
"international forum of educational technology & society
a k-6 computational thinking curriculum framework: implications for teacher
knowledge
author(s): charoula angeli, joke voogt, andrew fluck, mary webb, margaret cox, joyce
malyn-smith and jason zagami
source: journal of educational technology & society , vol. 19, no. 3 (july 2016), pp. 47-57
published by: international forum of educational technology & society
stable url: https://www.jstor.org/stable/10.2307/jeductechsoci.19.3.47
references
linked references are available on jstor for this article:
https://www.jstor.org/stable/10.2307/jeductechsoci.19.3.47?seq=1&cid=pdfreference#references_tab_contents
you may need to log in to jstor to access the linked references.
jstor is a not-for-profit service that helps scholars, researchers, and students discover, use, and build upon a wide
range of content in a trusted digital archive. we use information technology and tools to increase productivity and
facilitate new forms of scholarship. for more information about jstor, please contact support@jstor.org.
your use of the jstor archive indicates your acceptance of the terms & conditions of use, available at
https://about.jstor.org/terms
international forum of educational technology & society is collaborating with jstor to digitize,
preserve and extend access to journal of educational technology & society
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
angeli, c., voogt, j., fluck, a., webb, m., cox, m., malyn-smith, j., & zagami, j. (2016). a k-6 computational thinking
curriculum framework: implications for teacher knowledge. educational technology & society, 19 (3), 47–57.
47 issn 1436-4522 (online) and 1176-3647 (print). this article of the journal of educational technology & society is available under creative commons cc-by-nd-nc
3.0 license (https://creativecommons.org/licenses/by-nc-nd/3.0/). for further queries, please contact journal editors at ets-editors@ifets.info.
a k-6 computational thinking curriculum framework: implications for
teacher knowledge
charoula angeli1*
, joke voogt2
, andrew fluck3
, mary webb4
, margaret cox4
, joyce
malyn-smith5 and jason zagami6
1university of cyprus, cyprus // 2university of amsterdam, the netherlands // 3university of tasmania, australia //
4king’s college london, uk // 5education development center, usa // 6griffith university, australia //
cangeli@ucy.ac.cy // j.m.voogt@uva.nl // andrew.fluck@utas.edu.au // mary.webb@kcl.ac.uk // mj.cox@kcl.ac.uk
// jmsmith@edc.org // j.zagami@griffith.edu.au
*corresponding author
abstract
adding computer science as a separate school subject to the core k-6 curriculum is a complex issue with
educational challenges. the authors herein address two of these challenges: (1) the design of the curriculum
based on a generic computational thinking framework, and (2) the knowledge teachers need to teach the
curriculum. the first issue is discussed within a perspective of designing an authentic computational thinking
curriculum with a focus on real-world problems. the second issue is addressed within the framework of
technological pedagogical content knowledge explicating in detail the body of knowledge that teachers need to
have to be able to teach computational thinking in a k-6 environment. an example of how these ideas can be
applied in practice is also given. while it is recognized there is a lack of adequate empirical evidence in terms of
the effectiveness of the frameworks proposed herein, it is expected that our knowledge and research base will
dramatically increase over the next several years, as more countries around the world add computer science as a
separate school subject to their k-6 curriculum.
keywords
computational thinking curriculum, pedagogical content knowledge, technological pedagogical content knowledge,
teacher preparation, k-6
introduction
in a world in which digital technology plays an important role in carrying out essential daily-life tasks, it is
imperative individuals have the education, knowledge, and skills to critically understand the technological systems
they use, as well as to be able to troubleshoot and problem solve when things go wrong (wing, 2006; czerkawski,
2015; national research council, 2010). czerkawski (2015) argues the knowledge that individuals need to have in
order to competently respond to the challenges of the 21st century goes beyond the acquisition of mere skills with
immediate application, to knowledge with long-term value that will enable them to understand the basics of
computer structures and practices. in essence, the society needs citizens who understand the true affordances of
computers in terms of what they can and cannot do, so they themselves become effective authors/creators of
computational tools. wing (2006) broadened the idea of computation, and proposed that computational thinking
should be considered as a basic skill taught across the curriculum. she defined computational thinking as the thought
process of formulating and solving problems with the use of computers. according to wing (2006), the teaching of
computational thinking, as a basic skill across the school curriculum, will enable k-12 students to learn abstract,
algorithmic and logical thinking, and be prepared to solve complex and open-ended problems.
how do we then prepare our students to develop the knowledge they need to survive and effectively cope with the
technological challenges of the 21st century? as many educators strongly argued, this educational goal can be
achieved by integrating computer science as a distinct discipline and a school subject in the k-12 curriculum (barr &
stephenson, 2011; fluck, webb, cox, angeli, malyn-smith, voogt, & zagami, 2016; goode, chapman, & margolis,
2012; hazzan, lapidot, & ragonis, 2011; tucker, deek, jones, mccowan, stephenson, & verno, 2003). fluck et al.
(2016) stated that there is a strong case for integrating computer science in the k-12 curriculum with arguments from
both the educational and economic sectors. succinctly, the educational case asserts that computer science: (a)
develops and promotes a unique way of thinking about problems, namely computational thinking, that uses the
power of logic, algorithm, abstraction, and precision; (b) empowers individuals to create new artifacts and to move
from being consumers of technology to producers of technology; and (c) redefines the way learners think about other
disciplines, and, this can have a major impact on teaching practices, such as, for example, interdisciplinary teaching
in school. the economic case stresses the critical shortage of applicants in it-related jobs, especially in europe,
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
48
while at the same time the european commission predicts that major european countries, such as uk, will need an
additional 500,000 it professionals by 2015 (husing & korte, 2010).
adding computer science as a separate school subject to the core k-12 curriculum is, however, a complex issue that
involves many legislative, administrative, political, and educational challenges. the latter are the focal point of this
paper. in particular, there are two major educational challenges related to: (a) what computer science content to teach
across different educational levels, and (b) what body of knowledge do teachers need to have to be able to teach the
computer science curriculum. over the years, a variety of computer science curricula, representing different views
about what is important to teach in computer science and when, have been proposed in the literature and or enacted
in different countries, such as uk, usa, austria, germany, mongolia, israel, greece, cyprus, and recently australia.
well-known efforts in the united states are, amongst others, the computer science principles, exploring computer
science, beauty and joy of computing, project lead the way (pltw), and code.org. computer science principles is
part of a larger national effort in the united states, namely the cs 10k project that aims to develop effective high
school computing curricula enacted in 10,000 high schools taught by 10,000 well-prepared teachers by 2016.
computer science principles constitutes a framework of standards from which high school computer science courses
can be built (astrachan & briggs, 2012). the framework is specified through a set of six computational thinking
practices (i.e., connecting computing, developing computational artifacts, analyzing problems and artifacts,
abstracting, communicating, and collaborating), and a set of seven big ideas of computer science (i.e., creativity,
abstraction, data and information, algorithms, programming, internet, and global impact), and has been adopted by
several high schools in the united states for developing computer science courses, such as the beauty and joy of
computing, code.org, and pltw (astrachan & briggs, 2012; desjardins, 2015). the beauty and joy of computing
course focuses on the big ideas of computing, and its main objective is to expose students to the beauty and joy of
programming by engaging them in meaningful projects using the snap! programming language. similarly, code.org
is a high school course with lessons and programming projects around the seven big ideas of computing as well,
whereas, the pltw uses python as its primary programming environment to expose students to different
computational thinking projects.
analogously, in various other countries similar initiatives have also been undertaken for introducing computer
science to high school students (van diepen, perrenet, & zwaneveld, 2011; micheuz, 2008; furber, 2012).
undoubtedly, during the last two decades, a lot of work has been done by the computer science education community
in promoting computer science as a school subject in secondary education. unfortunately, the same conclusion
cannot be reached about the status of computer science in the elementary school curriculum (grades k-6,
approximately from 6 to 12 years old).
a number of computer science education researchers have written about their concerns in regards to teaching
computer science in k-6 (e.g., armoni, 2012). these concerns are primarily linked to the incompatibility between
abstraction, an essential process in computer science, and children’s weakness to understand abstraction because of
their very young age. armoni (2012) explained that abstraction is an inherent component of computer science that is
always encapsulated during the process of thinking about and automating a solution to a problem. from a piagetian
perspective, children before the age of seven cannot really understand concrete logic, whereas children between
seven and eleven years old can solve problems that apply to concrete objects, but not problems that apply to abstract
concepts or phenomena. conversely, gibson (2012) argued that high school is too late for exposing students to
computer science for the first time, and stated that early exposure during kindergarten is necessary. in his research,
gibson (2012) found that young children can think abstractly when concrete reference systems are used to situate
their thinking.
recently, there has been much impetus in bringing computer science experiences to elementary school children
(kumar, 2014). kumar (2014) wrote about the proliferation of app development startup companies that have targeted
“early childhood computing education as the next emerging frontier” (p. 52), and about formal deliberative
initiatives for developing computer science curricula for k-6 students. succinctly, we acknowledge the effort by
prottsman (2014) who reported on the development of the thinkersmith curriculum in 2011, which introduced a
stand-alone set of unplugged activities for k-8 specifically designed to provide students with strong computer
science foundations without using computers. lessons in this curriculum, such as binary baubles, used materials
found in games and crafts to teach authentic computer science concepts. in 2013, code.org expanded on what
thinkersmith created, and offered a 20-hour unplugged curriculum for grades k-8. after the wide adoption of this
curriculum, in 2015 code.org developed further the existing 20-hour unplugged curriculum, which now includes
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
49
more than 55 lessons. cs unplugged, another unplugged computer science (cs) approach proposed by bell, witten,
fellows, adams, and mckenzie (2015), is a collection of activities that teach computational thinking through
engaging games and puzzles that use cards, string, crayons and lots of physical movement. students learn about
binary numbers and algorithms without using computer programming.
clearly, early computing education is now at the forefront, and, studies toward this line of research are urgently
needed in order to develop an informed body of knowledge about learning and teaching computer science in k-6.
accordingly, the authors propose a curriculum framework with a focus on promoting computational thinking skills
for ages 6 to 12. while computational thinking is just one element of computer science, albeit an important one
(fluck et al., 2016), the authors suggest a curriculum for k-6 with an explicit focus on computational thinking,
before covering more theoretical and applied concepts of computer science in secondary education. particularly, this
study sought to address the following questions: (a) what computational thinking skills should a curriculum promote
in k-6? and (b) what knowledge do teachers need to have to be able to teach a computational thinking curriculum in
k-6?
a definition of computational thinking
while the concept of computational thinking in education can be traced back to the work of seymour papert (papert,
1980), wing’s (2006) article has rekindled the interest for promoting computational thinking in k-12. other efforts
aiming at developing a definition for computational thinking include, among others, the national academy of
sciences workshop (national research council, 2010), the initiative undertaken by furber (2012), and workshops
organized by the computer science teachers association (csta) and the international society for technology in
education (iste).
succinctly, the 2010 national research council’s report differentiated computational thinking from computer
literacy, computer programming, and computer applications (i.e., games), and broadened the term to include core
concepts from the discipline of computer science, such as abstraction, decomposition, pattern generalization,
visualization, problem-solving, and algorithmic thinking.
similarly, furber (2012) offered a concise definition of computational thinking as “the process of recognizing aspects
of computation in the world that surrounds us, and applying tools and techniques from computer science to
understand and reason about both natural and artificial systems and processes” (p. 29).
csta and iste, in collaboration with leaders from higher education, industry, and k-12 education, developed an
operational definition of computational thinking as a problem-solving process that includes, but is not limited to, the
following elements: (a) formulating problems in a way that enables us to use a computer and other tools to help
solve them; (b) logically organizing and analyzing data; (c) representing data through abstractions, such as, models
and simulations; (d) automating solutions through algorithmic thinking (i.e., a series of ordered steps); (e)
identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and
effective combination of steps and resources; and (f) generalizing and transferring this problem-solving process to a
wide variety of problems.
despite the fact that currently there is not one unanimous definition of computational thinking, it seems fair to
conclude that, based on the literature reviewed in this study, researchers have come to accept that computational
thinking is a thought process that utilizes the elements of abstraction, generalization, decomposition, algorithmic
thinking, and debugging (detection and correction of errors). abstraction is the skill of removing characteristics or
attributes from an object or an entity in order to reduce it to a set of fundamental characteristics (wing, 2011). while
abstraction reduces complexity by hiding irrelevant detail, generalization reduces complexity by replacing multiple
entities that perform similar functions with a single construct (thalheim, 2000). abstraction and generalization are
often used together as abstracts are generalized through parameterization to provide greater utility. decomposition is
the skill of breaking complex problems into simpler ones (national research council, 2010). algorithmic thinking is
a problem-solving skill related to devising a step-by-step solution to a problem and differs from coding (i.e., the
technical skills required to use a programming language) (selby, 2014). additionally, algorithmic notions of
sequencing (i.e., planning an algorithm, which involves putting actions in the correct sequence), and algorithmic
notions of flow of control (i.e., the order in which individual instructions or steps in an algorithm are evaluated) are
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
50
also considered important elements of computational thinking (selby, 2014). debugging is the skill to recognize
when actions do not correspond to instructions, and the skill to fix errors (selby, 2014).
table 1 shows the elements of computational thinking as these have been discussed and defined in this section.
accordingly, this conceptual framework is the one that was adopted for developing the computational thinking
curriculum framework for k-6 presented in the next section.
table 1. the elements of computational thinking
element definition
1. abstraction the skill to decide what information about an entity/object to keep and what to ignore
(wing, 2011).
2. generalization the skill to formulate a solution in generic terms so that it can be applied to different
problems (selby, 2014).
3. decomposition the skill to break a complex problem into smaller parts that are easier to understand
and solve (national research council, 2010; wing, 2011).
4. algorithms
a. sequencing
b. flow of control
the skill to devise a step-by-step set of operations/actions of how to go about solving
a problem (selby, 2014).
the skill to put actions in the correct sequence (selby, 2014).
the order in which instructions/actions are executed (selby, 2014).
5. debugging the skill to identify, remove, and fix errors (selby, 2014).
a computational thinking curriculum framework for k-6
based on the five computational thinking skills shown in table 1, a computational thinking curriculum framework is
developed and presented in table 2. table 2 shows indicators of competence for all five computational thinking
skills, namely, abstraction, generalization, decomposition, algorithmic thinking, and debugging, in a progression
from simple to complex across the educational levels of k-2, 3-4, and 5-6. succinctly, the framework aims at
engaging children in thinking and problem solving by developing a solution to a problem, automating the solution
through algorithmic thinking, and generalizing this solution to new problems when common patterns are identified or
recognized. in essence, the framework aims at introducing students of a very young age to the thinking processes of
computational thinking so they become competent to learn more advanced theoretical and practical topics of
computer science in secondary education. in addition, the framework targets the development of all five
computational thinking skills across all k-6 levels, albeit at different levels of competence, through the use of
examples and tasks that are within the reach of children either with or without external support (external reference
systems). it is noted that the boundaries specified for each level may possibly vary from school to school and from
classroom to classroom. by the same token, it is also expected that refinements to the curriculum framework will be
ongoing once data become available from pilot offerings of different curricula, aligned with the proposed framework,
in diverse contexts.
table 2. a computational thinking curriculum framework for k-6
skill grade level (age level)
k-2 (ages 6 to 8) 3-4 (ages 9 to 10) 5-6 (ages 11 to 12)
abstraction  with the use of external
reference systems, create a
model/representation* to solve a
problem (i.e., using specific
directional language - forward,
left turn, right turn, back - and
turns of a given degree (90, 180,
270, 360), children create a path
and write instructions to enable
others to follow the path, or
children design a mat based on a
story, and have their bee-bot
 create a
model/representation to
solve a problem (i.e.,
create an object and
assign properties to it
during an activity of
digital game design and
creation).
 create a new
model/representation
to solve a problem
(i.e., create a
simulation using
scratch).
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
51
follow the path from the
narrative).
generalization  identify common patterns
between older and newer
problem-solving tasks, and use
sequences of instructions
previously employed, to solve a
new problem (i.e., use a
sequence of instructions from an
older path, to program the beebot to follow a new path that
includes the older path).
 remix and reuse (by
extending if needed)
resources that were
previously created.
 remix and reuse (by
extending if needed)
resources that were
previously created.
decomposition  break a complex task into a
series of simpler subtasks (i.e.,
break a longer path into a series
of smaller paths that the bee-bot
can follow).
 break a complex task
into simpler subtasks.
 develop a solution by
assembling together
collections of smaller
parts.
 break a complex task
into simpler subtasks.
 develop a solution by
assembling together
collections of smaller
parts.
algorithmic
thinking
 define a series of steps for a
solution.
 put instructions in the correct
sequence.
 define a series of steps
for a solution.
 put instructions in the
correct sequence.
 repeat the sequence
several times (iteration).
 define a series of steps
for a solution.
 put instructions in the
correct sequence.
 repeat the sequence
several times
(iteration).
 make decisions based
on conditions.
 store, retrieve, and
update variables.
 formulate
mathematical and
logical expressions.
debugging  recognize when instructions do
not correspond to actions.
 remove and fix errors.
 recognize when
instructions do not
correspond to actions.
 remove and fix errors.
 recognize when
instructions do not
correspond to actions.
 remove and fix errors.
note. *model/representation = can be conceptual, mathematical, mechanical, textual, graphical, etc.
curriculum design issues: a focus on a holistic design approach
the framework presented in table 2 constitutes a general framework that can be used to develop various
computational thinking programs, courses, or modules in k-6. the curriculum framework is conceptualized in a
generic form to allow teachers the freedom and agency to adapt and customize the framework as they see fit for their
own classrooms and students. according to van den akker (2010), this enactment perspective, where teachers create
their own curriculum realities, is increasingly replacing the fidelity perspective on implementation where teachers
faithfully follow curricular prescriptions from external sources. accordingly, this trend “puts even more emphasis on
teachers as key people in curriculum change” (van den akker, 2010, p. 185), underlining the utmost importance of
relevant teacher preparation. in view of that, the authors herein propose the holistic design approach as one method
that teachers can use to enact the computational thinking framework proposed in this paper.
a holistic design approach attempts to “deal with complexity without losing sight of the separate elements and the
interconnections between those elements” (van merriënboer & kirschner, 2007, p. 6). it is the opposite of an
atomistic design where complex contents and tasks are reduced to simpler elements, promoting this way content
compartmentalization and fragmentation. compartmentalization and fragmentation support the separation of a whole
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
52
into small, distinct, and often isolated parts. for example, teachers teach children to think computationally by
teaching them abstraction, then decomposition, followed by generalization, algorithmic thinking, and debugging. it is
doubtful if in the end children will have the opportunity to practice the whole complex skill (computational thinking,
in this case) in its entirety, and doubtful if they will ever learn to think computationally. on the other hand, a holistic
design approach aims at eliminating compartmentalization and fragmentation by focusing on whole complex and
authentic learning tasks, without losing sight of the individual elements that make up the complex whole. thus, with
this approach, if implemented correctly by the teacher, children learn to think computationally to solve a problem,
and also learn all other constituent and interconnected pieces of knowledge (theoretical and or practical) that are
directly related with the computational thinking task. we support the holistic design approach for teaching
computational thinking and emphasize here two design steps in the process, namely, (a) the design of problemsolving tasks with a focus on real-life issues, and (b) the sequencing of problem-solving tasks from simple to
complex. we do acknowledge that more design steps exist in the literature.
with regard to the first design step, it is argued that the sources of the computational thinking curriculum ought to be
problems, issues, and concerns directly related to life itself. a curriculum of this kind will result in usable knowledge
- that is, knowledge that can be applied directly in the context of real life, problems and concerns at hand - and not in
inert knowledge (voogt, fisser, good, mishra, & yadav, 2015; webb, fluck, cox, angeli-valanides, malyn-smith,
voogt, & zagami, 2015). educational researchers have found that a curriculum that is focused on problem solving
around real-world problems can result in greater intellectual curiosity, motivation, improved attitude toward
schooling, and higher achievement in college (wolf & brandt, 1998). consequently, a curriculum designed around
real-life problems can be a way to make computational thinking relevant to students’ lives, and, thus, a way to keep
them interested in the subject matter. ultimately, this may end up in increasing substantially the number of students
who will eventually pursue computer science as their major field of study later in college.
from an implementation point of view, a curriculum designed around real-life problems demands a wider range of
content, simply because authentic real-world problems are usually multidisciplinary in nature. as a consequence, a
curriculum from this perspective poses new demands on teaching often requiring close collaboration among teachers
with different content expertise. it should be noted that real-life problem-solving tasks constitute challenging design
endeavors, and, a curriculum designer may approach the design process through the means of rapid prototyping
before designing an entire educational program, course, or module.
with regard to the sequencing of the problem-solving tasks, a sequence from simple whole tasks to more complex
whole tasks is recommended. it is made clear that each problem-solving task, irrespective of complexity, engages the
learner in whole-task problem-solving experiences. in the context of computational thinking, this means that each
learning task, simple or complex, confronts the learner with all or almost all of the constituent computational
thinking skills for a real-life computational thinking experience. all tasks are meaningful, authentic, and relevant to
children’s life. a sequence of tasks constitutes the backbone of the computational thinking curriculum. it is also
evident that children may need guidance and support as they start working on more challenging tasks. support may
be provided in the form of external reference systems to help students gradually develop abstractions. students may
also need guidance with the problem-solving process itself.
the knowledge that teachers need to teach the curriculum
as gal-ezer and stephenson (2010) stated, having a curriculum is important, but preparing teachers to teach the
curriculum is also critical. amongst computer science teacher educators, the framework of pedagogical content
knowledge (pck) has been highly regarded as an appropriate framework for defining the knowledge teachers need
to have to be able to teach computer science (e.g., hubwieser, magenheim, mühling, & ruf, 2013; saeli, 2012).
succinctly, pck refers to a body of knowledge, which is highly context sensitive, cannot be conceptualized in
isolation from teachers’ classroom and teaching experiences, and is beyond and above a simple synthesis of
knowledge of subject matter and pedagogy (shulman, 1986; shulman, 1987). pck is an amalgam of knowledge that
“embodies the aspects of content most germane to its teachability” (shulman, 1986, p. 9), and refers to the
transformation of content into forms that are understandable to learners. according to van driel and berry (2012),
having a good pck means that teachers have several representations of the most commonly taught topics within a
certain subject. the more representations teachers have at their disposal and the better they recognize learning
difficulties, the more effectively they can deploy their pck (van driel & berry, 2012).
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
53
within the domain of computer science, a number of computer science education researchers attempted to define
pck for computer science, either in general ways (hubwieser et al., 2013; saeli, perrenet, jochems, & zwaneveld,
2011; stephenson, gal-ezer, haberman, & verno, 2005) or more specific ways (saeli, 2012). saeli et al. (2011)
concentrated on the teaching of programming in secondary education, and provided a general conceptualization of
pck for the domain of programming in terms of its constituent elements (i.e., what to teach about computer
programming, how to teach programming, and what are learners’ difficulties in programming). in a following study,
saeli (2012) was able to provide a more specific conceptualization of pck for the domain of programming in the
context of secondary education, which included details about each constituent knowledge base. in terms of the
content to be taught, she mentioned loops, data structures, arrays, problem-solving skills, decomposition, parameters,
and algorithms amongst others. regarding teachers’ pedagogical knowledge she mentioned offering a simple
programming language to better facilitate students’ effort to learn the syntax of the language, and choosing several
worthy problems to solve. lastly, she identified learners’ difficulties about different programming concepts, such as
loops, arrays, variables, and general problem-solving skills.
in the early 2000s, though, a number of educational researchers undertook systematic efforts for extending and
enriching the concept of pck by adding technology knowledge as another essential category of teachers’
knowledge base (angeli & valanides, 2005; koehler & mishra, 2008; niess, 2005). from this perspective, the
introduction of technology knowledge in the existing framework of pck successfully expanded pck to tpck -
that is, technological pedagogical content knowledge (angeli & valanides, 2005; angeli & valanides, 2009;
koehler & mishra, 2008; niess, 2005). a conceptualization of the framework of tpck is proposed by angeli and
valanides (2005; 2009) as shown in figure 1. according to figure 1, tpck is conceptualized as a unique body of
knowledge that is formed by the contribution of five distinct knowledge bases, namely, content knowledge,
pedagogical knowledge, knowledge of learners, knowledge of the educational context, and technology knowledge
(angeli & valanides, 2005; angeli & valanides, 2009). this body of knowledge grows when teachers are engaged
systematically in useful educational practices, either in their own classrooms or teacher professional development
programs.
figure 1. technological pedagogical content knowledge (adopted from angeli & valanides, 2005)
tpck is an important body of knowledge for the field of computer science, because technology is at the center of the
computer science domain, either, as a means in itself (i.e., to learn to use the technology as a goal), or as a means for
achieving or teaching something else (i.e., to use technology in order to solve a problem or to teach a computer
science concept). for the purposes of this study, the authors provide a conceptualization of tpck for the construct of
computational thinking, as it is defined in table 1, in order to better explain what teachers need to know to be able to
teach a computational thinking course aligned with the framework proposed in table 2.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
54
analytically, content knowledge (ck) is defined as knowledge about computational thinking (ckct
). this includes
knowledge and understanding about the skills of abstraction (including modeling), denoted as ckct(a)
,
generalization, denoted as ckct(g)
, decomposition, designated as ckct(d), algorithmic thinking, designated as
ck
ct(algo)
, and debugging, denoted as ck
ct(debug)
. ck
ct(algo)
includes knowledge of several computational thinking
concepts, such as, data, processing, information, sequencing, loops, parallel processing, events, conditions, operators,
variables, and dataflow of control.
learner knowledge for computational thinking (lkct
) includes knowledge about learners’ difficulties in (a)
developing abstractions that are beyond of any particular programming language or tool, denoted as lk
ct(a)
, (b)
generalizing from one solution to another by identifying common patterns, denoted as lkct(g)
, (c) decomposing
complex problems to simpler ones, designated as lkct(d)
, (d) thinking algorithmically to solve a problem (including
difficulties in understanding relevant concepts, such as sequencing, loops, flow of control, conditions, etc.), denoted
as lk
ct(algo)
, and (e) debugging, denoted as lkct(debug).
pedagogical knowledge for computational thinking (pkct
) includes the general pedagogical knowledge applicable to
all other content domains (i.e., the use of questions to promote understanding, use of examples, explanation,
demonstration), in addition to knowledge about subject-specific pedagogical practices pertinent to computational
thinking. pkct
is defined in terms of the following teaching tactics: (a) model how to problem solve or think about a
problem in iterative and incremental ways, (b) present or explain a solution to a problem in terms of a series of steps,
(c) model decision making based on conditions, (d) do something based on (and expanding) what others or you have
done (reuse and remix), (e) show how a complex problem can be decomposed into simpler problems and develop a
solution in increments, (f) show how to design a model before writing a computer program for solving the problem,
and (g) try things out as you go and make revisions based on what happens.
technology knowledge for computational thinking (tkct
) includes knowledge and skills about how to (a)
operate/use a variety of technologies, (b) invent new technologies/tools, (c) solve a task using technical processes,
methods, and tools, and (d) learn and adapt to new technologies.
context knowledge for computational thinking (cxct
) is defined from the point of view explicated by porrashernández and salinas-amescua (2013) who proposed to regard context knowledge along two important
dimensions, namely (a) scope (macro, mezzo, and micro level context) and (b) actor (students’ and teachers’ inner
and external context). macro context is defined by social, political, technological, and economic conditions at a
global level that influence the value and worth of adding computer science and computational thinking to the school
curriculum. mezzo context is defined by the social, cultural, political, organizational, and economic conditions
settled in the local community and the educational institution about the value of computational thinking in children’s
lives. finally, micro context is the level that deals with in-class conditions for learning (e.g., available resources for
computational thinking, available technologies, norms and policies, beliefs, expectations, teachers’ and students’
goals about computational thinking). in addition, porras-hernández and salinas-amescua (2013) argued that in order
to comprehend teachers’ uses of technology, it is important to consider teachers’ and students’ (actors’) unique
characteristics, as they are brought in the context as separate objects of knowledge with internal (e.g., students’
needs, preferences, misconceptions, learning difficulties, prior knowledge, teachers’ self-efficacy, pedagogical
beliefs) and external contexts (e.g., ethnicity, culture, community, and socioeconomic background).
lastly, tpck for computational thinking (tpckct
) is defined as knowing how to: (1) identify a range of creative
and authentic computational thinking projects; (2) identify a range of technologies with an appropriate set of
affordances in terms of providing the necessary technological means for practicing/teaching the whole range of
computational thinking skills with each project; and (3) use the affordances of technology to transform ckct
and
pkct
using representations that make the overall computational thinking experience comprehensible for all learners.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
55
the question that naturally arises at this point is: “what form should teacher preparation take, so that teachers
develop their tpckct
competencies adequately?” in the next section, we provide preliminary research evidence
from a teacher education course on preparing teachers how to teach computational thinking.
teacher preparation in developing tpck competencies for computational thinking
in the fall of 2015, fifteen elementary school teachers pursuing a master’s degree in instructional technology were
enrolled in a course on learning how to teach computational thinking in their k-6 classrooms. all teachers were
unfamiliar with computational thinking and had no prior experiences with computer programming. the teachers
participated in 13 three-hour weekly meetings. the participants were engaged in hands-on design activities with the
scratch computer programming environment. the learning-by-design approach, which has been shown to be
effective in contemporary teacher development studies (mckenney, kali, markauskaite, & voogt, 2015), was used in
the course to engage teachers in designing models of different problem situations before constructing computer
programs for solving the problems.
the course instructor initially engaged the teachers in authentic problem solving by asking them to think about the
city/town they were living and identify ways of how people’s lives in those places could be improved. the teachers
explained their thinking about possible improvements and then the instructor asked them to think about how computers
could be used for solving some of the problems they identified. a brainstorming activity resulted in ten different ideas
that constituted the real-life tasks that the course instructor used to teach the teachers about computational thinking. the
ten tasks were sequenced from simple to complex based on the involvedness of the solution.
for each problem, teachers were taught how to create a model first before writing a computer program for solving the
problem. creating a model proved to be extremely difficult for the teachers and often times they asked their
instructor for help. early attempts in creating models resulted in models containing lots of unnecessary information,
but, gradually teachers, with the help of the course instructor learned that models are abstractions of something free
from inessential detail. the teachers were taught how to create models through a process that was explicitly taught to
them and involved identification of the important entities of the model, their characteristics (parameters in the
model), and relationships, either quantitative or qualitative, between the parameters of the entities. the teachers
showed commitment in developing the best models they could possibly create, and, often times they exhibited lots of
creative ideas of how to make them better.
in regards to teaching teachers computer programming, the course instructor used systematically the following
pedagogical strategies: (a) decide what sprites are needed for your project, (b) decide what scripts are needed for
your project, (c) organize the scripts in meaningful ways for you and others, (d) develop some code, try it out, then
develop some more, (e) test and debug, and (f) build or extend on existing projects or ideas. during the programming
tasks, computational concepts such as, data, processing, information, sequencing, loops, parallel processing, events,
conditions, operators, variables, and dataflow of control, were explicitly explained and illustrated with lots of
programming examples. teachers had no difficulties with understanding programming concepts, even though they
found the concepts of variables and conditional logic more challenging than the others.
concluding remarks
in conclusion, the authors in this paper presented a computational thinking curriculum framework for designing a
curriculum for k-6, an area of research that is still in its infancy, described design guidelines for enacting the
curriculum framework, and defined tpckct
as the body of knowledge that teachers need to have to be able to teach
the curriculum in k-6. in addition, the authors provided an example of a teacher preparation course that was
specifically designed to promote teachers’ tpckct
. it is recognized that more empirical evidence in the form of rich
educational cases is needed in terms of further investigating the effectiveness of the frameworks proposed herein in a
variety of contexts. it is expected that with the gradual adoption of computer science as a distinct school subject in
the k-6 curriculum of countries around the world, our knowledge and research base regarding the issues discussed in
this paper will dramatically expand over the next several years.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
56
references
angeli, c., & valanides, n. (2005). preservice teachers as ict designers: an instructional design model based on an expanded
view of pedagogical content knowledge. journal of computer-assisted learning, 21(4), 292-302.
angeli, c., & valanides, n. (2009). epistemological and methodological issues for the conceptualization, development, and
assessment of ict-tpck: advances in technological pedagogical content knowledge (tpck). computers & education, 52, 154-
168.
armoni, m. (2012). teaching cs in kindergarten: how early can the pipeline begin? acm inroads, 3(4), 18-19.
astrachan, o., & briggs, a. (2012). the cs principles project. acm inroads, 3(2), 38-42.
barr, v., & stephenson, c. (2011). bringing computational thinking to k-12: what is involved and what is the role of the
computer science education community? acm inroads, 2(1), 48-54.
bell, t. c., witten, i. h., fellows, m. r., adams, r., & mckenzie, j. (2015). cs unplugged: an enrichment and extension
programme for primary-aged students. retrieved from http://csunplugged.org/wpcontent/uploads/2015/03/csunplugged_os_2015_v3.1.pdf
czerkawski, b. (2015). computational thinking in virtual learning environments. in proceedings of e-learn: world conference
on e-learning in corporate, government, healthcare, and higher education 2015 (pp. 993-997). chesapeake, va: association
for the advancement of computing in education (aace).
desjardins, m. (2015). creating ap® cs principles: let many flowers bloom. acm inroads, 6(4), 60-66.
fluck, a., webb, m., cox, m., angeli, c., malyn-smith, j., voogt, j., & zagami, j. (2016). arguing for computer science in the
school curriculum. educational technology and society, 19(3), 38-46.
furber, s. (2012). shut down or restart? the way forward for computing in uk schools. london, uk: the royal society.
gal-ezer, j., & stephenson, c. (2010). computer science teacher preparation is critical. acm inroads, 1(1), 61-66.
gibson, j. p. (2012, july). teaching graph algorithms to children of all ages. in proceedings of the 17th annual sigcse
conference on innovation and technology in computer science education (iticse’12) (pp. 34–39). new york, ny: acm.
goode, j., chapman, g., & margolis, j. (2012). beyond curriculum: the exploring computer science program. acm
inroads, 3(2), 47-53.
hazzan, o., lapidot, t., & ragonis, n. (2011). guide to teaching computer science: an activity-based approach. london, uk:
springer.
hubwieser, p., magenheim, j., mühling, a., & ruf, a. (2013, august). towards a conceptualization of pedagogical content
knowledge for computer science. in proceedings of the ninth annual international acm conference on international computing
education research (pp. 1-8). new york, ny: acm.
husing, t., & korte, w. b. (2010). evaluation of the implementation of the communication of the european commission: e-skills
for the 21st century. bonn, germany: empirica. retrieved from http://hdl.voced.edu.au/10707/323186
koehler, m. j., & mishra p. (2008). introducing tpck. in aacte committee on innovation and technology (eds.), handbook
of technological pedagogical content knowledge (tpck) for educators (pp. 3–29). new york, ny: routledge.
kumar, d. (2014). digital playgrounds for early computing education. acm inroads, 5(1), 20-21.
mckenney, s., kali, y., markauskaite, l., & voogt, j. (2015). teacher design knowledge for technology enhanced learning: an
ecological framework for investigating assets and needs. instructional science, 43(2), 181-202.
micheuz, p. (2008). some findings on informatics education in austrian academic secondary schools. informatics in education,
7(2), 221-236.
national research council. (2010). committee for the workshops on computational thinking: report of a workshop on the scope
and nature of computational thinking. washington, dc: national academy press. doi:10.17226/12840
niess m. l. (2005). preparing teachers to teach science and mathematics with technology: developing a technology pedagogical
content knowledge. teaching and teacher education, 21, 509–523.
papert, s. (1980). mindstorms: children, computers, and powerful ideas. new york, ny: basic books, inc.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt
57
porras-hernández, l. h., & salinas-amescua, b. (2013). strengthening tpack: a broader notion of context and the use of
teacher's narratives to reveal knowledge construction. journal of educational computing research, 48(2), 223-244.
prottsman, k. (2014). computer science for the elementary classroom. acm inroads, 5(4), 60-63.
saeli, m. (2012). teaching programming for secondary school: a pedagogical content knowledge based approach (unpublished
doctoral dissertation). technische universiteit eindhoven, netherlands.
saeli, m., perrenet, j., jochems, w. m., & zwaneveld, b. (2011). teaching programming in secondary school: a pedagogical
content knowledge perspective. informatics in education, 10(1), 73-88.
selby, c. c. (2014). how can the teaching of programming be used to enhance computational thinking skills? (unpublished
doctoral dissertation). university of southampton, southampton, uk.
shulman, l. s. (1986). those who understand: knowledge growth in teaching. educational researcher, 15, 4–14.
shulman, l. s. (1987). knowledge and teaching: foundations of the new reform. harvard educational review, 57, 1-23.
stephenson, c., gal-ezer, j., haberman, b., & verno, a. (2005). the new educational imperative: improving high school
computer science education. new york, ny: computer science teachers association (csta).
thalheim, b. (2000). fundamentals of entity-relationship modeling. new york, ny: springer.
tucker, a. b., deek, f., jones, j., mccowan, d., stephenson, c., & verno, a. (2003). a model curriculum for k-12 computer
science. new york, ny: acm/computer science teachers association.
van diepen, n., perrenet, j., & zwaneveld, b. (2011). which way with informatics in high schools in the netherlands? the dutch
dilemma. informatics in education, 10(1), 123-148.
van driel, j. h., & berry, a. (2012). teacher professional development focusing on pedagogical content knowledge. educational
researcher, 41(1), 26-28.
van den akker, j. (2010). building bridges: how research may improve curriculum policies and classroom practices. in beyond
lisbon 2010: perspectives from research and development for education policy in europe (pp. 177-195). aarau, switzerland:
cidree.
van merriënboer, j. v., & kirschner, p. a. (2007). ten steps to complex learning: a systematic approach to four-component
instructional design. mahwah, nj: lawrence erlbaum.
voogt, j., fisser, p., good, j., mishra, p., & yadav, a. (2015). computational thinking in compulsory education: towards an
agenda for research and practice. education and information technologies, 20(4), 715-728.
webb, m., fluck, a., cox, m., angeli-valanides, c., malyn-smith, j., voogt, j., & zagami, j. (2015). curriculum: advancing
understanding of the roles of computer science/informatics in the curriculum. in k-w lai (ed.), edusummit 2015 summary
report (pp. 60-68). retrieved from http://www.curtin.edu.au/edusummit/local/docs/edusummit2015-ebook.pdf
wing, j. (2006). computational thinking. communications of the acm, 49(3), 33-35.
wing, j. m. (2011, march). computational thinking. retrieved from
https://csta.acm.org/curriculum/sub/currfiles/wingctprez.pdf
wolf, p., & brandt, r. (1998). what do we know from brain research? educational leadership, 56(3), 8-13.
this content downloaded from
142.231.78.28 on wed, 29 jan 2020 21:10:21 utc
all use subject to htt"
"computational thinking builds on the power and limits of computing processes, whether they are executed by a human or by a machine. computational methods and models give us the courage to solve problems and design systems that no one of us would be capable of tackling alone. computational thinking confronts the riddle of machine intelligence: what can humans do better than computers? and what can computers do better than humans? most fundamentally it addresses the question: what is computable? today, we know only parts of the answers to such questions.

computational thinking is a fundamental skill for everyone, not just for computer scientists. to reading, writing, and arithmetic, we should add computational thinking to every child's analytical ability. just as the printing press facilitated the spread of the three rs, what is appropriately incestuous about this vision is that computing and computers facilitate the spread of computational thinking.

computational thinking involves solving problems, designing systems, and understanding human behavior, by drawing on the concepts fundamental to computer science. computational thinking includes a range of mental tools that reflect the breadth of the field of computer science.

having to solve a particular problem, we might ask: how difficult is it to solve? and what's the best way to solve it? computer science rests on solid theoretical underpinnings to answer such questions precisely. stating the difficulty of a problem accounts for the underlying power of the machinethe computing device that will run the solution. we must consider the machine's instruction set, its resource constraints, and its operating environment.

in solving a problem efficiently, we might further ask whether an approximate solution is good enough, whether we can use randomization to our advantage, and whether false positives or false negatives are allowed. computational thinking is reformulating a seemingly difficult problem into one we know how to solve, perhaps by reduction, embedding, transformation, or simulation.

computational thinking is thinking recursively. it is parallel processing. it is interpreting code as data and data as code. it is type checking as the generalization of dimensional analysis. it is recognizing both the virtues and the dangers of aliasing, or giving someone or something more than one name. it is recognizing both the cost and power of indirect addressing and procedure call. it is judging a program not just for correctness and efficiency but for aesthetics, and a system's design for simplicity and elegance.

computational thinking is using abstraction and decomposition when attacking a large complex task or designing a large complex system. it is separation of concerns. it is choosing an appropriate representation for a problem or modeling the relevant aspects of a problem to make it tractable. it is using invariants to describe a system's behavior succinctly and declaratively. it is having the confidence we can safely use, modify, and influence a large complex system without understanding its every detail. it is modularizing something in anticipation of multiple users or prefetching and caching in anticipation of future use.

computational thinking is thinking in terms of prevention, protection, and recovery from worst-case scenarios through redundancy, damage containment, and error correction. it is calling gridlock deadlock and contracts interfaces. it is learning to avoid race conditions when synchronizing meetings with one another.

computational thinking is using heuristic reasoning to discover a solution. it is planning, learning, and scheduling in the presence of uncertainty. it is search, search, and more search, resulting in a list of web pages, a strategy for winning a game, or a counterexample. computational thinking is using massive amounts of data to speed up computation. it is making trade-offs between time and space and between processing power and storage capacity.

thinking like a computer scientist means more than being able to program a computer. it requires thinking at multiple levels of abstraction.

consider these everyday examples: when your daughter goes to school in the morning, she puts in her backpack the things she needs for the day; that's prefetching and caching. when your son loses his mittens, you suggest he retrace his steps; that's backtracking. at what point do you stop renting skis and buy yourself a pair?; that's online algorithms. which line do you stand in at the supermarket?; that's performance modeling for multi-server systems. why does your telephone still work during a power outage?; that's independence of failure and redundancy in design. how do completely automated public turing test(s) to tell computers and humans apart, or captchas, authenticate humans?; that's exploiting the difficulty of solving hard ai problems to foil computing agents.

computational thinking will have become ingrained in everyone's lives when words like algorithm and precondition are part of everyone's vocabulary; when nondeterminism and garbage collection take on the meanings used by computer scientists; and when trees are drawn upside down.

we have witnessed the influence of computational thinking on other disciplines. for example, machine learning has transformed statistics. statistical learning is being used for problems on a scale, in terms of both data size and dimension, unimaginable only a few years ago. statistics departments in all kinds of organizations are hiring computer scientists. schools of computer science are embracing existing or starting up new statistics departments.

computer scientists' recent interest in biology is driven by their belief that biologists can benefit from computational thinking. computer science's contribution to biology goes beyond the ability to search through vast amounts of sequence data looking for patterns. the hope is that data structures and algorithmsour computational abstractions and methodscan represent the structure of proteins in ways that elucidate their function. computational biology is changing the way biologists think. similarly, computational game theory is changing the way economists think; nanocomputing, the way chemists think; and quantum computing, the way physicists think.

this kind of thinking will be part of the skill set of not only other scientists but of everyone else. ubiquitous computing is to today as computational thinking is to tomorrow. ubiquitous computing was yesterday's dream that became today's reality; computational thinking is tomorrow's reality.

back to top  what it is, and isn't

computer science is the study of computationwhat can be computed and how to compute it. computational thinking thus has the following characteristics:

conceptualizing, not programming. computer science is not computer programming. thinking like a computer scientist means more than being able to program a computer. it requires thinking at multiple levels of abstraction;
fundamental, not rote skill. a fundamental skill is something every human being must know to function in modern society. rote means a mechanical routine. ironically, not until computer science solves the ai grand challenge of making computers think like humans will thinking be rote;
a way that humans, not computers, think. computational thinking is a way humans solve problems; it is not trying to get humans to think like computers. computers are dull and boring; humans are clever and imaginative. we humans make computers exciting. equipped with computing devices, we use our cleverness to tackle problems we would not dare take on before the age of computing and build systems with functionality limited only by our imaginations;
complements and combines mathematical and engineering thinking. computer science inherently draws on mathematical thinking, given that, like all sciences, its formal foundations rest on mathematics. computer science inherently draws on engineering thinking, given that we build systems that interact with the real world. the constraints of the underlying computing device force computer scientists to think computationally, not just mathematically. being free to build virtual worlds enables us to engineer systems beyond the physical world;
ideas, not artifacts. it's not just the software and hardware artifacts we produce that will be physically present everywhere and touch our lives all the time, it will be the computational concepts we use to approach and solve problems, manage our daily lives, and communicate and interact with other people; and
for everyone, everywhere. computational thinking will be a reality when it is so integral to human endeavors it disappears as an explicit philosophy.
many people equate computer science with computer programming. some parents see only a narrow range of job opportunities for their children who major in computer science. many people think the fundamental research in computer science is done and that only the engineering remains. computational thinking is a grand vision to guide computer science educators, researchers, and practitioners as we act to change society's image of the field. we especially need to reach the pre-college audience, including teachers, parents, and students, sending them two main messages:

intellectually challenging and engaging scientific problems remain to be understood and solved. the problem domain and solution domain are limited only by our own curiosity and creativity; and
one can major in computer science and do anything. one can major in english or mathematics and go on to a multitude of different careers. ditto computer science. one can major in computer science and go on to a career in medicine, law, business, politics, any type of science or engineering, and even the arts.
professors of computer science should teach a course called ""ways to think like a computer scientist"" to college freshmen, making it available to non-majors, not just to computer science majors. we should expose pre-college students to computational methods and models. rather than bemoan the decline of interest in computer science or the decline in funding for research in computer science, we should look to inspire the public's interest in the intellectual adventure of the field. we'll thus spread the joy, awe, and power of computer science, aiming to make computational thinking commonplace."
"1. introduction
this work presents and discusses a specific didactic approach
to support the development of students’ computational thinking
(ct) skills in educational robotics (er) activities. as wing [1]
argues, computational thinking (ct) is a fundamental skill for
everyone and it should be considered as an important component
of every child’s analytical ability along with reading, writing, and
arithmetic. recently, there has been growing recognition of the
importance of ct in controlling and managing cognitive activities,
as well as understanding and solving problems in a wide range
of contexts, not only in the field of computer science, but in all
disciplines [2].
∗ corresponding author. tel.: +30 6977718143.
e-mail addresses: atmatzid@csd.auth.gr (s. atmatzidou), sdemetri@csd.auth.gr
(s. demetriadis).
robotics can be used as a tool that offers opportunities for students to engage and develop computational thinking skills [3,4].
educational robotics is being introduced in many schools as an
innovative learning environment, enhancing and building higher
order thinking skills and abilities, and helping students solve complex problems [5]. furthermore, a guided instruction approach
using robots facilitates teamwork, develops conceptual understanding, enhances critical thinking, and promotes higher-order
learning in the domains of mathematics and science [6].
this paper describes the implementation of er activity in
secondary school, focusing on the different possible impacts that
the instructional approach might have on the development of
students’ ct skills depending on their age and gender. guided
by worksheets, students worked in small groups to solve robot
programming problems. the level of their ct skills was evaluated
at different times during the activity, with focus on five key ct
constructs—abstraction, generalisation, algorithm, modularity and
decomposition.
http://dx.doi.org/10.1016/j.robot.2015.10.008
0921-8890/© 2015 elsevier b.v. all rights reserved.
662 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
2. background
robotics is usually seen as an interdisciplinary activity drawing
mostly in science, mathematics, informatics and technology and
offering major new benefits to education in general at all levels
[7,8]. educational robotics is a powerful, flexible, teaching and
learning tool, encouraging students to construct and control robots
using specific programming languages [7]. the roots of er are to be
found in seymour papert’s work, creator of the logo programming
language [9]. papert suggests that learning is most effective when
students are experiencing and discovering things for themselves.
he also argues that robotics activities have tremendous potential
to improve classroom teaching [9,10]. drawing on the theoretical
underpinnings of papert’s constructionism and vygotsky’s sociocognitive approaches, er activities help students transform themselves from passive to active learners, constructing new knowledge
by collaborating with their peers and developing essential mental skills by acting as researchers. many studies indicate that er
activities have a positive impact on the development of students’
critical thinking, problem solving and metacognitive skills
[5,11,12] and also on the learning of a programming language
[7,13,14]. other studies demonstrate how er promotes a joyful
mode of learning, while advancing students’ motivation, collaboration, self-confidence and creativity [15–17]. many researchers argue that robotics programs provide a valuable avenue to increase
students’ interest and participation in science, technology, engineering and mathematics (stem), while they motivate them to
pursue a career in one of these fields (e.g. [18–20]). however, certain researchers point out that although robotics seems to be an
excellent tool for teaching and learning and a compelling topic for
students of all ages, the pedagogy of teaching with robotics is still
in its infancy [7,21]. it is also noted that more research is needed to
point out how to work with educational robotics to help students
develop specific skills [10,22].
as this study focuses on er as a means for advancing students’
ct skills, we concisely review next the ct theoretical framework
and studies on the er-ct relationship. wing [1] describes ct as a
type of analytical thinking that draws on concepts fundamental to
computer science and provides a way for solving problems, designing systems, and understanding human behaviour. ct roots go back
to papert’s ideas of the computer being the children’s machine that
would allow them to develop procedural thinking through programming, and refers to ways of algorithmically solving problems
and to the acquisition of technological fluency [9].
in the literature there are multiple definitions of ct and several suggestions about which skills and abilities are relevant to ct
and how to integrate ct in the curricula of all grades. wing [2] asserts that ct has the potential to advance the students’ problemsolving skills through processes such as abstraction, generalisation,
decomposition, algorithm design and separation of concerns. astrachan et al. [23] emphasise skills such as: developing computational artefacts, abstracting, analysing problems and artefacts, and
communicating and working effectively in teams. still others
argue that the key concepts of ct are abstraction, automation, simulation, evaluation, algorithm building, conditional logic, debugging, decomposition, problem analysis, distributed computing and
effective teamwork [24–26]. emphasis is also given to the view that
the educational benefits of ct transfer to any domain – not only in
the field of computer science – by enhancing and reinforcing intellectual skills [1,27]. yadav [28] argues emphatically that ‘ct in education has the potential to significantly advance the problem-solving
skills of k-12 students’.
naturally, researchers have started exploring also the potential of educational robotics to promote the development of ct
[4,29–31]. certain studies emphasise that children who program
robots learn and apply core ct concepts such as abstraction, automation, analysis, decomposition, modularisation and iterative
design [4,29,30]. a 2011 study by national science foundation [4]
provided evidence that student programmers in a robotics project,
developed abstraction, automation, and analysis related skills,
while programming the robot agent to interact with its environment. however, it is worth mentioning according to researchers
that the field requires systematic assessment procedures.
research engaging younger children reported also positive
outcomes, demonstrating that children 4–6 years old can build
simple robotics projects becoming acquainted with powerful ideas
of engineering, technology, and computer programming while
also building ct skills [30,32,33]. more specifically, a study with
53 kindergarten children [33] using lego wedo robots and the
cherp (creative hybrid environment for robotics programming)
language, reported that the children were involved and understood
basic programming and ct concepts relevant to sequencing and
choosing the correct instructions. a similar study by kazakoff
et al. with 27 kindergarten children, focusing solely on sequencing,
showed improvement of the students’ scores from the first activity
to the last [29].
regarding elder children (junior and high school students),
studies report also positive results on the development of ct
skills. grover [27] developed a curriculum for teaching ct
language and ct principles in schools. the results indicated that
students after the intervention were capable of using certain
ct related vocabulary and principles (such as conditional logic
and decomposition), whereas other concepts like abstraction,
representation and algorithmic flow control were seldom used.
another study by touretzky et al. [34] engaging children aged
10–17 (some of them with special abilities), focused on abstraction
across different programming environments and especially on
deep and abstract understanding of programming concepts. the
researchers concluded that – despite the limitations – robotics
is a helpful tool for young students, ‘‘facilitating a more abstract
understanding’’. penmetcha [35] investigated the effects of er
activity on university students exploring the relationship between
robotics and developing programming and algorithmic thinking.
the results showed that robotics fulfil their purpose as a
medium for incorporating ct practices, regardless of the students’
background, and can be used to teach concepts such as designing,
programming and testing at a more abstract level. as in the other
studies, limitations were reported relevant to the study small
sample size [27]. finally, a case study by eguchi [36] explores
the effects of a robotics competition on students’ ct and problem
solving skills reporting an overall very positive effect.
overall, although the ct concept has attracted considerable
attention, the literature on implementing ct in a k-12 setting is
still relatively sparse [28]. there is also lack of empirical evidence
in defining the explicit ct boundaries [37], although recent articles
begin to describe what it looks like [4,30,38,39]. more than that,
research into how ct can be introduced in the classroom is on
the early stages and there is shortage of description about how
children can learn and develop ct skills [27,28,37]. another issue is
to understand at what age – or grade level – children are ready to be
familiar with advanced concepts such as abstraction, automation,
decomposition, etc. and how to teach those skills progressively [4].
likewise, there is little agreement on strategies for assessing the
development of ct in young people [23,38,40,41]. existing studies
typically employ a student group of specific age thus limiting the
generalisation of the results to other age groups (e.g. [8,29,33]),
have small sample sizes (e.g. [27,29,34,35]), and do not provide
explicit teacher guidance on how to organise a well-guided er
activity to promote students’ ct skills. researchers also differ in the
way they build an operational ct skills framework to apply to their
studies. table 1 presents the various ct skill models employed in
various er studies.
another issue of interest is the gender differences observed
in studies on stem learning activities. much research has
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 663
table 1
ct skills models employed in various er studies.
article context ct skills model
lee et al. [4] k-12 abstraction, automation, and analysis.
grover [27] 10 students mean age: 13 computational thinking language (ctl) [42] abstraction, taskbreakdown, conditional logic,
representation, algorithm, and debugging.
penmetcha [35] 26 university students abstraction, algorithm, programming, and designing.
bers et al. [33] 53 kindergarten students sequencing
kazakoff et al. [29] 27 kindergarten students sequencing
touretzky et al. [34] 31 students aged 10–17 abstraction between three software frameworks (kodu, alice, lego nxt), recognise fundamental
programming concepts.
bers et al. [33] 53 kindergarten students debugging, correspondence, sequencing, and control flow.
eguchi [36] 168 students aged 10–19 problem solving, debugging, prototyping, decomposition, logical thinking, creating step-by-step
procedure, analysing skills, critical thinking, iteration, and debugging.
documented gender differences, showing that men have higher
levels of self-efficacy and higher probability of success in stemrelated fields (e.g., [43,44]). however, over the past few decades
the gender gap has narrowed. the stereotypic gender role might
have a clear impact on attitudes about technology but this can
be positively changed under the right conditions [45,46]. studies
indicate that both genders can have a successful and rewarding
experience being exposed to robotics activities. milto et al. [47]
found that although men were more confident in their abilities
than women, in an introductory engineering class women and men
displayed equivalent competency in robotics activities. similarly,
nourbakhsh et al. [48] investigated the gender differences in a
robotics course involving high school students. according to the
study, although girls entered the course with less confidence than
boys and were more likely to have struggled with programming, by
the end of the course girls’ confidence increased more than boys’.
another study by cheng [49] reported that in terms of assembling
and programming lego robots, while there were slightly higher
average scores for male students it was not of significant difference.
however, research on comparing the development of ct skills
between genders in k-12 robotics activities is relatively sparse.
while research has been conducted on gender differences in many
science and mathematics areas [50] limited research has been
carried out into gender differences in robotics and programming
achievement especially in early childhood [51].
research motivation and key research question
considering the above background, the current study aimed
to conduct an instructional well-guided er activity, recruit a
relatively large student sample size and explore the impact of
the activity on students’ ct skills, comparing student groups of
different age and gender. thus, the overarching research question
set by the study is: ‘‘are students of different age and gender
developing ct skills in the same way in the context of educational
robotics activity?’’
3. method
3.1. participants
for the purpose of our study we conducted a series of robotic
training seminars in public schools in the area of thessaloniki.
in total, 164 students of two different school levels (junior high
and high vocational) participated in the study. specifically, in the
seminars were engaged:
• junior high (j): 89, k-9 students (age: 15, 48 boys and 41 girls)
• high vocational (h): 75, k-12 students (age: 18, 64 boys and 11
girls).
3.2. a model for ct skills
to operationalise the ct theoretical approach, we focused on
five core dimensions of the broader ct conceptual framework.
these included: abstraction, generalisation, algorithm, modularity
and decomposition. the proposed model encompasses skills that
can easily emerge when students engage in educational robotics
activities. in detail, the proposed model for ct skills presented in
table 2.
3.3. implementation procedure
in total, we conducted 8 training robotics seminars (4 at junior
high and 4 at high vocational schools’) during the 2012–2013
school year. the lego mindstorms nxt 2.0 educational robotics kit
was used in all seminars. organised and supervised by the main
researchers (authors of this work), each seminar comprised 11
sessions (2 h each, conducted once a week). trained postgraduate
students (‘‘trainers’’) assisted with the practicalities of the
activity (e.g. organising student groups, handling out worksheets,
encouraging and scaffolding teams, administering questionnaires,
etc.). the seminars were conducted during the typical school time
schedule and the class teachers remained in the classroom during
the activity, simply helping to maintain the flow of each lesson. in
detail, the sessions were as follows:
1st session: in the beginning, the teacher introduced robotics
in general, the lego mindstorms nxt robot and the lego nxtg programming environment. then she handed out the profile
questionnaire (pq) to be filled in individually by students. working
in groups, the students implemented their first program using their
own robot kit. emphasis was placed on the concept of algorithm
and the importance of developing precise instructions that when
implemented they lead to the solution of the problems.
2nd session: the objective here was students’ familiarisation
with some basic programming concepts (sequential structure and
loop structure). the students also became familiar with the motors,
the touch sensor, the sound sensor and finally with some basic
feature of nxt, such us displaying images on the screen of the
robot. in this session, students programmed their robots to dance
and presented them to the other groups. the session placed focus
on the abstraction and generalisation concepts. participants were
prompted to reflect on the role of these two concepts in their own
problem solving activities.
3rd and 4th sessions: the students worked on the control
structure and on how to use the ultrasonic sensor and the wait
block. they also practised conversion of numbers to text in order
to show a numerical value on the screen. in the last activity of
the 4th session the challenge was to create a robotic alarm system
that detects motion and sound. at the end of the fourth session
we administered the first questionnaire (q1) in order to assess the
students’ level of ct skills development. in 3rd session the focus
here was on modularity and decomposition and their importance
in optimising the structure of an algorithm implementation. from
the 4th session onwards, the activities challenged the students to
engage in practising all the concepts of the ct model and develop
relevant skills.
5th and 6th sessions: the students became familiar with the
operation of light sensor, the creation of reusable subprograms
664 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
table 2
the ct skills model applied in the current study.
ct skills description student skills
(the student should be able to. . . )
abstraction abstraction is the process of creating something simple from
something complicated, by leaving out the irrelevant details, finding
the relevant patterns, and separating ideas from tangible details [52].
wing [2] argues that the essence of ct is abstraction.
1. separate the important from the redundant information.
2. analyse and specify common behaviours or programming structures
between different scripts.
3. identify abstractions between different programming environments.
generalisation generalisation is transferring a problem-solving process to a wide
variety of problems [38].
expand an existing solution in a given problem to cover more
possibilities/cases.
algorithm algorithm is a practice of writing step-by-step specific and explicit
instructions for carrying out a process.
kazimoglu et al. [37] argue that selection of appropriate algorithmic
techniques is a crucial part of ct.
1. explicitly state the algorithm steps.
2. identify different effective algorithms for a given problem.
3. find the most efficient algorithm.
modularity modularity is the development of autonomous processes that
encapsulate a set of often used commands performing a specific
function and might be used in the same or different problems [38].
develop autonomous code sections for use in the same or different
problems.
decomposition decomposition is the process of breaking down problems into
smaller parts that may be more easily solved.
break down a problem into smaller/simpler parts that are easier to
manage.
wing [2] argues that ct is using decomposition when attacking or
designing a large complex task.
(make a new ‘‘my block’’), the use of the lamp block and the
parallel programming. the students programmed a recycler robot,
where the robot moves following a black line and sorts items to be
recycled depending on their colours.
7th and 8th sessions: the students worked on the concept
of variable and basic arithmetic operators. in this context, the
students implemented a security guard robot that moves around a
building and detects every motion, sound and change in lightness.
9th and 10th sessions: students were given activities of
increased difficulty to practise their developing ct skills in the
context of more complex authentic problems, such as a car that
moves following the traffic code, etc. the project allowed children
to demonstrate the powerful ideas they learned over the previous
sessions as well as to apply them and continue learning by solving
a new problem. a second questionnaire (q2) was administered at
the end of this session to assess the students’ current level of ct
skills development.
11th session: in the final session, student groups were given the
‘‘final challenge’’ that is a demanding robot programming task for
groups to compete against each other. the winner was the group
that proposed an effective and efficient task solution (optimised
code and fastest solution).
after the completion of each seminar, two other instruments
were used to capture the students’ level of ct skills and also
their views regarding the er training experience. these were: (a)
a ‘think-aloud’ protocol implementation, (b) a student’s opinion
questionnaire. overall, the procedure of each training seminar and
the various data collection instruments are presented in fig. 1.
3.4. didactic model
in each seminar, students worked in groups of three (or four
if necessary) and were guided by worksheets in the investigating
robot programming tasks of gradually increased complexity. these
enabled them to start constructing understanding and developing
the ct skills prescribed by our model. the worksheets also directed
students to assume the roles of analyst (analyse the problem),
algorithm designer (describe the algorithm), programmer (write
the code), or debugger/evaluator (review and assess the solution).
the students exchanged roles successively as the activities evolved.
during the sessions, the trainers acted as facilitators to scaffold
students while solving programming tasks. after the 5th session,
trainers gradually faded their support. this means that detailed
guidance was gradually replaced by simple prompts to students
to assume the relevant role and practise the acquired skills on
their own capacity [5]. the trainers were ready to fade-in again
and support students should the circumstances require it. to
trigger students’ reflection and development of ct modelled skills,
prompts such as the following (see table 3) were included in the
worksheets. peers were expected to spend some time discussing
how to answer these prompts; then one peer was assigned the
responsibility of writing down the group answer to the worksheet.
3.5. measures, instruments and data analysis
the instruments that we used to collect evaluation data (and
respective measures) are as follows:
profile questionnaire (pq): an individual questionnaire was administered in the beginning of each seminar. the questionnaire
recorded some simple demographic data (e.g. student gender), the
students’ background on computer use (for example, frequency
of computer use, computer experience, etc.) and experience with
robotics (such as previous knowledge on constructing and programming robots).
two intermediate questionnaires (q1 and q2): q1 was handed out
after the 4th and q2 after the 10th session. both questionnaires
asked students to solve programming problems and practise ct
skills during their solution process; for example, identify common
programming structures that guide robot behaviour in two tasks
(abstraction), propose a more general solution (generalisation),
describe step-by-step the solution process (algorithm), etc. the
assessment of students’ answers in q1 and q2 was based on a
graded criterion instrument (rubric) using a 4-point likert scale
(1 = ‘unsatisfactory’, 2 = ‘quite satisfactory’, 3 = ‘satisfactory’,
4 = ‘excellent’). there were specific criteria for each construct of
the ct model (abstraction, generalisation, algorithm, modularity,
decomposition) and so each student was assigned a grade for each
ct construct after answering the q1 and q2 questionnaires. a
mean value was also calculated across all ct constructs (in q1
and q2 respectively). we consider the q1 and q2 measurements
as indicators of student’s level of ct skills development at certain
phases during the training seminar (q1 after the 4th session,
q2 after the 10th session). in the following, we refer to q1
measurement as ‘‘students’ starting ct skill level’’ (or simply ct-4)
and to q2 measurement as ‘‘students’ final ct skill level’’ (or simply
ct-10). as ct-4 is a measurement reflecting students’ ct skills
early in the training, we use it as covariate in our statistical analysis.
we would like to clarify that although administering a pre-test
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 665
fig. 1. seminar organisational structure: lower row indicates session when ct skills were introduced; arrows indicate sessions when evaluation interventions were
conducted.
table 3
ct skills and relevant prompts to trigger students’ self-reflection.
abstraction what is common in robot behaviour in both programs? how would you describe this common behaviour? what is the common
programming structure? which is the information you actually need? what is irrelevant detail and not necessary in your description?
generalisation propose a more general solution for the activity above, that can cover a wider variety of cases. is the proposed solution more general and
why?
algorithm write step-by-step the operations needed so that the robot can do what the problem asks. what are the steps i will need to do to solve this
problem?
modularity are there any parts of the code that you have met before? have you created your own blocks for these? what are they? do you expect to
need some parts of this particular code in the future or in a different problem?
decomposition can i break down this complex problem into smaller ones? can i solve and explain the smaller problems, building up a solution towards the
complex problem?
before any training was feasible, we though as a better approach
to first provide students with a common programming tool for
expressing ct (in our case, the lego mindstorms programming
software) and then collect initial data after few sessions (session
4). we argue that this approach enabled us to: (a) help students
develop a homogeneous background that led to more reliable
measurement of their initial ct level (students can express their
ct using the same programming tool), and (b) compare students’
‘‘short training’’ ct development (session 4) to ‘‘long training’’ ct
development (session 10).
student opinion questionnaire (soq): an opinion questionnaire
was handed out to students to be filled individually after the
completion of the training. the instrument recorded: (a) students’
subjective views on understanding ct concepts and developing
relevant skills, and (b) students’ views and opinions regarding the
outcomes of the overall learning experience on four key aspects:
(1) development of students’ ct skills, (2) understanding of
basic programming concepts, (3) students’ in-group collaboration
(benefits and possible drawbacks), and (4) likes and dislikes
relevant to the overall activity.
think-aloud protocol: after the training, students individually were
given a certain robot programming task and were asked to describe
aloud the process they would follow to solve it. simultaneously, the
researcher prompted students to reflect on ct concepts relevant to
their solution. the assessment of the student’s proposed solution
was based also on the same graded criterion instrument (rubric)
as before. we consider this grade as an indicator of student’s
ct skills when evaluated in a different context than that of
the q1 and q2 questionnaires. the main difference is that the
‘think-aloud’ method allows students to express their thinking
more freely as opposed to the highly structured form of the
questionnaire instruments. in the following, we refer to ‘thinkaloud’ measurement as ‘‘students’ ta ct skill level’’ (or simply ctta). as before, we have 5 individual measures for each ct construct
and a mean ct-ta grade calculated across all ct constructs.
interview: after the think-aloud activity students were asked (as
a semi-structured interview) to freely state their opinion on key
aspects of the activity (the four aspects described above in the soq
section).
observation: systematic monitoring of the students’ work was
applied by taking notes on a structured form (observation sheets).
both the supervising researcher and trainers filled in the sheets and
then extensively discussed their observations to reach consent and
decide on their importance. so, an observation table was gradually
developed displaying researchers’ observations in order of their
discussed importance.
3.6. results
3.6.1. statistical analysis
profile questionnaire data revealed that none of the participating students had any previous experience with robotics. after the
data collection, the statistical processing was as follows:
(a) table 4 presents statistical controls applied on students’
ct-4 and ct-10 scores in junior high (j) and high vocational
(h) groups.
(b) table 5 presents statistical controls applied on students’ ct-4
and ct-10 scores analysed in each of the five dimensions of the
ct model.
(c) table 6 presents statistical control applied on the students’
ct-ta scores (both total and analytical scores for each of the
five ct dimensions).
(d) table 7 presents statistical control applied on students’ ct-4
and ct-10 scores across different gender groups. two gender
groups were used: girls and boys at junior (j) level. the
girls/boys distribution in the high (h) group was highly
uneven and this group was excluded from across gender
comparisons.
(e) table 8 presents statistical controls applied on students’ ct-4
and ct-10 scores analysed in each one of the five dimensions
of our ct model. as before (table 7) data refer to gender groups
only within j group.
(f) table 9 presents statistical control applied on the students’ ctta scores across gender (both total and analytical scores for
each of the five ct dimensions).
666 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
table 4
comparing ct-10 and ct-4 scores between j and h groups.
level n ct-4 ct-10 paired t-test ancova
m (sd) m (sd) ct-10 compared to ct-4
(same student group)
comparing ct-10
across student groups
(ct-4 as covariate)
j 89 2.96 (0.51) 3.08 (0.59) t(88) = −1.91, p = 0.059 f (1, 161) = 0.289
h 75 2.36 (0.69) 2.71 (0.77) t(74) = −6.69, p = 0.00*
p = 0.592, η2 = 0.02
total 164 2.69 (0.67) 2.91 (0.70) t(163) = −5.27, p = 0.00*
*
significant difference at the 0.05 level.
table 5
comparing ct-10 and ct-4 scores analytically for the five ct dimensions.
ct skills level ct-4 ct-10 paired t-test ancova
m (sd) m (sd) comparing ct-10 across student
groups with ct-4 as covariate
abstraction j 2.50 (0.81) 2.52 (0.87) t(88) = −0.22, p = 0.83 f (1, 161) = 0.014
h 2.61 (0.83) 2.57 (0.85) t(74) = 0.59, p = 0.55 p = 0.907, η2 = 0.00
generalisation j 2.57 (0.81) 2.70 (0.81) t(88) = −1.18, p = 0.24 f (1, 161) = 0.189
h 2.15 (0.89) 2.48 (0.98) t(74) = −2.79, p = 0.01*
p = 0.665, η2 = 0.01
algorithm j 3.08 (0.74) 2.98 (0.64) t(88) = 1.06, p = 0.29 f (1, 161) = 0.446
h 2.48 (0.77) 2.81 (0.79) t(74) = −5.19, p = 0.00*
p = 0.505, η2 = 0.03
modularity j 3.34 (0.78) 3.57 (0.87) t(88) = −2.19, p = 0.03*
f (1, 161) = 0.0
h 2.11 (1.04) 2.80 (1.25) t(74) = −6.28, p = 0.00*
p = 0.998, η2 = 0.00
decomposition j 3.11 (0.96) 3.66 (0.70) t(88) = −5.58, p = 0.00*
f (1, 161) = 11.861
h 2.27 (1.03) 2.83 (1.06) t(74) = −5.31, p = 0.00*
p = 0.001*
, η
2 = 0.69
*
significant difference at the 0.05 level.
table 6
comparing ct-ta scores between j and h groups.
ct skills j h t-test
m (sd) m (sd)
abstraction 2.20 (0.87) 2.31 (0.95) t(162) = −0.80, p = 0.42
generalisation 2.28 (1.09) 2.68 (1.06) t(162) = −2.40, p = 0.02*
algorithm 2.77 (0.76) 2.60 (0.97) t(140) = 1.21, p = 0.23
modularity 2.60 (1.33) 2.36 (1.02) t(161) = 1.31, p = 0.19
decomposition 3.03 (1.19) 2.84 (1.05) t(162) = 1.06, p = 0.29
total ct-ta 2.62 (0.69) 2.60 (0.75) t(162) = −0.16, p = 0.87
*
significant difference at the 0.05 level.
table 7
comparing ct-10 and ct-4 scores between gender groups (j level only).
gender n ct-4 ct-10 paired t-test ancova
m (sd) m (sd) ct-10 compared to ct-4
(same student group)
comparing ct-10 across student
groups (ct-4 as covariate)
girl 41 2.81 (0.49) 3.09 (0.65) t(40) = −3.43, p = 0.00*
f (1, 86) = 1.146
boy 48 3.02 (0.54) 3.08 (0.51) t(47) = −0.71, p = 0.48 p = 0.287, η2 = 0.013
total 89 2.92 (0.53) 3.09 (0.58) t(88) = −2.68, p = 0.01*
*
significant difference at the 0.05 level.
3.6.2. students’ opinion questionnaire (soq)
data from soqs and interviews helped us understand students’
opinions regarding the overall activity. key findings can be
summarised as follows:
(i) students’ subjective impression was that they acquired
certain ct skills. they reported that they can detect and
describe the common behaviours or programming structures
used in different tasks (m = 4.03, sd = 0.77) and also that
they can suggest a more general solution for a given problem
(m = 4.00, sd = 0.79).
(ii) students reported that the guidelines in the worksheets
helped them develop a certain problem-solving process (m =
3.73, sd = 0.80). they find this process useful to think of
(‘‘it comes to mind’’) when solving problems in other domains
as well (m = 3.58, sd = 0.81). some relevant students’
statements are: ‘‘now i think differently and solve problems
more easily’’ and ‘‘i changed my way of thinking in problem
solving even in other subjects such as mathematics’’.
(iii) the students stated that they became familiar with basic programming constructs (m = 4.16, sd = 0.68) and that
they would like to continue with programming. in particular, h level students mentioned that they better understood some basic programming concepts they learned in other
programming environments, such as the control structure
(‘‘if. . . then. . . else’’) and the loop structure (‘‘for. . . next’’, ‘‘do
while. . . ’’). they also said that working with the robots not
only helped them develop a deeper understanding of programming (m = 4.11, sd = 0.67) but also kept them in-
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 667
table 8
comparing ct-10 and ct-4 scores analytically for the five ct dimensions (j level only).
ct skills gender ct-4 ct-10 paired t-test ancova
m (sd) m (sd) comparing ct-10 across school
levels (ct-4 as covariate)
abstraction girl 2.42 (0.78) 2.62 (0.91) t(40) = −1.56, p = 0.13 f (1, 86) = 1.866
boy 2.57 (0.84) 2.44 (0.84) t(47) = 0.88, p = 0.38 p = 0.175, η2 = 0.021
generalisation girl 2.43 (0.70) 2.66 (0.92) t(40) = −1.66, p = 0.11 f (1, 86) = 0.00
boy 2.70 (0.87) 2.74 (0.91) t(47) = −0.25, p = 0.80 p = 0.989, η2 = 0.00
algorithm girl 3.01 (0.71) 2.99 (0.65) t(40) = 0.20, p = 0.85 f (1, 86) = 0.037
boy 3.15 (0.77) 2.97 (0.65) t(47) = 1.15, p = 0.26 p = 0.848, η2 = 0.00
modularity girl 3.18 (0.79) 3.54 (0.94) t(40) = −2.02, p = 0.05*
f (1, 86) = 0.073
boy 3.48 (0.76) 3.60 (0.82) t(47) = −0.98, p = 0.33 p = 0.787, η2 = 0.001
decomposition girl 3.00 (0.97) 3.66 (0.82) t(40) = −4.59, p = 0.00*
f (1, 86) = 0.123
boy 3.20 (0.94) 3.67 (0.60) t(47) = −3.39, p = 0.00*
p = 0.727, η2 = 0.001
*
significant difference at the 0.05 level.
table 9
statistical analysis comparing ct-ta between gender groups (j level only).
ct skills girls (n = 41) boys (n = 48) independent t-test
m (sd) m (sd)
abstraction 2.31 (0.94) 2.11 (0.80) t(87) = 1.12,
p = 0.27
generalisation 2.32 (1.08) 2.24 (1.11) t(87) = 0.33,
p = 0.74
algorithm 2.91 (0.69) 2.65 (0.80) t(87) = 1.66,
p = 0.10
modularity 2.68 (1. 33) 2.53 (1.34) t(87) = 0.54,
p = 0.60
decomposition 3.12 (1. 25) 2.95 (1.16) t(87) = 0.68,
p = 0.50
total ct-ta 2.71 (0.73) 2.54 (0.66) t(82) = 1.14,
p = 0.26
terest and motivated them to keep working on programming
(m = 3.42, sd = 0.66).
(iv) regarding collaboration, the students enjoyed working in
groups (‘‘three minds are better than one’’, ‘‘we motivate each
other when working together’’) and assuming ct relevant roles
(m = 4.06, sd = 0.72) with the most popular role being that
of the ‘‘programmer’’.
(v) finally, the students found the robotics experience very interesting (m = 4.38, sd = 0.63), reporting that they would like
to continue practising er in the future (m = 3.65, sd = 0.84)
and engage in more challenging tasks. indicative of their interest is the fact that when finishing with the worksheets, they
explored different programming structures (‘‘blocks’’) – even
those they had not learned yet – and different ideas to expand
and improve their solutions.
3.7. discussion and conclusions
the current work analysed the development of students’ computational thinking skills in the context of educational robotics,
with special focus on the impact that the instructional approach
may have on student groups of different ages and genders. the
study provides evidence from evaluation instruments administered at various times during the activity, thus offering a picture of
how ct skills develop as students’ work progresses. students’ ct
skills are also evaluated using different modalities in assessment
instruments (questionnaires answered in written and problemsolving think aloud protocols). finally, researchers’ observations
and qualitative data from students’ opinion questionnaires help
triangulate data and deeper understand their meaning.
a first observation is that students develop the same level of ct
skills at the end of their training independently of age. additionally,
ct skills in most cases are significantly improved as the training
proceeds (comparing ct-4 and ct-10 scores in tables 4 and 5).
this is clear for the total population and for each of the two
groups, although for the j group appears as a strong tendency (p =
0.059) not exactly reaching the level of significance (table 4, paired
t-test and ancova). thus, one key conclusion is that the
satisfactory development of ct skills needs a considerable number
of training sessions – independently of student’s age – and is not
simply a matter of a few training sessions. this conclusion is in
line with studies emphasising that skill development in general
requires adequate amount of training time [33,53].
reflecting further on table 5, we see that significant differences
between ct-10 and ct-4 measures are identified in certain
cases independently of student’s level (age) (clearly for the
modularity and decomposition dimensions), while in other cases
such differences are evidenced only for the h group (algorithm
and generalisation dimensions) or not at all (abstraction). to
explain these differences we resort to researchers’ observations
regarding the group composition and students’ preference for
writing. most students in the h group are boys not so willing to
provide answers in written (this is in line with studies suggesting
that boys are significantly more reluctant writers than girls, for
example [54]). by contrast, students in the j group are almost
equally distributed across gender and adopt a more positive
attitude towards expressing themselves in written (compared to
boys in h group).
keeping this in mind, we explore the implications of data in
table 5. as the development of the abstraction skill for both groups
reaches a high level already in session 4 (not to be surpassed
in the next sessions), this is an indication that students from
session 4 onwards deal with programming tasks without further
development of this skill in a way that is reflected in the measures.
also, the additional workload of expressing this skill in written
does not seem to affect students in the high group. however,
generalisation and algorithm skills are further developed (from
ct-4 to ct-10) only for the high group (table 5). this is probably
explained by the observation that younger students in the j group
are more willing to follow instructions and provide answers in
written (so their scores are high already from the 4th session
(ct-4)), while students in the h group improve significantly
from ct-4 to ct-10 as they gradually familiarise themselves
with following the worksheet guidelines and become more
willing to provide written documents expressing their thinking.
these explanations are further supported by the fact that the
aforementioned differences are not observed when the modality
of the assessment instrument changes (see also comments
below regarding table 6). finally, considering the modularity
and decomposition dimensions we observe significant differences
between ct-10 and ct-4, for both j and h groups. regarding
modularity, we believe that the significant improvement of
668 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
ct-10 score for the j group is mainly due to the improvement of
the girls’ ct-10 score in the group (see also modularity in table 8,
we comment on that further below). regarding decomposition,
we see that both boys and girls in j group improve significantly
their ct-10 score (see also table 8) and this, we believe, is due
to the increase of problem complexity as the training proceeds.
increased problem complexity gives the opportunity to students
of both groups (j and h) to practise the skill more extensively and
this is reflected in their scores. additionally, we identify – only for
decomposition – a statistically significant difference between the
two groups favouring students in the j group (ancova in table 5).
we suggest that this is another manifestation of the unwillingness
of boys in the h group to routinely follow instructions. students
in this group do not actually think it is necessary to decompose
the problem into smaller ones to solve it. however, this attitude
could also be linked to the cognitive maturity of elder adolescents
in group h as compared to the younger adolescents in group j,
which enables the former to manage more complex programming
solutions without decomposing them.
moving on to table 6 (ct-ta scores), we see that when evaluating students’ ct skills orally (think-aloud protocol) no betweengroup differences are identified (except for generalisation,
favouring the h group). this, corroborates our already stated conclusions that: (a) development of ct skills happens in the same
way for both groups independently of age, and (b) ct skills measures might be affected by the workload imposed on students from
the recording instrument modality. when students are asked to
provide written evidence of their skills, they might appear to underperform because of poorly following the instructions (as in decomposition, table 5). however, it is not clear why the h group
outperforms j in generalisation (table 6). one possible explanation
is that the oral modality allows the specific profile male students
in group h to thoroughly express their more complex thinking required to describe a generalised problem solution. thus, we might
have here another indication of the interaction between students’
scores and assessment instrument modality, which should be seriously considered by researchers in relevant studies. in all other
dimensions (and also in the total ct skills score) no significant differences are recorded.
next, we focus on the analysis of scores between gender groups
(tables 7–9). a key conclusion here is that, although boys and
girls reach the same ct skills level (ancova in table 7), there is,
however, a significant difference between ct-10 and ct-4 scores
for the girls’ subsample indicating that the girls need longer time
to reach the same skills level. this difference is also reflected on the
total population (paired t-tests in table 7). this outcome is in line
with other studies suggesting that girls seem to require more time,
compared to boys, when it comes to skills development (see [55]).
table 8 presents analytically the ct-10 and ct-4 skills scores
in the five dimensions for boys and girls. the previously discussed
pattern (‘‘both genders reach the same skill level but girls need
more time’’) appears again for the abstraction (strong tendency
for girls, p = 0.13), generalisation (strong tendency for girls,
p = 0.11), modularity (significant difference for girls, p = 0.05),
but not for the algorithm or the decomposition dimensions. for the
decomposition, we believe, the explanation is the same as before;
the increased complexity of programming tasks as the training
proceeds allow students of both genders to practise decomposition
more systematically and this is reflected in their scores.
finally, some interesting evidence emerges in table 9. on
one hand, no significant differences in ct skill scores appear
(neither for the total ct-ta score nor for any dimension, except for
strong tendency in algorithm, favouring girls). the ‘‘no significant’’
outcome is compatible with the overall gender pattern that boys
and girls reach finally the same skills level. on the other hand,
however, the strong tendency in algorithm seems to be at odds
with what has been discussed so far, as the algorithm relevant skill
is the only one developed in the same way by both boys and girls
(table 8). one possible explanation might be that while girls in
the j group understand and express the algorithmic dimension of
a programming task as efficiently as boys (table 8), nevertheless,
when they are additionally given the opportunity to express their
algorithmic thinking orally, they tend to do that more effectively
than boys (table 9). anyway, we acknowledge that more research
is needed to clarify that point.
by reflecting on researchers’ observations we report the most
important of them as follows: (a) despite any initial difficulties in
grasping the concept of abstraction, students were able to easily
identify the common programming concepts when comparing
different scenarios. this conclusion is in line with quantitative
data indicating that abstraction is easily grasped and practised
by students. (b) in the beginning, the students, faced difficulties
in understanding the concept of generalisation and suggesting
more general solutions. however, at the end of the training,
interesting generalisations were observed in students’ solutions.
especially students in the h group assimilated the concept more
easily and used it in the activities often without any intervention
from trainers. this corroborates the findings in table 6 where
elder adolescents (the h group) seem to practise generalisation
significantly better when the assessment modality is oral. thus,
generalisation appears to be a ct skill which develops better in
elders and this is perhaps related to the cognitive developmental
level of the h group. certainly, more research is needed to further
clarify the issue. (c) most students had difficulty in describing the
algorithm with clarity and accuracy. they preferred to describe a
process in general rather than analyse it step by step. perhaps this
is due to the cognitive load induced when analytically expressing
the algorithm. here, again, a modality effect is identified (girls
tend to orally describe the algorithm better than boys— table 9).
(d) the students, encouraged by the trainers, practised the skill of
modularity in their activities by creating their own programming
‘‘blocks’’. the students in j group familiarised with and integrated
the skill more than the students in h group. this last observation
is in line with quantitative data (table 5) showing that j group
applies decomposition better. we attribute that behaviour mostly
to h group students’ unwillingness to follow instructions for
decomposing problems, being able to manage the code as a whole.
overall, this study provides evidence that: (a) students of
different ages (15 vs. 18) and genders eventually reach the same
level of ct skills development; this view is supported by evidence
from assessment instruments using two modalities. (b) time is
an essential commodity for ct skills development; skills level
evaluated in later session have been found in most cases to be
significantly improved when compared to initial session. (c) when
analysing the particular skills of the ct model certain differences
are identified which are related to the following factors: age and
student cognitive developmental level, students’ attitudes relevant
to following instructions and afford workload induced by the task,
and also gender. (d) the assessment instrument modality may
have an impact on students’ scores as boys are, generally, more
reluctant writers compared to girls. when this attitude is intense
then boys may appear to underperform if skills evaluation is based
on instruments of written modality. (e) girls appear in most cases
to need more time (training sessions) in order to reach the same
skill level as boys. (f) provided that the overall instructional context
is supportive and the learning activity time is adequate, students
may overcome their initial difficulties and successfully develop
their ct skills.
understanding the above conclusions should be done while
also considering the limitations of the study. it is important
to remember that educational robotics activities cannot be
conducted under full experimental control and many factors might
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 669
interact in an unexpected and – relatively – uncontrolled way.
the current study provides evidence coming from various data
collecting methods and with assessment instruments of different
modality, something that – we believe – increases the validity
of the conclusions. however, it was not possible to include a
control group in the design that would allow exploring the
issue of whether the ct skills in er activities develop in the
same way compared to a control non-er instructional condition.
an additional limitation is the exclusion of the h group from
across gender controls due to the highly uneven distribution of
girls/boys in the sample. this does not permit the current study to
simultaneously apply across-age and across-gender controls that
could further shed light on the gender relevant differences and
reveal any possible interaction between the two factors. finally,
the study did not administer any pre-intervention controls of
students’ ‘‘preference for writing’’ attitude and general ability
levels. our experience indicates that such tests could provide
valuable information regarding some of the observed gender and
group relevant differences.
acknowledgements
the authors would like to thank all school teachers, postgraduate student-trainers and the students involved in the er seminars
for their helpful collaboration and also the journal editor and the
manuscript reviewers for their constructive comments."
"1. introduction
this work presents and discusses a specific didactic approach
to support the development of students’ computational thinking
(ct) skills in educational robotics (er) activities. as wing [1]
argues, computational thinking (ct) is a fundamental skill for
everyone and it should be considered as an important component
of every child’s analytical ability along with reading, writing, and
arithmetic. recently, there has been growing recognition of the
importance of ct in controlling and managing cognitive activities,
as well as understanding and solving problems in a wide range
of contexts, not only in the field of computer science, but in all
disciplines [2].
∗ corresponding author. tel.: +30 6977718143.
e-mail addresses: atmatzid@csd.auth.gr (s. atmatzidou), sdemetri@csd.auth.gr
(s. demetriadis).
robotics can be used as a tool that offers opportunities for students to engage and develop computational thinking skills [3,4].
educational robotics is being introduced in many schools as an
innovative learning environment, enhancing and building higher
order thinking skills and abilities, and helping students solve complex problems [5]. furthermore, a guided instruction approach
using robots facilitates teamwork, develops conceptual understanding, enhances critical thinking, and promotes higher-order
learning in the domains of mathematics and science [6].
this paper describes the implementation of er activity in
secondary school, focusing on the different possible impacts that
the instructional approach might have on the development of
students’ ct skills depending on their age and gender. guided
by worksheets, students worked in small groups to solve robot
programming problems. the level of their ct skills was evaluated
at different times during the activity, with focus on five key ct
constructs—abstraction, generalisation, algorithm, modularity and
decomposition.
http://dx.doi.org/10.1016/j.robot.2015.10.008
0921-8890/© 2015 elsevier b.v. all rights reserved.
662 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
2. background
robotics is usually seen as an interdisciplinary activity drawing
mostly in science, mathematics, informatics and technology and
offering major new benefits to education in general at all levels
[7,8]. educational robotics is a powerful, flexible, teaching and
learning tool, encouraging students to construct and control robots
using specific programming languages [7]. the roots of er are to be
found in seymour papert’s work, creator of the logo programming
language [9]. papert suggests that learning is most effective when
students are experiencing and discovering things for themselves.
he also argues that robotics activities have tremendous potential
to improve classroom teaching [9,10]. drawing on the theoretical
underpinnings of papert’s constructionism and vygotsky’s sociocognitive approaches, er activities help students transform themselves from passive to active learners, constructing new knowledge
by collaborating with their peers and developing essential mental skills by acting as researchers. many studies indicate that er
activities have a positive impact on the development of students’
critical thinking, problem solving and metacognitive skills
[5,11,12] and also on the learning of a programming language
[7,13,14]. other studies demonstrate how er promotes a joyful
mode of learning, while advancing students’ motivation, collaboration, self-confidence and creativity [15–17]. many researchers argue that robotics programs provide a valuable avenue to increase
students’ interest and participation in science, technology, engineering and mathematics (stem), while they motivate them to
pursue a career in one of these fields (e.g. [18–20]). however, certain researchers point out that although robotics seems to be an
excellent tool for teaching and learning and a compelling topic for
students of all ages, the pedagogy of teaching with robotics is still
in its infancy [7,21]. it is also noted that more research is needed to
point out how to work with educational robotics to help students
develop specific skills [10,22].
as this study focuses on er as a means for advancing students’
ct skills, we concisely review next the ct theoretical framework
and studies on the er-ct relationship. wing [1] describes ct as a
type of analytical thinking that draws on concepts fundamental to
computer science and provides a way for solving problems, designing systems, and understanding human behaviour. ct roots go back
to papert’s ideas of the computer being the children’s machine that
would allow them to develop procedural thinking through programming, and refers to ways of algorithmically solving problems
and to the acquisition of technological fluency [9].
in the literature there are multiple definitions of ct and several suggestions about which skills and abilities are relevant to ct
and how to integrate ct in the curricula of all grades. wing [2] asserts that ct has the potential to advance the students’ problemsolving skills through processes such as abstraction, generalisation,
decomposition, algorithm design and separation of concerns. astrachan et al. [23] emphasise skills such as: developing computational artefacts, abstracting, analysing problems and artefacts, and
communicating and working effectively in teams. still others
argue that the key concepts of ct are abstraction, automation, simulation, evaluation, algorithm building, conditional logic, debugging, decomposition, problem analysis, distributed computing and
effective teamwork [24–26]. emphasis is also given to the view that
the educational benefits of ct transfer to any domain – not only in
the field of computer science – by enhancing and reinforcing intellectual skills [1,27]. yadav [28] argues emphatically that ‘ct in education has the potential to significantly advance the problem-solving
skills of k-12 students’.
naturally, researchers have started exploring also the potential of educational robotics to promote the development of ct
[4,29–31]. certain studies emphasise that children who program
robots learn and apply core ct concepts such as abstraction, automation, analysis, decomposition, modularisation and iterative
design [4,29,30]. a 2011 study by national science foundation [4]
provided evidence that student programmers in a robotics project,
developed abstraction, automation, and analysis related skills,
while programming the robot agent to interact with its environment. however, it is worth mentioning according to researchers
that the field requires systematic assessment procedures.
research engaging younger children reported also positive
outcomes, demonstrating that children 4–6 years old can build
simple robotics projects becoming acquainted with powerful ideas
of engineering, technology, and computer programming while
also building ct skills [30,32,33]. more specifically, a study with
53 kindergarten children [33] using lego wedo robots and the
cherp (creative hybrid environment for robotics programming)
language, reported that the children were involved and understood
basic programming and ct concepts relevant to sequencing and
choosing the correct instructions. a similar study by kazakoff
et al. with 27 kindergarten children, focusing solely on sequencing,
showed improvement of the students’ scores from the first activity
to the last [29].
regarding elder children (junior and high school students),
studies report also positive results on the development of ct
skills. grover [27] developed a curriculum for teaching ct
language and ct principles in schools. the results indicated that
students after the intervention were capable of using certain
ct related vocabulary and principles (such as conditional logic
and decomposition), whereas other concepts like abstraction,
representation and algorithmic flow control were seldom used.
another study by touretzky et al. [34] engaging children aged
10–17 (some of them with special abilities), focused on abstraction
across different programming environments and especially on
deep and abstract understanding of programming concepts. the
researchers concluded that – despite the limitations – robotics
is a helpful tool for young students, ‘‘facilitating a more abstract
understanding’’. penmetcha [35] investigated the effects of er
activity on university students exploring the relationship between
robotics and developing programming and algorithmic thinking.
the results showed that robotics fulfil their purpose as a
medium for incorporating ct practices, regardless of the students’
background, and can be used to teach concepts such as designing,
programming and testing at a more abstract level. as in the other
studies, limitations were reported relevant to the study small
sample size [27]. finally, a case study by eguchi [36] explores
the effects of a robotics competition on students’ ct and problem
solving skills reporting an overall very positive effect.
overall, although the ct concept has attracted considerable
attention, the literature on implementing ct in a k-12 setting is
still relatively sparse [28]. there is also lack of empirical evidence
in defining the explicit ct boundaries [37], although recent articles
begin to describe what it looks like [4,30,38,39]. more than that,
research into how ct can be introduced in the classroom is on
the early stages and there is shortage of description about how
children can learn and develop ct skills [27,28,37]. another issue is
to understand at what age – or grade level – children are ready to be
familiar with advanced concepts such as abstraction, automation,
decomposition, etc. and how to teach those skills progressively [4].
likewise, there is little agreement on strategies for assessing the
development of ct in young people [23,38,40,41]. existing studies
typically employ a student group of specific age thus limiting the
generalisation of the results to other age groups (e.g. [8,29,33]),
have small sample sizes (e.g. [27,29,34,35]), and do not provide
explicit teacher guidance on how to organise a well-guided er
activity to promote students’ ct skills. researchers also differ in the
way they build an operational ct skills framework to apply to their
studies. table 1 presents the various ct skill models employed in
various er studies.
another issue of interest is the gender differences observed
in studies on stem learning activities. much research has
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 663
table 1
ct skills models employed in various er studies.
article context ct skills model
lee et al. [4] k-12 abstraction, automation, and analysis.
grover [27] 10 students mean age: 13 computational thinking language (ctl) [42] abstraction, taskbreakdown, conditional logic,
representation, algorithm, and debugging.
penmetcha [35] 26 university students abstraction, algorithm, programming, and designing.
bers et al. [33] 53 kindergarten students sequencing
kazakoff et al. [29] 27 kindergarten students sequencing
touretzky et al. [34] 31 students aged 10–17 abstraction between three software frameworks (kodu, alice, lego nxt), recognise fundamental
programming concepts.
bers et al. [33] 53 kindergarten students debugging, correspondence, sequencing, and control flow.
eguchi [36] 168 students aged 10–19 problem solving, debugging, prototyping, decomposition, logical thinking, creating step-by-step
procedure, analysing skills, critical thinking, iteration, and debugging.
documented gender differences, showing that men have higher
levels of self-efficacy and higher probability of success in stemrelated fields (e.g., [43,44]). however, over the past few decades
the gender gap has narrowed. the stereotypic gender role might
have a clear impact on attitudes about technology but this can
be positively changed under the right conditions [45,46]. studies
indicate that both genders can have a successful and rewarding
experience being exposed to robotics activities. milto et al. [47]
found that although men were more confident in their abilities
than women, in an introductory engineering class women and men
displayed equivalent competency in robotics activities. similarly,
nourbakhsh et al. [48] investigated the gender differences in a
robotics course involving high school students. according to the
study, although girls entered the course with less confidence than
boys and were more likely to have struggled with programming, by
the end of the course girls’ confidence increased more than boys’.
another study by cheng [49] reported that in terms of assembling
and programming lego robots, while there were slightly higher
average scores for male students it was not of significant difference.
however, research on comparing the development of ct skills
between genders in k-12 robotics activities is relatively sparse.
while research has been conducted on gender differences in many
science and mathematics areas [50] limited research has been
carried out into gender differences in robotics and programming
achievement especially in early childhood [51].
research motivation and key research question
considering the above background, the current study aimed
to conduct an instructional well-guided er activity, recruit a
relatively large student sample size and explore the impact of
the activity on students’ ct skills, comparing student groups of
different age and gender. thus, the overarching research question
set by the study is: ‘‘are students of different age and gender
developing ct skills in the same way in the context of educational
robotics activity?’’
3. method
3.1. participants
for the purpose of our study we conducted a series of robotic
training seminars in public schools in the area of thessaloniki.
in total, 164 students of two different school levels (junior high
and high vocational) participated in the study. specifically, in the
seminars were engaged:
• junior high (j): 89, k-9 students (age: 15, 48 boys and 41 girls)
• high vocational (h): 75, k-12 students (age: 18, 64 boys and 11
girls).
3.2. a model for ct skills
to operationalise the ct theoretical approach, we focused on
five core dimensions of the broader ct conceptual framework.
these included: abstraction, generalisation, algorithm, modularity
and decomposition. the proposed model encompasses skills that
can easily emerge when students engage in educational robotics
activities. in detail, the proposed model for ct skills presented in
table 2.
3.3. implementation procedure
in total, we conducted 8 training robotics seminars (4 at junior
high and 4 at high vocational schools’) during the 2012–2013
school year. the lego mindstorms nxt 2.0 educational robotics kit
was used in all seminars. organised and supervised by the main
researchers (authors of this work), each seminar comprised 11
sessions (2 h each, conducted once a week). trained postgraduate
students (‘‘trainers’’) assisted with the practicalities of the
activity (e.g. organising student groups, handling out worksheets,
encouraging and scaffolding teams, administering questionnaires,
etc.). the seminars were conducted during the typical school time
schedule and the class teachers remained in the classroom during
the activity, simply helping to maintain the flow of each lesson. in
detail, the sessions were as follows:
1st session: in the beginning, the teacher introduced robotics
in general, the lego mindstorms nxt robot and the lego nxtg programming environment. then she handed out the profile
questionnaire (pq) to be filled in individually by students. working
in groups, the students implemented their first program using their
own robot kit. emphasis was placed on the concept of algorithm
and the importance of developing precise instructions that when
implemented they lead to the solution of the problems.
2nd session: the objective here was students’ familiarisation
with some basic programming concepts (sequential structure and
loop structure). the students also became familiar with the motors,
the touch sensor, the sound sensor and finally with some basic
feature of nxt, such us displaying images on the screen of the
robot. in this session, students programmed their robots to dance
and presented them to the other groups. the session placed focus
on the abstraction and generalisation concepts. participants were
prompted to reflect on the role of these two concepts in their own
problem solving activities.
3rd and 4th sessions: the students worked on the control
structure and on how to use the ultrasonic sensor and the wait
block. they also practised conversion of numbers to text in order
to show a numerical value on the screen. in the last activity of
the 4th session the challenge was to create a robotic alarm system
that detects motion and sound. at the end of the fourth session
we administered the first questionnaire (q1) in order to assess the
students’ level of ct skills development. in 3rd session the focus
here was on modularity and decomposition and their importance
in optimising the structure of an algorithm implementation. from
the 4th session onwards, the activities challenged the students to
engage in practising all the concepts of the ct model and develop
relevant skills.
5th and 6th sessions: the students became familiar with the
operation of light sensor, the creation of reusable subprograms
664 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
table 2
the ct skills model applied in the current study.
ct skills description student skills
(the student should be able to. . . )
abstraction abstraction is the process of creating something simple from
something complicated, by leaving out the irrelevant details, finding
the relevant patterns, and separating ideas from tangible details [52].
wing [2] argues that the essence of ct is abstraction.
1. separate the important from the redundant information.
2. analyse and specify common behaviours or programming structures
between different scripts.
3. identify abstractions between different programming environments.
generalisation generalisation is transferring a problem-solving process to a wide
variety of problems [38].
expand an existing solution in a given problem to cover more
possibilities/cases.
algorithm algorithm is a practice of writing step-by-step specific and explicit
instructions for carrying out a process.
kazimoglu et al. [37] argue that selection of appropriate algorithmic
techniques is a crucial part of ct.
1. explicitly state the algorithm steps.
2. identify different effective algorithms for a given problem.
3. find the most efficient algorithm.
modularity modularity is the development of autonomous processes that
encapsulate a set of often used commands performing a specific
function and might be used in the same or different problems [38].
develop autonomous code sections for use in the same or different
problems.
decomposition decomposition is the process of breaking down problems into
smaller parts that may be more easily solved.
break down a problem into smaller/simpler parts that are easier to
manage.
wing [2] argues that ct is using decomposition when attacking or
designing a large complex task.
(make a new ‘‘my block’’), the use of the lamp block and the
parallel programming. the students programmed a recycler robot,
where the robot moves following a black line and sorts items to be
recycled depending on their colours.
7th and 8th sessions: the students worked on the concept
of variable and basic arithmetic operators. in this context, the
students implemented a security guard robot that moves around a
building and detects every motion, sound and change in lightness.
9th and 10th sessions: students were given activities of
increased difficulty to practise their developing ct skills in the
context of more complex authentic problems, such as a car that
moves following the traffic code, etc. the project allowed children
to demonstrate the powerful ideas they learned over the previous
sessions as well as to apply them and continue learning by solving
a new problem. a second questionnaire (q2) was administered at
the end of this session to assess the students’ current level of ct
skills development.
11th session: in the final session, student groups were given the
‘‘final challenge’’ that is a demanding robot programming task for
groups to compete against each other. the winner was the group
that proposed an effective and efficient task solution (optimised
code and fastest solution).
after the completion of each seminar, two other instruments
were used to capture the students’ level of ct skills and also
their views regarding the er training experience. these were: (a)
a ‘think-aloud’ protocol implementation, (b) a student’s opinion
questionnaire. overall, the procedure of each training seminar and
the various data collection instruments are presented in fig. 1.
3.4. didactic model
in each seminar, students worked in groups of three (or four
if necessary) and were guided by worksheets in the investigating
robot programming tasks of gradually increased complexity. these
enabled them to start constructing understanding and developing
the ct skills prescribed by our model. the worksheets also directed
students to assume the roles of analyst (analyse the problem),
algorithm designer (describe the algorithm), programmer (write
the code), or debugger/evaluator (review and assess the solution).
the students exchanged roles successively as the activities evolved.
during the sessions, the trainers acted as facilitators to scaffold
students while solving programming tasks. after the 5th session,
trainers gradually faded their support. this means that detailed
guidance was gradually replaced by simple prompts to students
to assume the relevant role and practise the acquired skills on
their own capacity [5]. the trainers were ready to fade-in again
and support students should the circumstances require it. to
trigger students’ reflection and development of ct modelled skills,
prompts such as the following (see table 3) were included in the
worksheets. peers were expected to spend some time discussing
how to answer these prompts; then one peer was assigned the
responsibility of writing down the group answer to the worksheet.
3.5. measures, instruments and data analysis
the instruments that we used to collect evaluation data (and
respective measures) are as follows:
profile questionnaire (pq): an individual questionnaire was administered in the beginning of each seminar. the questionnaire
recorded some simple demographic data (e.g. student gender), the
students’ background on computer use (for example, frequency
of computer use, computer experience, etc.) and experience with
robotics (such as previous knowledge on constructing and programming robots).
two intermediate questionnaires (q1 and q2): q1 was handed out
after the 4th and q2 after the 10th session. both questionnaires
asked students to solve programming problems and practise ct
skills during their solution process; for example, identify common
programming structures that guide robot behaviour in two tasks
(abstraction), propose a more general solution (generalisation),
describe step-by-step the solution process (algorithm), etc. the
assessment of students’ answers in q1 and q2 was based on a
graded criterion instrument (rubric) using a 4-point likert scale
(1 = ‘unsatisfactory’, 2 = ‘quite satisfactory’, 3 = ‘satisfactory’,
4 = ‘excellent’). there were specific criteria for each construct of
the ct model (abstraction, generalisation, algorithm, modularity,
decomposition) and so each student was assigned a grade for each
ct construct after answering the q1 and q2 questionnaires. a
mean value was also calculated across all ct constructs (in q1
and q2 respectively). we consider the q1 and q2 measurements
as indicators of student’s level of ct skills development at certain
phases during the training seminar (q1 after the 4th session,
q2 after the 10th session). in the following, we refer to q1
measurement as ‘‘students’ starting ct skill level’’ (or simply ct-4)
and to q2 measurement as ‘‘students’ final ct skill level’’ (or simply
ct-10). as ct-4 is a measurement reflecting students’ ct skills
early in the training, we use it as covariate in our statistical analysis.
we would like to clarify that although administering a pre-test
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 665
fig. 1. seminar organisational structure: lower row indicates session when ct skills were introduced; arrows indicate sessions when evaluation interventions were
conducted.
table 3
ct skills and relevant prompts to trigger students’ self-reflection.
abstraction what is common in robot behaviour in both programs? how would you describe this common behaviour? what is the common
programming structure? which is the information you actually need? what is irrelevant detail and not necessary in your description?
generalisation propose a more general solution for the activity above, that can cover a wider variety of cases. is the proposed solution more general and
why?
algorithm write step-by-step the operations needed so that the robot can do what the problem asks. what are the steps i will need to do to solve this
problem?
modularity are there any parts of the code that you have met before? have you created your own blocks for these? what are they? do you expect to
need some parts of this particular code in the future or in a different problem?
decomposition can i break down this complex problem into smaller ones? can i solve and explain the smaller problems, building up a solution towards the
complex problem?
before any training was feasible, we though as a better approach
to first provide students with a common programming tool for
expressing ct (in our case, the lego mindstorms programming
software) and then collect initial data after few sessions (session
4). we argue that this approach enabled us to: (a) help students
develop a homogeneous background that led to more reliable
measurement of their initial ct level (students can express their
ct using the same programming tool), and (b) compare students’
‘‘short training’’ ct development (session 4) to ‘‘long training’’ ct
development (session 10).
student opinion questionnaire (soq): an opinion questionnaire
was handed out to students to be filled individually after the
completion of the training. the instrument recorded: (a) students’
subjective views on understanding ct concepts and developing
relevant skills, and (b) students’ views and opinions regarding the
outcomes of the overall learning experience on four key aspects:
(1) development of students’ ct skills, (2) understanding of
basic programming concepts, (3) students’ in-group collaboration
(benefits and possible drawbacks), and (4) likes and dislikes
relevant to the overall activity.
think-aloud protocol: after the training, students individually were
given a certain robot programming task and were asked to describe
aloud the process they would follow to solve it. simultaneously, the
researcher prompted students to reflect on ct concepts relevant to
their solution. the assessment of the student’s proposed solution
was based also on the same graded criterion instrument (rubric)
as before. we consider this grade as an indicator of student’s
ct skills when evaluated in a different context than that of
the q1 and q2 questionnaires. the main difference is that the
‘think-aloud’ method allows students to express their thinking
more freely as opposed to the highly structured form of the
questionnaire instruments. in the following, we refer to ‘thinkaloud’ measurement as ‘‘students’ ta ct skill level’’ (or simply ctta). as before, we have 5 individual measures for each ct construct
and a mean ct-ta grade calculated across all ct constructs.
interview: after the think-aloud activity students were asked (as
a semi-structured interview) to freely state their opinion on key
aspects of the activity (the four aspects described above in the soq
section).
observation: systematic monitoring of the students’ work was
applied by taking notes on a structured form (observation sheets).
both the supervising researcher and trainers filled in the sheets and
then extensively discussed their observations to reach consent and
decide on their importance. so, an observation table was gradually
developed displaying researchers’ observations in order of their
discussed importance.
3.6. results
3.6.1. statistical analysis
profile questionnaire data revealed that none of the participating students had any previous experience with robotics. after the
data collection, the statistical processing was as follows:
(a) table 4 presents statistical controls applied on students’
ct-4 and ct-10 scores in junior high (j) and high vocational
(h) groups.
(b) table 5 presents statistical controls applied on students’ ct-4
and ct-10 scores analysed in each of the five dimensions of the
ct model.
(c) table 6 presents statistical control applied on the students’
ct-ta scores (both total and analytical scores for each of the
five ct dimensions).
(d) table 7 presents statistical control applied on students’ ct-4
and ct-10 scores across different gender groups. two gender
groups were used: girls and boys at junior (j) level. the
girls/boys distribution in the high (h) group was highly
uneven and this group was excluded from across gender
comparisons.
(e) table 8 presents statistical controls applied on students’ ct-4
and ct-10 scores analysed in each one of the five dimensions
of our ct model. as before (table 7) data refer to gender groups
only within j group.
(f) table 9 presents statistical control applied on the students’ ctta scores across gender (both total and analytical scores for
each of the five ct dimensions).
666 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
table 4
comparing ct-10 and ct-4 scores between j and h groups.
level n ct-4 ct-10 paired t-test ancova
m (sd) m (sd) ct-10 compared to ct-4
(same student group)
comparing ct-10
across student groups
(ct-4 as covariate)
j 89 2.96 (0.51) 3.08 (0.59) t(88) = −1.91, p = 0.059 f (1, 161) = 0.289
h 75 2.36 (0.69) 2.71 (0.77) t(74) = −6.69, p = 0.00*
p = 0.592, η2 = 0.02
total 164 2.69 (0.67) 2.91 (0.70) t(163) = −5.27, p = 0.00*
*
significant difference at the 0.05 level.
table 5
comparing ct-10 and ct-4 scores analytically for the five ct dimensions.
ct skills level ct-4 ct-10 paired t-test ancova
m (sd) m (sd) comparing ct-10 across student
groups with ct-4 as covariate
abstraction j 2.50 (0.81) 2.52 (0.87) t(88) = −0.22, p = 0.83 f (1, 161) = 0.014
h 2.61 (0.83) 2.57 (0.85) t(74) = 0.59, p = 0.55 p = 0.907, η2 = 0.00
generalisation j 2.57 (0.81) 2.70 (0.81) t(88) = −1.18, p = 0.24 f (1, 161) = 0.189
h 2.15 (0.89) 2.48 (0.98) t(74) = −2.79, p = 0.01*
p = 0.665, η2 = 0.01
algorithm j 3.08 (0.74) 2.98 (0.64) t(88) = 1.06, p = 0.29 f (1, 161) = 0.446
h 2.48 (0.77) 2.81 (0.79) t(74) = −5.19, p = 0.00*
p = 0.505, η2 = 0.03
modularity j 3.34 (0.78) 3.57 (0.87) t(88) = −2.19, p = 0.03*
f (1, 161) = 0.0
h 2.11 (1.04) 2.80 (1.25) t(74) = −6.28, p = 0.00*
p = 0.998, η2 = 0.00
decomposition j 3.11 (0.96) 3.66 (0.70) t(88) = −5.58, p = 0.00*
f (1, 161) = 11.861
h 2.27 (1.03) 2.83 (1.06) t(74) = −5.31, p = 0.00*
p = 0.001*
, η
2 = 0.69
*
significant difference at the 0.05 level.
table 6
comparing ct-ta scores between j and h groups.
ct skills j h t-test
m (sd) m (sd)
abstraction 2.20 (0.87) 2.31 (0.95) t(162) = −0.80, p = 0.42
generalisation 2.28 (1.09) 2.68 (1.06) t(162) = −2.40, p = 0.02*
algorithm 2.77 (0.76) 2.60 (0.97) t(140) = 1.21, p = 0.23
modularity 2.60 (1.33) 2.36 (1.02) t(161) = 1.31, p = 0.19
decomposition 3.03 (1.19) 2.84 (1.05) t(162) = 1.06, p = 0.29
total ct-ta 2.62 (0.69) 2.60 (0.75) t(162) = −0.16, p = 0.87
*
significant difference at the 0.05 level.
table 7
comparing ct-10 and ct-4 scores between gender groups (j level only).
gender n ct-4 ct-10 paired t-test ancova
m (sd) m (sd) ct-10 compared to ct-4
(same student group)
comparing ct-10 across student
groups (ct-4 as covariate)
girl 41 2.81 (0.49) 3.09 (0.65) t(40) = −3.43, p = 0.00*
f (1, 86) = 1.146
boy 48 3.02 (0.54) 3.08 (0.51) t(47) = −0.71, p = 0.48 p = 0.287, η2 = 0.013
total 89 2.92 (0.53) 3.09 (0.58) t(88) = −2.68, p = 0.01*
*
significant difference at the 0.05 level.
3.6.2. students’ opinion questionnaire (soq)
data from soqs and interviews helped us understand students’
opinions regarding the overall activity. key findings can be
summarised as follows:
(i) students’ subjective impression was that they acquired
certain ct skills. they reported that they can detect and
describe the common behaviours or programming structures
used in different tasks (m = 4.03, sd = 0.77) and also that
they can suggest a more general solution for a given problem
(m = 4.00, sd = 0.79).
(ii) students reported that the guidelines in the worksheets
helped them develop a certain problem-solving process (m =
3.73, sd = 0.80). they find this process useful to think of
(‘‘it comes to mind’’) when solving problems in other domains
as well (m = 3.58, sd = 0.81). some relevant students’
statements are: ‘‘now i think differently and solve problems
more easily’’ and ‘‘i changed my way of thinking in problem
solving even in other subjects such as mathematics’’.
(iii) the students stated that they became familiar with basic programming constructs (m = 4.16, sd = 0.68) and that
they would like to continue with programming. in particular, h level students mentioned that they better understood some basic programming concepts they learned in other
programming environments, such as the control structure
(‘‘if. . . then. . . else’’) and the loop structure (‘‘for. . . next’’, ‘‘do
while. . . ’’). they also said that working with the robots not
only helped them develop a deeper understanding of programming (m = 4.11, sd = 0.67) but also kept them in-
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 667
table 8
comparing ct-10 and ct-4 scores analytically for the five ct dimensions (j level only).
ct skills gender ct-4 ct-10 paired t-test ancova
m (sd) m (sd) comparing ct-10 across school
levels (ct-4 as covariate)
abstraction girl 2.42 (0.78) 2.62 (0.91) t(40) = −1.56, p = 0.13 f (1, 86) = 1.866
boy 2.57 (0.84) 2.44 (0.84) t(47) = 0.88, p = 0.38 p = 0.175, η2 = 0.021
generalisation girl 2.43 (0.70) 2.66 (0.92) t(40) = −1.66, p = 0.11 f (1, 86) = 0.00
boy 2.70 (0.87) 2.74 (0.91) t(47) = −0.25, p = 0.80 p = 0.989, η2 = 0.00
algorithm girl 3.01 (0.71) 2.99 (0.65) t(40) = 0.20, p = 0.85 f (1, 86) = 0.037
boy 3.15 (0.77) 2.97 (0.65) t(47) = 1.15, p = 0.26 p = 0.848, η2 = 0.00
modularity girl 3.18 (0.79) 3.54 (0.94) t(40) = −2.02, p = 0.05*
f (1, 86) = 0.073
boy 3.48 (0.76) 3.60 (0.82) t(47) = −0.98, p = 0.33 p = 0.787, η2 = 0.001
decomposition girl 3.00 (0.97) 3.66 (0.82) t(40) = −4.59, p = 0.00*
f (1, 86) = 0.123
boy 3.20 (0.94) 3.67 (0.60) t(47) = −3.39, p = 0.00*
p = 0.727, η2 = 0.001
*
significant difference at the 0.05 level.
table 9
statistical analysis comparing ct-ta between gender groups (j level only).
ct skills girls (n = 41) boys (n = 48) independent t-test
m (sd) m (sd)
abstraction 2.31 (0.94) 2.11 (0.80) t(87) = 1.12,
p = 0.27
generalisation 2.32 (1.08) 2.24 (1.11) t(87) = 0.33,
p = 0.74
algorithm 2.91 (0.69) 2.65 (0.80) t(87) = 1.66,
p = 0.10
modularity 2.68 (1. 33) 2.53 (1.34) t(87) = 0.54,
p = 0.60
decomposition 3.12 (1. 25) 2.95 (1.16) t(87) = 0.68,
p = 0.50
total ct-ta 2.71 (0.73) 2.54 (0.66) t(82) = 1.14,
p = 0.26
terest and motivated them to keep working on programming
(m = 3.42, sd = 0.66).
(iv) regarding collaboration, the students enjoyed working in
groups (‘‘three minds are better than one’’, ‘‘we motivate each
other when working together’’) and assuming ct relevant roles
(m = 4.06, sd = 0.72) with the most popular role being that
of the ‘‘programmer’’.
(v) finally, the students found the robotics experience very interesting (m = 4.38, sd = 0.63), reporting that they would like
to continue practising er in the future (m = 3.65, sd = 0.84)
and engage in more challenging tasks. indicative of their interest is the fact that when finishing with the worksheets, they
explored different programming structures (‘‘blocks’’) – even
those they had not learned yet – and different ideas to expand
and improve their solutions.
3.7. discussion and conclusions
the current work analysed the development of students’ computational thinking skills in the context of educational robotics,
with special focus on the impact that the instructional approach
may have on student groups of different ages and genders. the
study provides evidence from evaluation instruments administered at various times during the activity, thus offering a picture of
how ct skills develop as students’ work progresses. students’ ct
skills are also evaluated using different modalities in assessment
instruments (questionnaires answered in written and problemsolving think aloud protocols). finally, researchers’ observations
and qualitative data from students’ opinion questionnaires help
triangulate data and deeper understand their meaning.
a first observation is that students develop the same level of ct
skills at the end of their training independently of age. additionally,
ct skills in most cases are significantly improved as the training
proceeds (comparing ct-4 and ct-10 scores in tables 4 and 5).
this is clear for the total population and for each of the two
groups, although for the j group appears as a strong tendency (p =
0.059) not exactly reaching the level of significance (table 4, paired
t-test and ancova). thus, one key conclusion is that the
satisfactory development of ct skills needs a considerable number
of training sessions – independently of student’s age – and is not
simply a matter of a few training sessions. this conclusion is in
line with studies emphasising that skill development in general
requires adequate amount of training time [33,53].
reflecting further on table 5, we see that significant differences
between ct-10 and ct-4 measures are identified in certain
cases independently of student’s level (age) (clearly for the
modularity and decomposition dimensions), while in other cases
such differences are evidenced only for the h group (algorithm
and generalisation dimensions) or not at all (abstraction). to
explain these differences we resort to researchers’ observations
regarding the group composition and students’ preference for
writing. most students in the h group are boys not so willing to
provide answers in written (this is in line with studies suggesting
that boys are significantly more reluctant writers than girls, for
example [54]). by contrast, students in the j group are almost
equally distributed across gender and adopt a more positive
attitude towards expressing themselves in written (compared to
boys in h group).
keeping this in mind, we explore the implications of data in
table 5. as the development of the abstraction skill for both groups
reaches a high level already in session 4 (not to be surpassed
in the next sessions), this is an indication that students from
session 4 onwards deal with programming tasks without further
development of this skill in a way that is reflected in the measures.
also, the additional workload of expressing this skill in written
does not seem to affect students in the high group. however,
generalisation and algorithm skills are further developed (from
ct-4 to ct-10) only for the high group (table 5). this is probably
explained by the observation that younger students in the j group
are more willing to follow instructions and provide answers in
written (so their scores are high already from the 4th session
(ct-4)), while students in the h group improve significantly
from ct-4 to ct-10 as they gradually familiarise themselves
with following the worksheet guidelines and become more
willing to provide written documents expressing their thinking.
these explanations are further supported by the fact that the
aforementioned differences are not observed when the modality
of the assessment instrument changes (see also comments
below regarding table 6). finally, considering the modularity
and decomposition dimensions we observe significant differences
between ct-10 and ct-4, for both j and h groups. regarding
modularity, we believe that the significant improvement of
668 s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670
ct-10 score for the j group is mainly due to the improvement of
the girls’ ct-10 score in the group (see also modularity in table 8,
we comment on that further below). regarding decomposition,
we see that both boys and girls in j group improve significantly
their ct-10 score (see also table 8) and this, we believe, is due
to the increase of problem complexity as the training proceeds.
increased problem complexity gives the opportunity to students
of both groups (j and h) to practise the skill more extensively and
this is reflected in their scores. additionally, we identify – only for
decomposition – a statistically significant difference between the
two groups favouring students in the j group (ancova in table 5).
we suggest that this is another manifestation of the unwillingness
of boys in the h group to routinely follow instructions. students
in this group do not actually think it is necessary to decompose
the problem into smaller ones to solve it. however, this attitude
could also be linked to the cognitive maturity of elder adolescents
in group h as compared to the younger adolescents in group j,
which enables the former to manage more complex programming
solutions without decomposing them.
moving on to table 6 (ct-ta scores), we see that when evaluating students’ ct skills orally (think-aloud protocol) no betweengroup differences are identified (except for generalisation,
favouring the h group). this, corroborates our already stated conclusions that: (a) development of ct skills happens in the same
way for both groups independently of age, and (b) ct skills measures might be affected by the workload imposed on students from
the recording instrument modality. when students are asked to
provide written evidence of their skills, they might appear to underperform because of poorly following the instructions (as in decomposition, table 5). however, it is not clear why the h group
outperforms j in generalisation (table 6). one possible explanation
is that the oral modality allows the specific profile male students
in group h to thoroughly express their more complex thinking required to describe a generalised problem solution. thus, we might
have here another indication of the interaction between students’
scores and assessment instrument modality, which should be seriously considered by researchers in relevant studies. in all other
dimensions (and also in the total ct skills score) no significant differences are recorded.
next, we focus on the analysis of scores between gender groups
(tables 7–9). a key conclusion here is that, although boys and
girls reach the same ct skills level (ancova in table 7), there is,
however, a significant difference between ct-10 and ct-4 scores
for the girls’ subsample indicating that the girls need longer time
to reach the same skills level. this difference is also reflected on the
total population (paired t-tests in table 7). this outcome is in line
with other studies suggesting that girls seem to require more time,
compared to boys, when it comes to skills development (see [55]).
table 8 presents analytically the ct-10 and ct-4 skills scores
in the five dimensions for boys and girls. the previously discussed
pattern (‘‘both genders reach the same skill level but girls need
more time’’) appears again for the abstraction (strong tendency
for girls, p = 0.13), generalisation (strong tendency for girls,
p = 0.11), modularity (significant difference for girls, p = 0.05),
but not for the algorithm or the decomposition dimensions. for the
decomposition, we believe, the explanation is the same as before;
the increased complexity of programming tasks as the training
proceeds allow students of both genders to practise decomposition
more systematically and this is reflected in their scores.
finally, some interesting evidence emerges in table 9. on
one hand, no significant differences in ct skill scores appear
(neither for the total ct-ta score nor for any dimension, except for
strong tendency in algorithm, favouring girls). the ‘‘no significant’’
outcome is compatible with the overall gender pattern that boys
and girls reach finally the same skills level. on the other hand,
however, the strong tendency in algorithm seems to be at odds
with what has been discussed so far, as the algorithm relevant skill
is the only one developed in the same way by both boys and girls
(table 8). one possible explanation might be that while girls in
the j group understand and express the algorithmic dimension of
a programming task as efficiently as boys (table 8), nevertheless,
when they are additionally given the opportunity to express their
algorithmic thinking orally, they tend to do that more effectively
than boys (table 9). anyway, we acknowledge that more research
is needed to clarify that point.
by reflecting on researchers’ observations we report the most
important of them as follows: (a) despite any initial difficulties in
grasping the concept of abstraction, students were able to easily
identify the common programming concepts when comparing
different scenarios. this conclusion is in line with quantitative
data indicating that abstraction is easily grasped and practised
by students. (b) in the beginning, the students, faced difficulties
in understanding the concept of generalisation and suggesting
more general solutions. however, at the end of the training,
interesting generalisations were observed in students’ solutions.
especially students in the h group assimilated the concept more
easily and used it in the activities often without any intervention
from trainers. this corroborates the findings in table 6 where
elder adolescents (the h group) seem to practise generalisation
significantly better when the assessment modality is oral. thus,
generalisation appears to be a ct skill which develops better in
elders and this is perhaps related to the cognitive developmental
level of the h group. certainly, more research is needed to further
clarify the issue. (c) most students had difficulty in describing the
algorithm with clarity and accuracy. they preferred to describe a
process in general rather than analyse it step by step. perhaps this
is due to the cognitive load induced when analytically expressing
the algorithm. here, again, a modality effect is identified (girls
tend to orally describe the algorithm better than boys— table 9).
(d) the students, encouraged by the trainers, practised the skill of
modularity in their activities by creating their own programming
‘‘blocks’’. the students in j group familiarised with and integrated
the skill more than the students in h group. this last observation
is in line with quantitative data (table 5) showing that j group
applies decomposition better. we attribute that behaviour mostly
to h group students’ unwillingness to follow instructions for
decomposing problems, being able to manage the code as a whole.
overall, this study provides evidence that: (a) students of
different ages (15 vs. 18) and genders eventually reach the same
level of ct skills development; this view is supported by evidence
from assessment instruments using two modalities. (b) time is
an essential commodity for ct skills development; skills level
evaluated in later session have been found in most cases to be
significantly improved when compared to initial session. (c) when
analysing the particular skills of the ct model certain differences
are identified which are related to the following factors: age and
student cognitive developmental level, students’ attitudes relevant
to following instructions and afford workload induced by the task,
and also gender. (d) the assessment instrument modality may
have an impact on students’ scores as boys are, generally, more
reluctant writers compared to girls. when this attitude is intense
then boys may appear to underperform if skills evaluation is based
on instruments of written modality. (e) girls appear in most cases
to need more time (training sessions) in order to reach the same
skill level as boys. (f) provided that the overall instructional context
is supportive and the learning activity time is adequate, students
may overcome their initial difficulties and successfully develop
their ct skills.
understanding the above conclusions should be done while
also considering the limitations of the study. it is important
to remember that educational robotics activities cannot be
conducted under full experimental control and many factors might
s. atmatzidou, s. demetriadis / robotics and autonomous systems 75 (2016) 661–670 669
interact in an unexpected and – relatively – uncontrolled way.
the current study provides evidence coming from various data
collecting methods and with assessment instruments of different
modality, something that – we believe – increases the validity
of the conclusions. however, it was not possible to include a
control group in the design that would allow exploring the
issue of whether the ct skills in er activities develop in the
same way compared to a control non-er instructional condition.
an additional limitation is the exclusion of the h group from
across gender controls due to the highly uneven distribution of
girls/boys in the sample. this does not permit the current study to
simultaneously apply across-age and across-gender controls that
could further shed light on the gender relevant differences and
reveal any possible interaction between the two factors. finally,
the study did not administer any pre-intervention controls of
students’ ‘‘preference for writing’’ attitude and general ability
levels. our experience indicates that such tests could provide
valuable information regarding some of the observed gender and
group relevant differences.
acknowledgements
the authors would like to thank all school teachers, postgraduate student-trainers and the students involved in the er seminars
for their helpful collaboration and also the journal editor and the
manuscript reviewers for their constructive comments."
"comprehensive articles
48 acm inroads 2011 march • vol. 2 • no. 1
bringing
computational
thinking to k-12:
what is involved
and what is the role
of the computer
science education
community?
the process of increasing student exposure to computational thinking in k-12 is complex,
requiring systemic change, teacher engagement, and development of signifi cant
resources. collaboration with the computer science education community is vital to this effort.
by valerie barr and chris stephenson
comprehensive articles
2011 march • vol. 2 • no. 1 acm inroads 49
1.0 introduction
when jeanette wing [12] launched a discussion regarding the
role of “computational thinking” across all disciplines, she ignited
a profound engagement with the core questions of what computer
science is and what it might contribute to solving problems across
the spectrum of human inquiry. wing argued that advances in
computing allow researchers across all disciplines to envision new
problem-solving strategies and to test new solutions in both the
virtual and real world. computing has made possible profound
leaps of innovation and imagination as it facilitates our efforts to
solve pressing problems (for example, the prevention or cure of diseases, the elimination of world hunger), and expands our understanding of ourselves as biological systems and of our relationship
to the world around us. these advances, in turn, drive the need
for educated individuals who can bring the power of computingsupported problem solving to an expanded fi eld of endeavors.
it is no longer suffi cient to wait until students are in college
to introduce these concepts. all of today’s students will go on to
live a life heavily infl uenced by computing, and many will work in
fi elds that involve or are infl uenced by computing. they must begin to work with algorithmic problem solving and computational
methods and tools in k-12. the successful embedding of computational thinking concepts into the k-12 curriculum requires
efforts in two directions. educational policy must be changed,
overcoming signifi cant infrastructure hurdles, and k-12 teachers
need resources, starting with a cogent defi nition and relevant ageappropriate examples. in this paper we report on the fi rst part of a
multiphase project aimed at developing an operational defi nition
of computational thinking for k-12 along with suitable resources
for policy and curricular change. in addition to explaining the issues involved in the k-12 arena, this paper, following gal-ezer
and stephenson [4], is intended to help bridge the gap between
the k-12 and cs education communities. we note that this effort
is distinct from cs education efforts, such as that of zendler and
spannagel [13], in that our goal is to articulate a set of key concepts within computation that can be applied across disciplines,
rather than proposing a set of central concepts of computer science solely for cs curricula.
the computer science education community can play an important role in highlighting algorithmic problem solving practices and
applications of computing across disciplines, and help integrate the
application of computational methods and tools across diverse areas
of learning. at the same time, cs educators must understand the
complexities of the k-12 educational setting, incorporating that
knowledge into outreach activities and support for k-12 changes.
developing a defi nition of, or approach to, computational thinking that is suitable for k-12 is especially challenging in light of the
fact that there is, yet, no widely agreed upon defi nition of computational thinking. certainly, k-12 students already learn how to
think and to problem solve, but computer scientists can help teachers understand these processes as algorithmic, and identify where
actual computation and manipulation of data with a computer may
fi t in. many disciplines require, promote, and teach problem solving skills, logical thinking, or algorithmic thinking. computer scientists can promote understanding of how to bring computational
processes to bear on problems in other fi elds and on problems that
lie at the intersection of disciplines. for example, bioinformatics
and computational biology are different, but both benefi t from the
combination of biology and computer science. the former involves
collecting and analyzing biological information. the latter involves
simulating biological systems and processes. presenting both bioinformatics and computational biology in algorithmic form helps
scientists exchange information [5].
2.0 multiple definitions of computer
science and computational thinking
questions of the nature and educational value of computer science
are as old as the discipline itself. in 1985, abelson and sussman
argued that computer science is “a discipline of constructing appropriate descriptive languages” [1]. denning [2], however, posited
that computer science consists of mechanics (computation, communication, coordination, automation, and recollection), design
principles (simplicity, performance, reliability, evolvability, and security) and practices (programming, engineering systems, modeling and validation, innovating, and applying). the acm model
curriculum for k-12 computer science [11] provides a defi nition of computer science specifi cally for k-12 educators. computer
science, it argues, is neither programming nor computer literacy.
rather, it is “the study of computers and algorithmic processes including their principles, their hardware and software design, their
applications, and their impact on society” (pg.1). computer science
therefore includes:
■ programming,
■ hardware design,
■ networks,
■ graphics,
■ databases and information retrieval,
■ computer security,
■ software design,
■ programming languages and paradigms,
■ logic,
■ translation between levels of abstraction,
■ artifi cial intelligence,
■ the limits of computations (what computers cannot do),
■ applications in information technology and information
systems, and
■ social issues (internet security, privacy, intellectual property, etc.).
more recently, felleisen and krishnamurthy [3] have argued
that “imaginative programming” is the most crucial element of
computing because it closely aligns mathematics with computing
and in this way brings mathematics to life.
in framing the conceptual and educational importance of computational thinking, as distinct from computer science, wing [12]
suggested that computational thinking includes seeking algorithmic 
comprehensive articles
bringing computational thinking to k-12
continued
50 acm inroads 2011 march • vol. 2 • no. 1
approaches to problem domains; a readiness to move between differing levels of abstraction and representation; familiarity with decomposition; separation of concerns; and modularity. more recently,
isbell et al. [7] have argued for “computationalist thinking”, a focus
on providing services, interfaces, and behaviors that involves a more
central role for modeling as a means of formulating relationships
and identifying relevant agencies that are sources of change.
as the international working group on computational
thinking [8] pointed out, however, computational thinking “shares
elements with various other types of thinking such as algorithmic thinking, engineering thinking, and mathematical thinking”.
perkovic et al. [10] similarly focus on the intellectual skills necessary to “apply computational techniques or computer applications
to … problems and projects” in any discipline. hemmendinger [6]
notes that we must be aware of the risks of arrogance and overreaching when discussing the role of computational thinking, especially across disciplines. he argues that the elements of computational thinking that computer scientists tend to claim for their
own (constructing models, fi nding and correcting errors, creating
representations, and analyzing) are shared across many disciplines
and that the appearance of grand territorial claims risks provoking
adverse reactions. hemmendinger concludes that the ultimate goal
should not be to teach everyone to think like a computer scientist,
but rather to teach them to apply these common elements to solve
problems and discover new questions that can be explored within
and across all disciplines.
3.0 creating a definition for
computational thinking in k-12
k-12 education today is a highly complex, highly politicized environment where multiple competing priorities, ideologies, pedagogies, and ontologies all vie for dominance. it is simultaneously
subject to wildly diverse expectations, intense scrutiny, and diminishing resources. any effort to achieve systemic change in this
environment requires a deep understanding of the realities of the
system. passionate debate about the nature of computer science or
computational thinking may provide intellectual stimulation for
those in the computing fi elds. however, embedding computational
thinking in k-12 requires a practical approach, grounded in an operational defi nition. it requires that we begin with a set of questions focused specifi cally on k-12 implementation:
■ what would computational thinking look like in the
classroom?
■ what are the skills that students would demonstrate?
■ what would a teacher need in order to put computational
thinking into practice?
■ what are teachers already doing that could be modifi ed and
extended?
to be useful, a defi nition must ultimately be coupled with examples that demonstrate how computational thinking can be incorporated in the classroom. research regarding the implementation of computational thinking skills in informal education also
provides valuable insights. the international working group on
computational thinking [8], for example, points to several successful projects that use simulation and modeling, robotics, and
computer game design to teach abstraction, automation, and analysis. as they note, these kinds of activities also involve an iterative
design, refi nement, and refl ection process that resnick [9] argues is
central to creative as well as computational thinking.
in the summer of 2009, the computer science teachers association (csta) and the international society for technology in
education (iste) began a multiphase project aimed at developing an operational defi nition of
computational thinking for k-12.
these two organizations (see
appendix a for more information about csta and iste) are
particularly suited for this undertaking because of their extensive
involvement in k-12 and their expertise in developing educational
standards, curriculum materials, and professional development for
educators. this project would bring together computational thinking and k-12 curriculum thought leaders committed to focusing
on defi nitions and implementation of computational thinking in
the context of real k-12 curriculum outcomes, standards, and artifacts. the project began with the selection of a small steering committee that met to:
■ identify criteria for and names of potential invitees for a
thought leaders meeting; and
■ develop an agenda for a two-day thought leaders meeting
designed to create a framework/lexicon to better facilitate
discussions of key elements of computational thinking across
diverse disciplines.
the steering committee identifi ed a group of educators and administrators who
■ had interest in computational thinking for k-12 or expertise
in curriculum development and implementation
■ would provide representation from a broad spectrum of
backgrounds and perspectives (higher education faculty and
researchers, k-12 professional associations, school-based
leaders, teachers, the corporate community),
■ had experience with or demonstrated interest in k-12 issues, and
to be useful, a defi nition must ultimately
be coupled with examples that
demonstrate how computational thinking
can be incorporated in the classroom.
comprehensive articles
2011 march • vol. 2 • no. 1 acm inroads 51
■ demonstrated leadership,
particularly in stem discipline
areas.
the steering committee eventually selected 26 thought leaders and
charged them with developing a shared
vision and set of strategies for embedding computational thinking across the
k-12 curriculum, most especially in the
stem subject areas. the purpose of
the meeting, held over two days in april
2010, was not to craft a formal or defi nitive defi nition of computational thinking to be debated by academics. rather,
the goal of the meeting was to reach a
consensus of what computational thinking means in k-12, as well as explain
the particularities of k-12 education to
the cs education representatives. specifi cally, for any k-16 collaboration to
be successful, college faculty must understand the complexities of teaching in
and making changes in the k-12 setting. the computer scientists
participating, in particular, noted that educational change was
considerably more complex than they suspected and that working
with educators from multiple diverse disciplines meant learning
to “disconnect computational thinking from computer science”.
4.0 ways of envisioning
computational thinking
in k-12 classroom
the participants identifi ed many ideas about what computational
thinking is and what it could be in k-12 classrooms. when challenged with the task of describing what makes computational
thinking distinct from other kinds of thinking, participants tended
to focus on the centrality of the computer and a set of concepts
encompassed by computational thinking and doing:
ct is an approach to solving problems in a way that can be
implemented with a computer. students become not merely tool
users but tool builders. they use a set of concepts, such as abstraction, recursion, and iteration, to process and analyze data,
and to create real and virtual artifacts. ct is a problem solving
methodology that can be automated and transferred and applied
across subjects.
they also considered the generation of computational thinking
from, and its potential use in, a wide variety of disciplines:
the power of computational thinking is that it applies to every
other type of reasoning. it enables all kinds of things to get done:
quantum physics, advanced biology, human-computer systems, development of useful computational tools.
the participants envisioned computational thinking manifesting
in the classroom through active problem
solving. they saw students: “engaged in
using tools to solve problems”, “comfortable with trial and error”, and working in
“an atmosphere of fi guring things out together”. they also saw students using key
concepts, so that “you will hear them talk
about sequences, inputs, outputs, saved
value, how complex the solution is”. the
meeting participants also predicted that
students whose learning abounded with
opportunities for “computational doing” would evidence a more fl uid kind of
problem solving. these students would
understand that “problems can be solved
in multiple ways”, have “a tolerance for
ambiguity and fl exibility” and have “reasonable expectations about the prospect
of producing a working solution”.
one structured model that emerged
focused on identifying core computational thinking concepts and capabilities and providing examples of how they
might be embedded in activities across multiple disciplines. table
1 shows the results of these efforts.
participants also discussed the core concepts in the context of
capabilities, dispositions and pre-dispositions, and classroom culture. in many ways the capabilities category is a reiteration of the
core concepts, focused on what students would actually do. these
capabilities include:
■ design solutions to problems (using abstraction, automation,
creating algorithms, data collection and analysis);
■ implement designs (programming as appropriate);
■ test and debug;
■ model, run simulations, do systems analysis;
■ refl ect on practice and communicating;
■ use the vocabulary;
■ recognize abstractions and move between levels of
abstractions;
■ innovation, exploration, and creativity across disciplines;
■ group problem solving; and
■ employ diverse learning strategies.
the dispositions and pre-dispositions category arose from
an attempt to capture the “areas of values, motivations, feelings,
stereotypes and attitudes” applicable to computational thinking.
these included:
■ confi dence in dealing with complexity,
■ persistence in working with diffi cult problems,
■ the ability to handle ambiguity,
■ the ability to deal with open-ended problems,
■ setting aside differences to work with others to achieve a
common goal or solution, and
■ knowing one's strengths and weaknesses when working with
others.
the meeting
participants also
predicted that
students whose
learning abounded
with opportunities
for “computational
doing” would
evidence a more
fl uid kind of
problem solving.
comprehensive articles
bringing computational thinking to k-12
continued
52 acm inroads 2011 march • vol. 2 • no. 1
■ team work by students, with explicit use of:
• decomposition - breaking problems down into smaller parts
that may be more easily solved,
• abstraction - simplifying from the concrete to the general as
solutions are developed,
• negotiation - groups within the team working together to
merge parts of the solution into the whole, and
• consensus building - working to build group solidarity
behind one idea or solution.
in attempting to defi ne a classroom culture that would be most
conducive to computational thinking, the participants identifi ed
strategies or characteristics that could be considered broadly
benefi cial to any learning experience. these included:
■ increased use by both teachers and students of computational
vocabulary where appropriate to describe problems and solutions;
■ acceptance by both teachers and students of failed solution
attempts, recognizing that early failure can often put you on
the path to a successful outcome;
ct concept,
capability cs math science social studies language arts
data collection
find a data source for
a problem area
find a data source for
a problem area, for
example, fl ipping coins
or throwing dice
collect data from an
experiment
study battle statistics
or population data
do linguistic analysis
of sentences
data analysis
write a program to
do basic statistical
calculations on a set
of data
count occurrences of
fl ips, dice throws and
analyzing results
analyze data from an
experiment
identify trends in data
from statistics
identify patterns for
different sentence
types
data representation
use data structures
such as array, linked
list, stack, queue,
graph, hash table, etc.
use histogram, pie
chart, bar chart to
represent data; use
sets, lists, graphs, etc.
to contain data
summarize data from
an experiment
summarize and
represent trends
represent patterns
of different sentence
types
problem
decomposition
defi ne objects and
methods; defi ne main
and functions
apply order of
operations in an
expression
do a species
classifi cation
write an outline
abstraction
use procedures to
encapsulate a set
of often repeated
commands that
perform a function;
use conditionals,
loops, recursion, etc.
use variables in
algebra; identify
essential facts in a
word problem; study
functions in algebra
compared to functions
in programming;
use iteration to solve
word problems
build a model of a
physical entity
summarize facts;
deduce conclusions
from facts
use of simile and
metaphor; write a
story with branches
algorithms &
procedures
study classic
algorithms; implement
an algorithm for a
problem area
do long division,
factoring; do carries in
addition or subtraction
do an experimental
procedure
write instructions
automation
use tools such as:
geometer sketch pad;
star logo; python code
snippets
use probeware use excel use a spell checker
parallelization
threading, pipelining,
dividing up data or
task in such a way
to be processed in
parallel
solve linear
systems; do matrix
multiplication
simultaneously run
experiments with
different parameters
simulation
algorithm animation,
parameter sweeping
graph a function in a
cartesian plane and
modify values of the
variables
simulate movement of
the solar system
play age of empires;
oregon trail
do a re-enactment
from a story
table 1: core computational thinking concepts and capabilities
comprehensive articles
2011 march • vol. 2 • no. 1 acm inroads 53
■ improve the relationships and communication between k-12
educators (faculty and administrators), college cs faculty,
computer science professionals, and others in industry.
■ develop a clear statement of computational thinking as a
core competency in k-12.
■ demystify terminology about computational thinking, give
clear examples of ways it applies to and can be integrated
into a range of curricular areas.
5.2 inspiration and leadership
an activity for school and district level leadership inspiring change
is to provide materials that will help school administrators understand computational thinking and see why associated knowledge
and skills are important for today's students. the larger cs community can help by providing suitable materials and taking advantage of opportunities to work with k-12 administrators.
inspiring and preparing teachers to change include the following activities.
■ foster professional development since it is critical to successful
educational change. cs faculty can help by providing summer
institutes, demonstrating the role of computational thinking in
non-cs disciplines and providing relevant curricular materials.
■ encourage school administrators to provide incentives for
k-12 teachers to change courses and curricula. the nsf
ret grants awarded to cpath grantees are one model that
provides incentives for k-12 teachers to adopt curricular or
pedagogic changes that have been piloted at the college level.
■ provide teachers with resources to support change, including
curricular materials, models and simulations, model activities,
and web sites for independent student activities.
■ provide teachers with professional development and support
in the form of learning communities, summer institutes, peer
learning offered by teachers with computational thinking
experience, exposure to industry applications where ct
skills are utilized, and help identifying where computational
thinking is already included in teaching.
■ make available to school districts open-source tools (blogs,
wikis, forums) and web-based social networks and content
delivery systems for use by teachers and students (vetted so
that districts are not likely to block them).
■ encourage current professional education associations to
show how computational thinking fi ts into their current
standards/work.
while further detail and synthesis work is clearly required (and
planned for in the next phase of the project) these models provide
a way to begin embedding computational thinking within k-12
formal education. this counters the potential claim that computational thinking can only be addressed in informal education experiences where discipline based-learning and classroom constraints
are not major encumbrances. however, there are still considerable
barriers that must be considered in any attempt at systemic and
sustained change.
5.0 strategies for achieving
systematic change
the kind of systemic and sustained educational change proposed
necessitates two sets of resources. resources are needed to help
inform educational policy makers about the nature
and importance of computational thinking, its connections to learning goals that may have already
been set for students (for example national and state
standards), and ways it can best be integrated within
the larger framework for student learning and success. teachers also need resources that demonstrate
how to most appropriately and effectively integrate
these new concepts, fi rst into their own sphere of
content and pedagogical knowledge, and then into
their classroom content and practice.
in order to articulate and expand on these two set of resources,
the thought leaders identifi ed several strategic areas that would
have to be addressed in order to successfully embed computational
thinking within k-12. for each strategic area, they developed a set
of requirements and suggestions that would support that element
of systemic and sustained change.
5.1 policies, vision, and language
educational policies that include computational thinking as a part
of every student's education include the following activities.
■ present a single message at federal, state, and local levels
about the importance of computational thinking in k-12
education.
■ encourage computer science professional organizations to
advocate at the federal and state levels and work with groups
that are active on state k-12 standards.
■ incorporate computational thinking throughout the
entire k-12 experience with outcomes that demonstrate
incremental steps.
■ attach computational thinking, where possible, to existing
policies. for example, it could be included as an explicit
outcome of state level technology tests.
■ include in all teacher pre-service preparation programs a
class on computational thinking across disciplines.
a shared vision and common language include the following
activities.
the larger cs community can help
by providing suitable materials and
taking advantage of opportunities
to work with k-12 administrators.
comprehensive articles
bringing computational thinking to k-12
continued
54 acm inroads 2011 march • vol. 2 • no. 1 note: this project is supported by the national science foundation under grant nos. 0964217 and 1030054
references
 [1] abelson, h. and sussman g. structure and interpretation of computer programs. mit press,
cambridge, ma, 1985.
 [2] denning, p. great principles of computing. communications of the acm, 46(11). 15-20.
 [3] felleisen, m and krishnamurthi s. viewpoint - why computer science doesn't matter. communications of the acm, 52(7). 37.
 [4] gal-ezer, j. and stephenson, c. computer science teacher preparation is critical. acm
inroads, 1(1). 61-66.
 [5] hey, t., tansley, s. and k. tolle, “jim gray on escience: a transformed scientifi c method” in
the fourth paradigm: data-intensive scientifi c discovery. microsoft research, redmond,wa,
2009.
 [6] hemmendinger, d. a plea for modesty. acm inroads 1(2). 4-7.
 [7] isbell c., stein a., cutler r., forber j., fraser l., impagliazzo j., proulx v., russ s., thomas
r., xu y. (re)defi ning computing curricula by (re)defi ning computing. acm sigcse bulletin,
41(4). 195-207.
 [8] iwg, 2010, may, computational thinking for youth, education development center, inc.,
newton, ma
 [9] resnick, m. all i really need to know (about creative thinking) i learned (by studying how children learn (in kindergarten), acm 2007 creativity and cognition conference, washington, dc.
 [10] perkovic l., settle a., hwang s. and jones, j. a framework for computational thinking across
the curriculum, proceedings of the 2010 conference on innovation and technology in
computer science education, 2010, 123-127.
 [11] tucker, a., mccowan d., deek f., stephenson c., jones j. and verno a. a model curriculum
for k-12 computer science: report of the acm k-12 task force computer science curriculum
committee. association for computing machinery, new york, ny, 2003.
 [12] wing, j.m. computational thinking. communications of the acm, 49(3). 33-35.
 [13] zendler, a. and spannagel, c. empirical foundation of central concepts for computer science education. acm journal on educational resources in computing, 8(2).
valerie barr
computer science department, union college
807 union street, schenectady, ny 12308
barrv@union.edu
chris stephenson
computer science teachers association
2 penn plaza, suite 701, new york, ny 10121-00701
cstephenson@csta.acm.org
categories and subject descriptors: k.3.2 [computers and education]: computer and
information science education - computer science education, curriculum.
general terms: human factors
keywords: computational thinking, k-12 curriculum, k-12 cs education, cross-disciplinary
computing
doi: 10.1145/1929887.1929905 © 2011 acm 2153-2184/11/0300 $10.00
■ ask professional education associations to include a focus on
computational thinking in their conferences, workshops, and
professional development events.
these represent strategic areas that would support the longterm goal of embedding computational thinking in k-12. they
clearly demonstrate the myriad issues and obstacles involved when
trying to achieve educational change in k-12. they also illustrate
the critical importance of engaging knowledgeable k-12 educators
in projects that purport to improve student learning, and the extent
to which a successful effort will require the expertise, resources, and
dedication of educators and policy makers at all educational levels.
6.0 next step
the next phase of this project will involve a practitioners workshop
that will begin to develop the resources and strategies identifi ed in
the thought leaders meeting. the challenge will be to determine
the best possible artifacts to promote the implementation of computational thinking concepts in k-12. we expect that the practitioners
workshop will therefore include development of various resource
sets. for example, a framework might be developed to guide highlevel policy work (e.g school, district, state). a second resource might
consist of exemplars or activities for classroom teachers. while the
precise set of resources and their content have not yet been determined, it is clear that the practitioners workshop will be focused on
formulating new materials both for implementing ct concepts into
the curriculum and for advocating for computational thinking as a
key educational component for all students. given efforts already
under way at the college level, including the development of new
curricula and resources, we expect the computer science education
community will have much to contribute to this effort. ir
appendix a
csta is a membership organization of more than 7000 computing educators at the k-12 and post-secondary level. its mission is to
support and promote the teaching of computer science and other computing disciplines at the k-12 level by providing opportunities for teachers and students to understand better the computing disciplines and to prepare themselves more successfully to teach
and to learn. since its inception fi ve years ago, csta has become the primary voice for k-12 computer science education, advocating for
the importance of computer science as part of the educational canon and its centrality to all of the stem (science, technology, engineering, mathematics) disciplines. through its development and publication of the acm model curriculum for k-12 computer science
and supporting curriculum implementation documents, csta has provided the de facto national standards for computer science in k-12.
csta also conducts groundbreaking research and has published several germinal white papers on key computer science education issues.
it provides multiple levels of professional development (through workshops and annual conferences) that have helped educators improve
their technical knowledge and pedagogical skills.
i
ste is recognized for its leadership to improve learning and teaching through effective integration of technology across the curriculum
and throughout the education enterprise. iste's commitment to educational transformation is best represented by its work to develop
the national educational technology standards (nets) for students, teachers, and administrators. by convening k-12 educators,
teacher educators, curriculum and education associations, government, business, and private foundations, iste built consensus for the
framework and momentum for using the standards. iste is a also a leader in convening educators and school leaders, best illustrated by its
annual conference which showcases emerging technology and innovative and effective use of technology in the k-12 classroom."
"contents lists available at sciencedirect
computers in human behavior
journal homepage: www.elsevier.com/locate/comphumbeh
full length article
can computational thinking be improved by using a methodology based on
metaphors and scratch to teach computer programming to children?
diana pérez-marína,∗
, raquel hijón-neiraa
, adrián baceloa
, celeste pizarrob
a rey juan carlos university, computer science department, móstoles, madrid, spain
b rey juan carlos university, applied mathematics department, móstoles, madrid, spain
article info
keywords:
computational thinking
primary education
programming
methodology
metaphor
abstract
computational thinking (ct) is a key skill in the 21st century. however, it is not clear which is the most effective
way to acquire and improve ct. big research efforts are made to determine which pedagogical means should be
used. one research trend is based on the idea that teaching programming since primary education suffices to
improve ct. in our previous work, we proposed and validated a methodology based on metaphors and used of
scratch (mecoprog) to teach basic programming concepts to children. it is our hypothesis h that by applying
mecoprog, students will develop their ct. to check h, we carried out an experiment with 132 primary
education students (9–12 years in age). at the beginning of the experiment, all students were asked to fill in a
programming concepts test and two tests to measure their ct. during the sessions, all students were taught
according to mecoprog. finally, they took the three tests again. a significant increase in the results on all the
tests has been measured, supporting the use of metaphors and scratch to teach computer programming concepts
to primary education students to develop their ct.
1. introduction
computational thinking (ct) can be defined as the skill of solving
problems, designing systems, and understanding human behavior based
on computer science concepts (wing, 2006). ct is a key skill for children in the 21st century (wing, 2016). however, it is unclear how ct
can be developed in the most effective way in children. currently,
different pedagogical methodologies that can be used to develop ct are
being researched.
in the last years, some authors have claimed that ct can be acquired
and developed by teaching programming to children. in addition, it has
been claimed that this should be done as early as possible (heintz,
mannila, & färnqvist, 2016; kazakoff, sullivan, & bers, 2013;
mccartney, 2015; mccartney & tenenberg, 2014; papadakis,
kalogiannakis, & zaranis, 2016; strawhacker, portelance, lee, & bers,
2015).
it is possible that ct can be acquired by other means such as
educational robotics (bers et al., 2010), storytelling (lee et al., 2011),
unplugged activities (brackmann, barone, casali, boucinha, & muñozhernández, 2016), scratch jr (papadakis et al., 2016) or even in ethics
lessons (seoane-pardo, 2018). although this paper focuses on programming to foster ct, learning how to program is worthwhile not only
for that reason, but also because of the real need for programmers in
our digital society (margulieux, catrambone, & guzdial, 2016), as well
as other advantages such as the improvement of higher cognitive skills
(pea & kurland, 1984).
many countries implemented computer science as a subject in
primary education to train students into creators of computer programs
(heintz et al., 2016). a common approach to teaching computer science to children is scratch, defined as an authoring environment - developed by the lifelong kindergarten research group at the mit media
lab - to design interactive media by snapping together programminginstruction blocks (resnick et al., 2009; ouahbi, kaddari, darhmaoui,
elachqar, & lahmine, 2015). other approaches focus on using makey
makey, where students can interact with the computer by means of
fruits or play-doh rather than using the traditional mouse (lee, kafai,
vasudevan, & davis, 2014); using lego wedo or mindstorms ev3 robots (sović, jagušt, & seršić, 2014), and (producing) making games
(campe & denner, 2015). another possibility is to follow unplugged
approaches using storytelling or free exercises from code.org. this is
particularly useful in countries with limited resources, but also in developed countries, where computer science is considered interesting,
but there is a lack of trained teachers and/or resources (brackmann
et al., 2016).
the results of these approaches have not yet been properly evaluated, and their effectiveness is still unclear (kalelioğlu, 2015).
https://doi.org/10.1016/j.chb.2018.12.027
received 28 december 2017; received in revised form 6 august 2018; accepted 16 december 2018
∗ corresponding author.
e-mail address: diana.perez@urjc.es (d. pérez-marín).
computers in human behavior xxx (xxxx) xxxx
0747-5632/ © 2018 elsevier ltd. all rights reserved.
please cite this article as: diana pérez-marín, et al., computers in human behavior, https://doi.org/10.1016/j.chb.2018.12.027
moreover, no methodology or particular resources have been identified
as the most adequate to teach programming to children.
there are difficulties in teaching children even basic concepts such
as program construction (lahtinen, ala-mutka, & järvinen, 2005),
loops (ginat, 2004), structures control, and algorithms (seppälä,
malmi, & korhonen, 2006). these difficulties arise because of poor
teacher training or a lack of a proper teaching methodology (barker,
mcdowell, & kalahar, 2009; coull & duncan, 2011). it has become
evident that teachers need guidance to approach this task adequately
(brackmann et al., 2016; jovanov, stankov, mihova, ristov, & gusev,
2016; yadav, gretter, hambrusch, & sands, 2016).
in our previous work, we proposed and validated the use of metaphors to introduce children to basic concepts of programming according
to the methodology mecoprog (pérez-marín et al., 2018). for instance, we proposed using the metaphors of a thermomix® recipe as a
program (and sequence), pantry as memory, and boxes as variables. we
also illustrated the possibility of applying these metaphors to any resource available to the teacher, such as scratch.
the reason for using metaphors is the widely reported usefulness of
metaphors as powerful educational tools. metaphors focus on concepts
and facilitate students' organization of ideas and clearer, more
straightforward thinking (rodríguez diéguez, 1988). using metaphors
does not require special equipment and helps teachers turn abstract
concepts into simple ideas and images. students need clear and careful,
well-focused thinking to correctly write computer programs (heintz
et al., 2016).
this research paper asks the following question: can computational
thinking be improved by using a methodology based on metaphors and
scratch to teach computer programming to children? it is our hypothesis (h) that the answer is yes. for this study, we asked 132 primary
education students (aged 9 to 12) to follow mecoprog for six weeks.
there were two objectives: 1) to teach students the basic concepts of
computer science programming; and, 2) to develop students' ct by
teaching them those concepts using metaphors and scratch. the results
derived from this study show that using metaphors and scratch can
significantly develop students' ct, but also that students are able to
learn basic programming concepts.
the paper is organised as follows: section 2 reviews background
literature on computational thinking and teaching programming in
primary education; section 3 outlines the materials and methods of the
experiment carried out so that this study can be reproduced elsewhere;
section 4 presents the results of the experiment; and section 5, summarises the main conclusions and suggests future lines of work.
2. background
computational thinking (ct) is not a new term. it dates back to
1950s, when it was referred to as “algorithmic thinking”. it was defined
as a way to use algorithms to produce appropriate output to a given
input (denning, 2009). in 2006, wing relaunched interest in the topic
and defined ct as follows: “it involves solving problems, designing
systems, and understanding human behavior, by drawing on the concepts fundamental to computer science” (wing, 2006). given the generic nature of that definition, there has recently been several unsuccessful attempts to make it more specific (aho, 2012; brennan &
resnick, 2012; csta & iste, 2011; google for education, 2018; wing,
2008).
according to grover and pea (2013), ct includes decomposition,
pattern generalisations and location, abstraction and algorithms among
other computer science resources such as debugging and systematic
error detection, iterative, parallel and recursive thinking, control flow
and use of symbols.
brennan, balch, and chung (2014) also explored ct in terms of
programming, more specifically using scratch based on a 3-d ct classification into concepts, practices, and computational perspectives
(brennan & resnick, 2012). see table 1.
the goal is not to replace creative and critical thinking or other
competences, but to add the skill of using computers and algorithms to
solve problems (cuny, snyder, & wing, 2010; wing, 2011; csta &
iste, 2011; furber, 2012; espino, soledad, & gonzález, 2015). many
governments emphasise the need for children to be fluent in the digital
language rather than making them mere users of computer software
(garcía-peñalvo, 2016). there are already certain resources available in
the specialised literature for this (balanskat & engelhardt, 2015; wing,
2008).
learning how to program can induce changes in the way that people
think (papert, 1980; resnick, 1996). this is likely because of the analytical component of ct, which is quite similar to mathematical
thinking (i.e. problem solving), engineering thinking (design and evaluation of processes) and scientific thinking (systematic analysis).
ct can be useful not only for students or professionals of computer
science, but for any other person (wing, 2006). starting ct training as
early as possible is of particular interest, and it has been shown that
children aged as young as four can understand programming concepts
and even build simple robots which can move and interact with the
environment (bers, ponte, juelich, viera, & schenker, 2002; bers et al.,
2006).
this is why teaching computer science programming has been included in the primary education curricular in many countries (heintz
et al., 2016; see table 2). a commonly used approach to teach computer science to children is using scratch (resnick et al., 2009). while
interacting with scratch, students learn basic concepts such as sequences, loops, parallelism, events, conditionals, operators and data
(brennan & resnick, 2012; ouahbi et al., 2015).
other approaches include making an own program (campe &
denner, 2015), using lego wedo or mindstorms ev3 robots (sović
et al., 2014). with regard to unplugged approaches: these are common
in countries with limited resources, but also in developed countries,
which consider computer science an interesting option but lack trained
teachers and/or internet connections (brackmann et al., 2016).
in unplugged approaches, the concepts of computer science are
transmitted through storytelling or free exercises available on code.org.
it bears mentioning here that there is no established method to evaluate
the effectiveness of these approaches; therefore, their validity is still
unclear (kalelioğlu, 2015).
a previous study by pérez-marín et al. (2018) contributed to the
debate by introducing metaphors as an alternative approach to teaching
programming. metaphorical language is employed in real, everyday
life, and is considered a crucial component of thinking (lakoff &
johnson, 2008). in particular, conceptual metaphors (i.e., cognitive
mechanisms that project from a source domain to a target domain in
order to facilitate understanding of a concept in the target domain) are
of great interest in educational environments (sanford, tietz, farooq,
guyer, & shapiro, 2014).
metaphors have been used to teach biology (paris & glynn, 2004),
chemistry (thomas & mcrobbie, 2001), and mathematics (boero,
bazzini, & garuti, 2001). the use of metaphors to teach computer
science is common at college level and has been the subject of research
interest (putnam, sleeman, baxter, & kuspa, 1986; sanford et al.,
table 1
summary table of the 3-d ct dimensions model (source: brennan & resnick,
2012).
• concepts:
− sequences
− loops
− parallelism
− events
− conditionals
− operators
− data
• practices:
− incremental & iterative development
− test & debugging
− mix & reuse
− abstract & encapsulate
• perspectives:
− to express
− to connect
− to question
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
2
2014). there are studies on specific metaphors, such as the locker
memory to teach dynamic memory (jiménez-peris, pareja-flores,
patiño-martínez, & velázquez-iturbide, 1997), or matrixes for eventhandling in java (milner, 2010). however, the use of metaphorical
language as a tool to teach basic concepts of computer science for
primary education, and the minimum age at which it can be used, have
not yet been researched in detail. therefore, we proposed and validated
a methodology called mecoprog (see description in section 3) to
teach programming to primary education students, using metaphors.
the purpose of the experiment described in this paper is to analyse
whether mecoprog has an impact on the students' programming
knowledge and whether it can improve computational thinking in
students.
3. method
3.1. participants
132 spanish primary education students (56.1% male and 43.9%
femal, aged 9 to 12), recruited in two parts, were asked to take part in
the experiment in order to assess whether their computational thinking
(ct) improved after teaching programming using the mecoprog
methodology based on metaphors.
the reason for having two different parts is that programming is not
compulsory in spanish schools. therefore, only a few students, usually
in private schools, have the opportunity to attend programming lessons.
we asked several private schools that offered programming to collaborate in the study; one school agreed because their programming
teacher was on sick leave and they required a skilled temporary teacher
for 4th, 5th and 6th grades. we were given permission to teach using
the mecoprog method during the six weeks the teacher needed to
convalesce.
in addition, and in order to provide other children with the opportunity to attend programming classes and to ensure a more heterogeneous sample, we offered other schools in madrid and the city
council of fuenlabrada (where the authors live) a cost-free programming camp to be held on three consecutive saturdays, which children
aged 10 to 12 could attend. this camp also used the mecoprog
methodology.
50% of our participants attended private schools and the rest attended 32 different public schools and were recruited as they participated in the programming camp. fig. 1 shows the distribution of the
students per grade (in spain, 4th grade corresponds to students aged
9–10, 5th grade corresponds to students aged 10–11, and 6th grade
corresponds to students aged 11–12). 18.2% were 4th grade students,
38.6% were 5th grade students, and 45.2% were 6th grade students.
3.2. design
the research model followed a longitudinal pretest-posttest quasiexperimental design, because the head-master of the private school did
not provide a control group and we could not randomly assign students
to each group.
similarly, we could not have a control group in the programming
camp or randomly assign students to each group, because one of the
city council's conditions to providing us with a class-room was that all
students must receive the same teaching. moreover, as rooms were only
available from 10:00 a.m. to 2:00 p.m., we had to divide students; thus,
students in the 5th grade attended from 10:00 a.m. to midday, whereas
those in the 6th grade attended from midday to 2:00 p.m. it was not
possible to recruit 4th grade students from the city council.
according to cook & campbell (1986), we could measure the impact of our intervention using mecoprog by following the quasi-experimental design outlined below. no rewards were offered.
3.3. materials
3.3.1. mecoprog
our main resource was mecoprog (pérez-marín et al., 2018).
table 3 summarises the metaphors used in mecoprog grouped into
three blocks: 1 – program, sequence, variable and input and output
instructions, 2 - conditional instructions and 3 - loops.
the process for each block was (1) introduce the concept by using
metaphors, and then (2), practice with scratch. see fig. 2 for a global
overview of mecoprog.
block 1 (2 h): first, the concept of programming was explained by
using the thermomix® (tx) cooking recipe metaphor. children were
explained that – just likewhen they are following steps in a tx recipe -
table 2
interest in teaching programming (based on heinz, mannila & färnqvist. et al., 2016).
country content form primary secondary
australia digital technologies own subject and integrated compulsory compulsory
england computing replaces existing subject compulsory
estonia programming integrated compulsory compulsory
finland programming integrated compulsory
new zealand programming and computer science own subject opcional
norway programming own subject opcional
sweden programming and digital competence integrated compulsory opcional
south korea informatics own subject compulsory opcional
finland computer science own subject compulsory compulsory
usa computer science own subject opcional
macedonia computers and basics of programing own subject compulsory
fig. 1. distribution of the participants in grades.
table 3
metaphors used in mecoprog for programming concepts.
block concept metaphor
1 program, sequence, memory
and variable
thermomix® (tx) recipe, pantry and box
input and output mouth and rectum (beginning and end of
the digestive system)
2 conditional intelligent fridge
3 loop hand mixer
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
3
the computer is able to execute the instructions of a program one step at
a time. no ambiguity is allowed as the computer does not understand
instructions that are not precise. additionally, just as the goal of following a recipe is to produce good food, a program always has a specific
output. the first program that they are asked to execute in scratch is to
say “hello!“.
scratch's “say” and “ask” instructions help to teach basic input/
output programming concepts. whenever students do not understand
them, the metaphor of input as eating something with their mouth, and
how their digestive system processes it until it passes through the
rectum (output) is used. that way, students understand that you can
enter data into the computer (input), execute a program and produce a
result (output).
the concept of sequence is also explained here, as the sentences in a
tx recipe/program must be executed one after another. students are
also asked whether they think that a computer has a memory.
surprisingly, not all students think they do. therefore, we help them
understand the concept of computer memory by using the pantry metaphor. the concept of data was explained by comparing the ingredients they need to carry out a tx recipe with the data a computer
needs to executes a program. moreover, the pantry metaphor can also
be used to explain the concept of variables as a boxes metaphor. just
like food is organised in the kitchen: eggs in their box, fruit in their
fruit-bowl, etc. so the computer organises data into boxes inside its
memory as variables. to illustrate the concept, we created the scratch
program shown in fig. 2 left.
block 2 (2 h): an intelligent fridge was used as a metaphor to explain conditionals. students were told that the fridge has a sensor to
detect how many pieces of food it contains. for instance, we told
children to imagine that they were in charge of serving dessert to their
family at dinner. an intelligent fridge would know how many family
members there are and thus how many pieces of fruit they would need.
if they were four family members, they would need at least four pieces
of fruit. if there were fewer than four pieces contained in the fridge, the
intelligent fridge will connect to internet to buy more fruit. to illustrate
the concept, we created the scratch program shown in fig. 2 center.
block 3 (2 h): for loops, a hand mixer metaphor was used. just like
a hand mixer repeats the same movement over and over again, a loop
repeats the same command over and over again until a condition is
fulfilled. students are told that the condition in the case of the hand
mixer is to whip the eggs five times. to illustrate the concept, we created the scratch program shown in fig. 2 right.
following the 3d ct model (see table 1) for concept dimensions
the methodology covers sequences, loops, conditionals, operators and
data (see table 4 left). mecoprog also covers the first three practices
of the practices dimension (see table 1). all students were encouraged
to revisit their programs and incrementally improve them as they learnt
new concepts. all the examples involved testing and debugging when
simple coding was reused and incorporated into more complex ones
(see table 4 top right).
in regard to the perspective dimension, the metaphor methodology
also allows questioning (giving solutions to a proposed guided methodology) and expressing (giving solution to a problem using the computer) (see table 4 right bottom).
fig. 2. overview of mecoprog blocks: up (first) concept (second) scratch. from left to right: sample script to work with input/output (block 1), sample script to
work with conditionals (block 2), sample script to work with loops (block 3).
table 4
concepts, practices and perspectives covered by mecoprog, highlighted in
underlined, in the 3d ct model proposed by brennan and resnick (2012).
•concepts:
− sequences
− loops
− parallelism
− events
− conditionals
− operators
− data
• practices:
− incremental & iterative development
− test & debugging
− mix & reuse
− abstract & encapsulate
• perspectives:
− to express
− to connect
− to question
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
4
during the experiment, cutting cross all three blocks, we occasionally used an application named compthink app in our sessions (2018),
developed ad-hoc for the improvement of children's computational
thinking. the app works with seven aspects, all focused on improving
the students' computational thinking (see fig. 3):
1 loops: students select an element and set the number of times that
the element will repeat the action. then, they can watch an animation of the action being repeated the selected number of times.
2 algorithms: students establish the order of a finite set of steps to
carry out a certain activity, such as cooking a recipe, or planting a
tree.
3 patterns: students choose the different features of a face out of a
variety of options to create a face. they choose between different
types of hair, eyes or mouths, and the outcome is an animated gif
with the selections they have made.
4 conditionals: students drag and drop images according to the options given in “if/else” branches. for instance: “if the weather is cold
(scarfs, coat and boots), else (t-shirts, bathing suit and shorts)“.
5 steps: students select which part is missing from several possibilities
in the picture. in fig. 3, for example, cream and a cherry is needed
to complete the cupcake.
6 instructions: students find the final position on a map, divided in
squares, after following a set of movement instructions.
7 automats: students select the correct order to follow a path from
one place to another with certain restrictions.
compthink app (compthink app, 2018) is a drag-and-drop visual
interface for android tablets or smartphones. table 1 shows the 3-d ct
dimensions model (brennan & resnick, 2012). table 5 presents the
concepts that each part of the app covers including those proposed by
brennan and resnick (op. cit.).
3.3.2. tests
three tests have been used to measure the impact of our intervention that used mecoprog to teach students programming concepts
and skills and to improve their computational thinking.
we used the cont1 questionnaire to measure participants' knowledge of programming concepts (measures the con variable as explained in section 3.5). cont tests the participants' knowledge of
programming, sequence, memory & variables, input & output instructions, conditionals, and loops. the question formats are as follows: “what do you think a program is? can you give an example?“,
and seek to measure students' knowledge of those areas.
two tests were used to measure computational thinking. the first
test is called romt2 (measures the rom variable as explained in section 3.5). romt is a validated test with 28 items that measures the
computational thinking of children aged over 10 (román-gonzález,
pérez-gonzález, & jiménez-fernández, 2017). fig. 4 shows a sample
question in romt. questions are based on scratch code blocks and
cover certain ct areas.
given that romt cannot evaluate computational thinking in
children younger than 10, we also used a second validated test suitable
for those students. however, as far as we know, no test has been validated to measure ct in children younger than 10. therefore this study
proposed using a new test to measure ct created for children of this
age. it is called pcnt3 and measures the pcn variable as explained in
section 3.5. fig. 5 shows an example pcnt question.
pcnt has 14 exercises grouped into the categories outlined in
section 3.3.1 for the compthink app (2018), to cover the 3-d ct dimensions model created by brennan and resnick (2012) to assess
computational thinking. unplugged approaches use these types of exercises to develop ct (brackmann et al., 2016).
we debated whether to use pcnt exclusively for all students regardless of their age. however, we decided against that idea as romt is
a validated test, and we wanted to ensure that the results provided by
both tests could be correlated.
3.4. procedure
fig. 6 shows the experimental procedure. at the start of the experiment, all students took three tests:
• romt: a validated test for children to measure computational
thinking (román-gonzález et al., 2017).
• cont: a concept test created ad-hoc for the experiment.
• pcnt: a new test to measure ct based on the field's literature.
students from 4th to 6th grades in spanish primary education (aged
9–12) attended classes that taught programming through the mecoprog pedagogical method. certain students, who had chosen
programming as one of their optional school subjects, attended as part
of their schooling while the remaining students, who did not take
programming as a subject (as it is not compulsory in spain), were
grouped into a programming camp on saturdays. all of them used
scratch.
after 6 weeks/1 h per week in the private school and 3 2 h-sessions
in the camp, all students took those same three tests again. we had
previously decided to use the same tests again to guarantee that the
post-tests had the same level of difficulty as the pre-tests.
in order to avoid student boredom of taking the same tests again, we
waited a minimum of 3 weeks before asking them to take the post-test.
in addition, during the first test session we did not resolve any questions
they had from taking the pre-tests to avoid giving solutions to the posttest.
3.5. measures
the variables were the scores achieved by the students in the cont,
romt and pcnt tests. specifically, the following:
• con: students' knowledge test (cont) score
• rom: students' validated ct (romt) score
• pcnt: students' new ctt test score (pcnt)
3.6. data analysis
a comparative study using non-parametric tests to measure the
hypothesis contrast between the pre-post pcn, con and rom values
was performed. non-parametric tests were used because when the data
gathered was analysed, we saw that they had not come from a normal
distribution, and we did not have enough data to assume normality.
4. findings
4.1. overall results
table 6 shows the means, medians (more representative than the
mean in asymmetric distribution), and standard deviation for pre-test
and post-test of pcn, con and rom.
without making distinctions per grade, table 6 reveals a clear increase in the post-test results in the three variables, showing a greater
improvement in con variable, and a smaller improvement in rom
variable. standard deviation slightly increases in all the variables, except in pcn, where it is more reduced in the post-test.
fig. 7 shows box-plots for these three variables, both in the pre-test
and post-test. graphically, 50% of the central data are represented in
1 https://tinyurl.com/mecoprogct (in spanish). 2 https://tinyurl.com/mecoprogtrg (in spanish). 3 https://tinyurl.com/mecoprogctl (in spanish).
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
5
the box, and the median are marked with a line as representative
measure. the highest and lowest values for each box-plot correspond to
values which are not less than q1-1.5·(q3-q1) and not greater than
q3+1.5·(q3-q1). some outliers are marked with the case number.
after analysing the data using the shapiro-wilk test, we found that
the distribution of the variables under study did not come from a
normal distribution, except in post_con variable (p = 0.292) and
post_rom (p = 0.203). therefore, and without having a high enough
number of population, nonparametric tests were chosen for the study to
guarantee the robustness of the results.
spearman's rank correlation coefficient shows a significant correlation (p < 0.001) between pre and post-tests in pcn, con and rom
variables. the wilcoxon signed-rank test is used to compare two related
samples, in this case the pre and post-tests, and evaluate whether there
is any statistically-significant difference in the pre and post-tests in the
three variables studied.
table 7 shows a significant improvement for all tests. the rom pvalue is much higher than the others. therefore, con variable is the
most significant. consequently, we could conclude that the population
saw a significant improvement in the tests.
some additional information to size the effect is the r value, introduced by rosenthal in 1991. pcn had a value of r = 0.15 corresponding to a small effect, r = 0.55 for con variable, corresponding to
a large effect, and, finally, r = 0.16 for rom variable, indicating a small
effect.
4.2. results per grades
first, a descriptive analysis for each variable in the three grades is
presented. tables 8–10 show the median, mean and standard deviation.
con variable shows a large increase for all grades, in addition to
increasing data dispersion (see table 9). in rom variable, 5th and 6th
show an increase for the median, as well as the standard deviation. boxfig. 3. compthink app (2018), an example of the games for each of the seven options available.
table 5
concept dimension covered of 3-d ct dimensions model by compthink app.
compthink app brennan and resnick concept dimension on ct
loops loops and data
algorithms sequences
pattern sequences and data
conditionals conditionals
steps sequences and operators
instructions sequences
automats sequences and conditionals
fig. 4. an example of a romt question (“what instructions can you give pacman to reach the ghost?” choose from: a, b, c or d).
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
6
plots confirm this statement (see table 10). pcn variable shows a large
increase in 5th grade, followed by 6th grade. standard deviation is
reduced. no improvement is observed for 4th grade students (see
table 8).
box-plots confirm this reasoning and show the existence of several
outliers related to low marks for the three grades, especially in 4th
grade.
again, spearman's rank correlation coefficient shows a significant
correlation (p < 0.001) between pre and post-tests in pcn and con in
all the grades, and in 5th and 6th grades in rom. the wilcoxon signedrank test is used to compare two related samples, in this case pre and
post-test, and evaluate whether there is any statistically significant
difference in pre- and post-tests in the three variables studied for each
grade.
table 11 shows significant differences in different grades: there is a
significant improvement in pcnt variable in 5th (p = 0.008), as well as
romt variable, although with a higher p-value (p = 0.023). in the case
of con variable, the improvement is significant in all grades
(p = 0.000).
rosenthal r value quantifies the improvement where it happens. in
4th grade, a large improvement, close to very large, is observed in con
variable (r = 0.62). in 5th grade, there is a small increase, near to a
fig. 5. example of a pcnt question (“do you know what steps you need to take
to plant a tree? place the following four actions into order: 1) take a shovel, 2)
water the tree, 3) plant the tree, 4) dig a hole”).
fig. 6. flow diagram of the experiment.
table 6
median, mean and standard deviation in pre- and post-tests pcn, con and
rom.
pcn con rom
mdn m sd mdn m sd mdn m sd
pre 8.57 8.37 1.25 2.69 2.77 1.32 4.28 4.23 1.36
post 9.28 8.99 1.05 5 5.08 1.59 4.64 4.77 1.56
fig. 7. box-plot for variables pcn, con and rom in pre and post-test.
table 7
comparative study using wilcoxon test.
pcn con rom
z −2.830 −8.543 −2.294
p-value 0.005 0.000 0.022
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
7
medium increase in pcn variable (r = 0.27). a large increase occurs in
the con variable (r = 0.57) and a small increase in the rom variable
(r = 0.23). finally, in 6th grade, a large effect is found, with r = 0.55.
4.3. synopsys table
table 12 gathers the increase of the scores in the three tests taken by
the students before and after mecoprog.
finally, in response to our question regarding the relationship between pcnt and romt, there is a low lineal correlation between them
(spearman r = 0,248 p < 0.01).
5. discussion
this paper explored whether primary education students' ct can be
improved and, to what extent primary education students are able to
learn programming concepts. it included factors such as grade and used
tests to measure children's’ knowledge and computational thinking.
one important conclusion is that there is a statistic significant increase in children's post-test results both in knowledge (according to the
cont knowledge test), and ct values for all grades (according to pcnt
and romt ct tests). this suggests that even in a short period of time it
is possible to teach children basic computer programming concepts
such as memory, programming, conditionals or loops, and improve
their ct, with children as young as nine.
it is worth noting that although there is a general consensus regarding the need to foster children's ct (román-gonzález, 2015), and
the results reported in this study significantly contribute to the literature in this sens, there is still much controversy surrounding the definition of the term ct and how and when to integrate it into the curriculum (gouws, bradshaw, & wentworth, 2013).
since this study required a practical definition of what comprises ct
in order to work with children and anaylse what parts of ct could be
improved and how, we chose the 3d ct model (brennan & resnick,
2012; see table 1). the reason for selecting that model was that it had
been created by the authors of scratch, a program that allows children
to program.
as noted by vico (2017) (translated from spanish); “a child who
does not learn how to program will have the same handicap as a
spanish child who is not able to understand english”. this is also why
we wanted to foster an interest in ct, so that children can become
programmers. otherwise, it seems as though we have only taught our
pre-school children to read, but not how to write.
however, some computer science educators have argued that programming is not necessary to teach computational thinking (lu &
fletcher, 2009; yadav, zhou, mayfield, hambrusch, & korb, 2011).
some have even suggested that teaching programming to foster ct
could deter students as some may find computer science and programming boring (lu & fletcher, 2009).
in light of our results, and from our experience with children age 9
to 12, learning how to program is engaging and helps them focus on
problems. all children payed attention during the lessons regardless of
their grade. in general, it is well known that children love computers
and do not think that they are difficult or boring to use. this could be
used as a base to start working with children, who are naturally fascinated by technology.
this study is particularly relevant for teachers and national curriculums as it shows that children can enjoy learning about programming. until recently, it was unconceivable to think children could learn
about programming. on the contrary, children were not taught these
concepts until secondary school, or even university, at an age that
students begin to find these complex ideas difficult to understand, in
contrast to younger children, who can easily absorb them when adapted
to their age.
it has also become evident that teachers need guidance in their
approach to this task. according to this study, students are able to learn
programming concepts if they are taught with methodologies such as
mecoprog with scratch and those that use metaphors. teachers must
be trained in those methodologies if we want to reach primary
table 8
median, mean and standard deviation for pre-test and post-test for pcn, per
grades.
pcn
4th 5th 6th
mdn m sd mdn m sd mdn m sd
pre 9.28 8.60 1.42 7.85 8.26 1.12 8.57 8.45 1.34
post 9.28 8.75 1.68 9.28 9.03 1.01 9.28 8.95 1.09
table 9
median, mean and standard deviation for pre-test and post-test for con, per
grades.
con
4th 5th 6th
mdn m sd mdn m sd mdn m sd
pre 2.69 2.50 1.01 2.31 2.74 1.67 2.69 2.80 0.99
post 5.19 5.09 1.28 4.80 5.01 1.68 5.19 5.14 1.54
table 10
median, mean and standard deviation for pre-test and post-test for rom per
grade.
rom
5th 6th
mdn m sd mdn m sd
pre 4.28 4.43 1.54 4.11 4.08 1.21
post 5.00 5.17 1.71 4.64 4.46 1.38
table 11
comparative study using wilcoxon test.
pcn con rom
4th 5th 6th 4th 5th 6th 5th 6th
z −0.515 −2.674 −1.362 −4.204 −4.845 −5.715 −2.274 −0.928
p-value 0.607 0.008 0.173 0.000 0.000 0.000 0.023 0.354
table 12
rosenthal r to quantify the improvement detected in the three tests.
n dpcn dcon drom
4th 23 – 0.62 –
5th 38 0.27 0.51 0.23
6th 50 – 0.55 –
all 85 0.15 0.55 0.16
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
8
education students. therefore, and in line with the digital competence
that teachers should develop, we should include this training in their
pedagogical education (intef, 2017).
measuring the progress of ct is also necessary. the tests used for
this could differ depending on the definition of ct and the age of the
students. for instance, the test created by korkmaz, çakir, and özden
(2017) is limited to the sub-skills comprising the iste (2015) definition.
in addition, it is limited to associate students and older students.
only one validated test was found to measure ct according to the
3d ct model and to be useful for young children. the authors of this
test kindly allowed us to use it (román-gonzález et al., 2017) for this
study. however, the test (romt) is only validated for children older
than 10. for younger students, we tried a new test (pcnt), as explained
above, which was also in line with the published 3d ct model.
the results gathered both from romt and pnct proved that ct can
be improved by using mecoprog. however, given the low correlation
found between pcnt and romt, more studies should be carried out
focusing on how to assess ct for young students, particularly those
aged under 9.
5.1. limitations and future work
we are aware that these measures would change if we use a different ct definition, and that the results may change if we use a different model, and/or a different computer program other than scratch.
furthermore, mecoprog can be used with different resources, and
may thus produce different results in each case. the core metaphors
used in this paper are based on cooking. different metaphors can be
used such as car metaphors: the door as input/output for the car,
junctions for conditionals, roundabouts for loops and so on. during
class, teachers are able to select the most adequate metaphor from
mecoprog, as published (pérez-marín et al., 2018).
the experiment has been described in great detail so that other
researchers are interested in repeating it with a different sample or to
test more advanced programming concepts, can do so easily. this study
experiment focused on basic introductory computer programming
concepts because it was the first contact with those particular students
and the project only had a limited amount of time.
the authors are currently also carrying out a multifactorial study to
determine whether other factors such as sex, motivation or effort might
have an impact on students' ct test scores. we would also like to
continue with the validation of pcnt, given the low correlation found
between pcnt and romt.
6. conclusions
the findings of this longitudinal pre- and post-test quasi-experiment
carried out with 132 primary education students (aged 9 to 12) positively confirmed the formulated research question: can computational
thinking be improved using a methodology based on metaphors and
using scratch to teach computer programming to children?
table 12 gathers the main results of the research study. here, both
the knowledge programming concept test and the ct tests (romt and
pcnt) found better post-test scores, when data were analysed for all the
grades. these results suggest that using metaphors and scratch is useful
for teaching computer programming concepts to primary education
students, and for improving students' ct, providing a positive answer to
the research question. it contributes to the area of study exploring how
to develop computational thinking by covering gaps in methodologies,
and uses, for the first time, metaphors to teach basic programming
concepts to primary education students, together with scratch.
when the analysis is carried out per grade, it shows that 4th grade
students can understand programming concepts. in fact, it seems to
show that these students are actually able to learn more about programming concepts, as their increase in cont knowledge improves
more than any other group. because we could not apply the romt test
to them as they were aged younger than 10, no conclusion could be
drawn from this test. when the results of the pcnt are analysed, no
significant results could be drawn either, indicating the need for more
studies to quantify the increase (if any) of the development of ct in
students aged younger than 10 when they learn programming concepts.
we cannot end without highlighting the fact that 5th grade students
improved their performance in all tests. not only did they learn more
programming concepts through mecoprog, but their scores in both
ct-measuring tests increased significantly. finally, 6th and 4th grade
students' knowledge of programming improved, but no significant improvement was found in romt or pcnt scores. this may indicate either that these students need more time to improve their ct, or that the
mecoprog metaphors methodology is more applicable to students
aged 10–11.
acknowledgments
research funded by the projects tin 2015-66731-c2-1-r and
s2013/ice-2715.
references
aho, a. v. (2012). computation and computational thinking. the computer journal, 55(7),
832–835.
balanskat, a., & engelhardt, k. (2015). computing our future. computer programming and
coding priorities, school curricula and initiatives across europe. brussels, belgium:
european schoolnet2015.
barker, l. j., mcdowell, c., & kalahar, k. (2009). exploring factors that influence computer science introductory course students to persist in the major. acm sigcse
bulletin: vol. 41, (pp. 153–157). acm no. 1.
bers, m. u. (2010). the tangiblek robotics program: applied computational thinking for
young children. early childhood research & practice, 12(2), 2.
bers, m. u., ponte, i., juelich, c., viera, a., & schenker, j. (2002). teachers as designers:
integrating robotics in early childhood education. information technology in childhood
education annual, 1(1), 123–145.
bers, m., rogers, c., beals, l., portsmore, m., staszowski, k., cejka, e., et al. (2006).
innovative session: early childhood robotics for learning. proceedings of iste, c.
2011. computational thinking in k–12 education leadership toolkit.
boero, p., bazzini, l., & garuti, r. (2001). metaphors in teaching and learning mathematics: a case study concerning inequalities. pme conference: vol. 2, (pp. 2–185).
brackmann, c., barone, d., casali, a., boucinha, r., & muñoz-hernández, s. (2016).
computational thinking: panorama of the americas. computers in education (siie),
international symposium on iee (pp. 1–6). .
brennan, k., balch, c., & chung, m. (2014). creative computing. cambridge [masachussets].
harvard graduate school of educationhttp://scratched.gse.harvard.edu/guide/files/
creativecomputing20141015.pdf [consulta: 30/05/2017].
brennan, k., & resnick, m. (2012). new frameworks for studying and assessing the development of computational thinking. proceedings of the annual meeting of the
american educational research association, vancouver, canada (pp. 1–25). .
campe, s., & denner, j. (2015). programming games for learning: a research synthesis.
paper presented at the annual meeting of the american educational research association,
chicago, il.
cook, t. d., & campbell, d. t. (1986). the causal assumptions of quasi-experimental
practice. synthese, 68(1), 141–180.
compthink app (2018). http://www.lite.etsii.urjc.es/tools/compthink-app/.
coull, n. j., & duncan, i. m. (2011). emergent requirements for supporting introductory
programming. innovation in teaching and learning in information and computer
sciences, 10(1), 78–85.
csta, & iste (2011). operational definition of computational thinking for k–12 education.
retrieved from http://csta.acm.org/curriculum/sub/currfiles/compthinkingflyer.
pdf.
cuny, j., snyder, l., & wing, j. m. (2010). demystifying computational thinking for noncomputer scientists. unpublished manuscript in progress, [on line]. available: referenced in http://www.cs.cmu.edu/∼compthink/resources/thelinkwing.pdf.
denning, p. j. (2009). the profession of it. beyond computational thinking.
communications of the acm, 52(8), 28–30.
espino, e., soledad, c., & gonzález, c. (2015). estudio sobre diferencias de género en las
competencias y las estrategias educativas para el desarrollo del pensamiento computacional. revista de educación a distancia, 46.
furber, s. (2012). shut down or restart: the way forward for computing in uk schools. [on
line]. available: retrieved from http://royalsociety.org/education/policy/
computing-in-schools/report/.
garcía-peñalvo, f. j. (2016). a brief introduction to taccle 3—coding european project.
computers in education (siie), international symposium on ieee (pp. 1–4). .
ginat, d. (2004). on novice loop boundaries and range conceptions. computer science
education, 14(3), 165–181.
google for education (2018). exploring computational thinking. retrieved from https://
www.google.com/edu/resources/programs/exploring-computational-thinking/.
gouws, l. a., bradshaw, k., & wentworth, p. (2013). computational thinking in
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
9
educational activities: an evaluation of the educational game light-bot. proceedings of
the 18th acm conference on innovation and technology in computer science education (pp.
10–15). .
grover, s., & pea, r. (2013). computational thinking in k–12. a review of the state of the
field. educational researcher, 42(1), 38–43.
heintz, f., mannila, l., & färnqvist, t. (2016). a review of models for introducing
computational thinking, computer science and computing in k-12 education. frontiers
in education conference (fie), 2016 (pp. 1–9). ieee.
intef (2017). marco común de competencia digital docente. https://intef.es/blog/marcocomun-de-competencia-digital-docente-septiembre-2017/.
iste (2015). ct leadership toolkit. available at: https://www.iste.org/docs/ctdocuments/
ct-leadershipt-toolkit.pdf%3fsfvrsn%bc;4.
jiménez-peris, r., pareja-flores, c., patiño-martínez, m., & velázquez-iturbide, j.á.
(1997). the locker metaphor to teach dynamic memory. acm sigcse bulletin: vol.
29, (pp. 169–173). acm no. 1.
jovanov, m., stankov, e., mihova, m., ristov, s., & gusev, m. (2016). computing as a new
compulsory subject in the macedonian primary schools curriculum. global engineering
education conference (educon), 2016 ieee (pp. 680–685). ieee.
kalelioğlu, f. (2015). a new way of teaching programming skills to k-12 students: code.
org. computers in human behavior, 52, 200–210.
kazakoff, e. r., sullivan, a., & bers, m. u. (2013). the effect of a classroom-based intensive robotics and programming workshop on sequencing ability in early childhood. early childhood education, 41, 245–255.
korkmaz, ö., çakir, r., & özden, m. y. (2017). a validity and reliability study of the
computational thinking scales (cts). computers in human behavior, 72, 558–569.
lahtinen, e., ala-mutka, k., & järvinen, h. m. (2005). a study of the difficulties of novice
programmers. acm sigcse bulletin: vol. 37, (pp. 14–18). no. 3.
lakoff, g., & johnson, m. (2008). metaphors we live by. university of chicago press.
lee, e., kafai, y. b., vasudevan, v., & davis, r. l. (2014). playing in the arcade: designing
tangible interfaces with makey makey for scratch games. playful user interfaces (pp.
277–292). springer singapore.
lee, i., martin, f., denner, j., coulter, b., allan, w., erickson, j., & werner, l. (2011).
computational thinking for youth in practice. acm inroads, 2(1), 32–37.
lu, j. j., & fletcher, g. h. (2009). thinking about computational thinking. acm sigcse
bulletings, 41(1), 260e264.
margulieux, l. e., catrambone, r., & guzdial, m. (2016). employing subgoals in computer programming education. computer science education, 26(1), 44–67. https://doi.
org/10.1080/08993408.2016.1144429.
special issue ii on computer science education in k-12 schools. r. mccartney (ed.).
transactions on computing education, acm, 14, 2.
special issue on computing education in (k-12) schools. transactions on computing
education. r. mccartney, & j. tenenberg (eds.). acm, 14, 2.
milner, w. w. (2010). a broken metaphor in java. acm sigcse bulletings, 41(4), 76–77.
ouahbi, i., kaddari, f., darhmaoui, h., elachqar, a., & lahmine, s. (2015). learning basic
programming concepts by creating games with scratch programming environment.
procedia-social and behavioral sciences, 191, 1479–1482.
papadakis, s., kalogiannakis, m., & zaranis, n. (2016). developing fundamental programming concepts and computational thinking with scratchjr in preschool education: a case study. international journal of mobile learning and organisation, 10(3),
187–202.
papert, s. (1980). mindstorms: children, computers, and powerful ideas. new york, ny:
basic books.
paris, n. a., & glynn, s. m. (2004). elaborate analogies in science text: tools for enhancing preservice teachers' knowledge and attitudes. contemporary educational
psychology, 29(3), 230–247.
pea, r. d., & kurland, d. m. (1984). on the cognitive effects of learning computer programming. new ideas in psychology, 2(2), 137–168.
pérez-marín, d., hijón-neira, r., & martín-lope, m. (2018). a methodology proposal
based on metaphors to teach programming to children. ieee revista iberoamericana de
tecnologías del aprendizaje, 13(1), 46–53.
putnam, r. t., sleeman, d., baxter, j. a., & kuspa, l. k. (1986). a summary of misconceptions of high school basic programmers. journal of educational computing
research, 2(4), 459–472.
resnick, m. (1996). new paradigms for computing, new paradigms for thinking. in y.
inkafai, & m. resnick (eds.). constructionism in practice: designing, thinking, and
learning in a digital world. mahwah, nj: erlbaum.
resnick, m., maloney, j., monroy-hernandez, a., rusk, n., eastmond, e., brennan, k.,
et al. (2009). scratch: programming for all. communications of the acm, 52(11),
60–67.
rodríguez diéguez, j. l. (1988). las metáforas en la enseñanza. enseñanza & teaching.
revista interuniversitaria de didáctica (pp. 223–240). universidad de salamanca 6.
román-gonzález, m. (2015). computational thinking test: design guidelines and content
validation. proceedings of edulearn15 conference (pp. 2436–2444). .
román-gonzález, m., pérez-gonzález, j. c., & jiménez-fernández, c. (2017). which
cognitive abilities underlie computational thinking? criterion validity of the computational thinking test. computers in human behavior, 72, 678–691. https://doi.org/
10.1016/j.chb.2016.08.047.
rosenthal, r. (1991). meta-analytic procedures for social research (2nd ed.). newbury park,
ca: sage.
sanford, j. p., tietz, a., farooq, s., guyer, s., & shapiro, r. b. (2014). metaphors we teach
by. proceedings of the 45th acm technical symposium on computer science education (pp.
585–590). acm.
seoane-pardo, a. m. (2018). computational thinking between philosophy and stem.
programming decision making applied to the behaviour of “moral machines” in ethical
values classroomieee-ritahttps://doi.org/10.1109/rita.2018.2809940.
seppälä, o., malmi, l., & korhonen, a. (2006). “observations on student misconceptions—a case study of the build–heap algorithm”. computer science education,
16(3), 241–255.
sović, a., jagušt, t., & seršić, d. (2014). how to teach basic university-level programming concepts to first graders? integrated stem education conference (isec), 2014
ieee (pp. 1–6). ieee.
strawhacker, a., portelance, d., lee, m., & bers, m. (2015). designing tools for developing
minds: the role of child development in educational technology. idc 2015 workshop.
available on-line at: http://everychildacoder.org.uk/wp-content/uploads/2015/05/
strawhacker_et_al_final.pdf last visit: november 23rd, 2017 .
thomas, g. p., & mcrobbie, c. j. (2001). using a metaphor for learning to improve
students' metacognition in the chemistry classroom. journal of research in science
teaching, 38(2), 222–259.
vico, f. (2017). el niño que no programe tendrá un hándicap como hoy lo tiene el que no
entiende inglés. entrevistas educación 3.0. https://www.educaciontrespuntocero.com/
entrevistas/francisco-j-vico-programacion/59063.html.
wing, j. m. (2006a). computational thinking. communications of the acm, 49(3), 33–35.
wing, j. m. (2006b). computational thinking. communications of the acm, 49(3), 33–35.
wing, j. (2008). computational thinking and thinking about computing. philosophical
transactions of the royal society of mathematical physical and engineering sciences, 366,
3717–3725.
wing, j. (2011). research notebook: computational thinking— what and why. [on line].
available: the link magazine, springpittsburgh: carnegie mellon university. retrieved
from http://link.cs.cmu.edu/article.php?a=600.
wing, j. m. (2016). computational thinking, 10 years later. http://www.microsoft.com/enus/research/blog/computational-thinking-10-years-later.
yadav, a., gretter, s., hambrusch, s., & sands, p. (2016). expanding computer science
education in schools: understanding teacher experiences and challenges. computer
science education, 1–20.
yadav, a., zhou, n., mayfield, c., hambrusch, s., & korb, j. t. (2011). introducing
computational thinking in education courses. proceedings of acm special interest group
on computer science education, dallas, tx.
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
10"
"contents lists available at sciencedirect
computers in human behavior
journal homepage: www.elsevier.com/locate/comphumbeh
full length article
can computational thinking be improved by using a methodology based on
metaphors and scratch to teach computer programming to children?
diana pérez-marína,∗
, raquel hijón-neiraa
, adrián baceloa
, celeste pizarrob
a rey juan carlos university, computer science department, móstoles, madrid, spain
b rey juan carlos university, applied mathematics department, móstoles, madrid, spain
article info
keywords:
computational thinking
primary education
programming
methodology
metaphor
abstract
computational thinking (ct) is a key skill in the 21st century. however, it is not clear which is the most effective
way to acquire and improve ct. big research efforts are made to determine which pedagogical means should be
used. one research trend is based on the idea that teaching programming since primary education suffices to
improve ct. in our previous work, we proposed and validated a methodology based on metaphors and used of
scratch (mecoprog) to teach basic programming concepts to children. it is our hypothesis h that by applying
mecoprog, students will develop their ct. to check h, we carried out an experiment with 132 primary
education students (9–12 years in age). at the beginning of the experiment, all students were asked to fill in a
programming concepts test and two tests to measure their ct. during the sessions, all students were taught
according to mecoprog. finally, they took the three tests again. a significant increase in the results on all the
tests has been measured, supporting the use of metaphors and scratch to teach computer programming concepts
to primary education students to develop their ct.
1. introduction
computational thinking (ct) can be defined as the skill of solving
problems, designing systems, and understanding human behavior based
on computer science concepts (wing, 2006). ct is a key skill for children in the 21st century (wing, 2016). however, it is unclear how ct
can be developed in the most effective way in children. currently,
different pedagogical methodologies that can be used to develop ct are
being researched.
in the last years, some authors have claimed that ct can be acquired
and developed by teaching programming to children. in addition, it has
been claimed that this should be done as early as possible (heintz,
mannila, & färnqvist, 2016; kazakoff, sullivan, & bers, 2013;
mccartney, 2015; mccartney & tenenberg, 2014; papadakis,
kalogiannakis, & zaranis, 2016; strawhacker, portelance, lee, & bers,
2015).
it is possible that ct can be acquired by other means such as
educational robotics (bers et al., 2010), storytelling (lee et al., 2011),
unplugged activities (brackmann, barone, casali, boucinha, & muñozhernández, 2016), scratch jr (papadakis et al., 2016) or even in ethics
lessons (seoane-pardo, 2018). although this paper focuses on programming to foster ct, learning how to program is worthwhile not only
for that reason, but also because of the real need for programmers in
our digital society (margulieux, catrambone, & guzdial, 2016), as well
as other advantages such as the improvement of higher cognitive skills
(pea & kurland, 1984).
many countries implemented computer science as a subject in
primary education to train students into creators of computer programs
(heintz et al., 2016). a common approach to teaching computer science to children is scratch, defined as an authoring environment - developed by the lifelong kindergarten research group at the mit media
lab - to design interactive media by snapping together programminginstruction blocks (resnick et al., 2009; ouahbi, kaddari, darhmaoui,
elachqar, & lahmine, 2015). other approaches focus on using makey
makey, where students can interact with the computer by means of
fruits or play-doh rather than using the traditional mouse (lee, kafai,
vasudevan, & davis, 2014); using lego wedo or mindstorms ev3 robots (sović, jagušt, & seršić, 2014), and (producing) making games
(campe & denner, 2015). another possibility is to follow unplugged
approaches using storytelling or free exercises from code.org. this is
particularly useful in countries with limited resources, but also in developed countries, where computer science is considered interesting,
but there is a lack of trained teachers and/or resources (brackmann
et al., 2016).
the results of these approaches have not yet been properly evaluated, and their effectiveness is still unclear (kalelioğlu, 2015).
https://doi.org/10.1016/j.chb.2018.12.027
received 28 december 2017; received in revised form 6 august 2018; accepted 16 december 2018
∗ corresponding author.
e-mail address: diana.perez@urjc.es (d. pérez-marín).
computers in human behavior xxx (xxxx) xxxx
0747-5632/ © 2018 elsevier ltd. all rights reserved.
please cite this article as: diana pérez-marín, et al., computers in human behavior, https://doi.org/10.1016/j.chb.2018.12.027
moreover, no methodology or particular resources have been identified
as the most adequate to teach programming to children.
there are difficulties in teaching children even basic concepts such
as program construction (lahtinen, ala-mutka, & järvinen, 2005),
loops (ginat, 2004), structures control, and algorithms (seppälä,
malmi, & korhonen, 2006). these difficulties arise because of poor
teacher training or a lack of a proper teaching methodology (barker,
mcdowell, & kalahar, 2009; coull & duncan, 2011). it has become
evident that teachers need guidance to approach this task adequately
(brackmann et al., 2016; jovanov, stankov, mihova, ristov, & gusev,
2016; yadav, gretter, hambrusch, & sands, 2016).
in our previous work, we proposed and validated the use of metaphors to introduce children to basic concepts of programming according
to the methodology mecoprog (pérez-marín et al., 2018). for instance, we proposed using the metaphors of a thermomix® recipe as a
program (and sequence), pantry as memory, and boxes as variables. we
also illustrated the possibility of applying these metaphors to any resource available to the teacher, such as scratch.
the reason for using metaphors is the widely reported usefulness of
metaphors as powerful educational tools. metaphors focus on concepts
and facilitate students' organization of ideas and clearer, more
straightforward thinking (rodríguez diéguez, 1988). using metaphors
does not require special equipment and helps teachers turn abstract
concepts into simple ideas and images. students need clear and careful,
well-focused thinking to correctly write computer programs (heintz
et al., 2016).
this research paper asks the following question: can computational
thinking be improved by using a methodology based on metaphors and
scratch to teach computer programming to children? it is our hypothesis (h) that the answer is yes. for this study, we asked 132 primary
education students (aged 9 to 12) to follow mecoprog for six weeks.
there were two objectives: 1) to teach students the basic concepts of
computer science programming; and, 2) to develop students' ct by
teaching them those concepts using metaphors and scratch. the results
derived from this study show that using metaphors and scratch can
significantly develop students' ct, but also that students are able to
learn basic programming concepts.
the paper is organised as follows: section 2 reviews background
literature on computational thinking and teaching programming in
primary education; section 3 outlines the materials and methods of the
experiment carried out so that this study can be reproduced elsewhere;
section 4 presents the results of the experiment; and section 5, summarises the main conclusions and suggests future lines of work.
2. background
computational thinking (ct) is not a new term. it dates back to
1950s, when it was referred to as “algorithmic thinking”. it was defined
as a way to use algorithms to produce appropriate output to a given
input (denning, 2009). in 2006, wing relaunched interest in the topic
and defined ct as follows: “it involves solving problems, designing
systems, and understanding human behavior, by drawing on the concepts fundamental to computer science” (wing, 2006). given the generic nature of that definition, there has recently been several unsuccessful attempts to make it more specific (aho, 2012; brennan &
resnick, 2012; csta & iste, 2011; google for education, 2018; wing,
2008).
according to grover and pea (2013), ct includes decomposition,
pattern generalisations and location, abstraction and algorithms among
other computer science resources such as debugging and systematic
error detection, iterative, parallel and recursive thinking, control flow
and use of symbols.
brennan, balch, and chung (2014) also explored ct in terms of
programming, more specifically using scratch based on a 3-d ct classification into concepts, practices, and computational perspectives
(brennan & resnick, 2012). see table 1.
the goal is not to replace creative and critical thinking or other
competences, but to add the skill of using computers and algorithms to
solve problems (cuny, snyder, & wing, 2010; wing, 2011; csta &
iste, 2011; furber, 2012; espino, soledad, & gonzález, 2015). many
governments emphasise the need for children to be fluent in the digital
language rather than making them mere users of computer software
(garcía-peñalvo, 2016). there are already certain resources available in
the specialised literature for this (balanskat & engelhardt, 2015; wing,
2008).
learning how to program can induce changes in the way that people
think (papert, 1980; resnick, 1996). this is likely because of the analytical component of ct, which is quite similar to mathematical
thinking (i.e. problem solving), engineering thinking (design and evaluation of processes) and scientific thinking (systematic analysis).
ct can be useful not only for students or professionals of computer
science, but for any other person (wing, 2006). starting ct training as
early as possible is of particular interest, and it has been shown that
children aged as young as four can understand programming concepts
and even build simple robots which can move and interact with the
environment (bers, ponte, juelich, viera, & schenker, 2002; bers et al.,
2006).
this is why teaching computer science programming has been included in the primary education curricular in many countries (heintz
et al., 2016; see table 2). a commonly used approach to teach computer science to children is using scratch (resnick et al., 2009). while
interacting with scratch, students learn basic concepts such as sequences, loops, parallelism, events, conditionals, operators and data
(brennan & resnick, 2012; ouahbi et al., 2015).
other approaches include making an own program (campe &
denner, 2015), using lego wedo or mindstorms ev3 robots (sović
et al., 2014). with regard to unplugged approaches: these are common
in countries with limited resources, but also in developed countries,
which consider computer science an interesting option but lack trained
teachers and/or internet connections (brackmann et al., 2016).
in unplugged approaches, the concepts of computer science are
transmitted through storytelling or free exercises available on code.org.
it bears mentioning here that there is no established method to evaluate
the effectiveness of these approaches; therefore, their validity is still
unclear (kalelioğlu, 2015).
a previous study by pérez-marín et al. (2018) contributed to the
debate by introducing metaphors as an alternative approach to teaching
programming. metaphorical language is employed in real, everyday
life, and is considered a crucial component of thinking (lakoff &
johnson, 2008). in particular, conceptual metaphors (i.e., cognitive
mechanisms that project from a source domain to a target domain in
order to facilitate understanding of a concept in the target domain) are
of great interest in educational environments (sanford, tietz, farooq,
guyer, & shapiro, 2014).
metaphors have been used to teach biology (paris & glynn, 2004),
chemistry (thomas & mcrobbie, 2001), and mathematics (boero,
bazzini, & garuti, 2001). the use of metaphors to teach computer
science is common at college level and has been the subject of research
interest (putnam, sleeman, baxter, & kuspa, 1986; sanford et al.,
table 1
summary table of the 3-d ct dimensions model (source: brennan & resnick,
2012).
• concepts:
− sequences
− loops
− parallelism
− events
− conditionals
− operators
− data
• practices:
− incremental & iterative development
− test & debugging
− mix & reuse
− abstract & encapsulate
• perspectives:
− to express
− to connect
− to question
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
2
2014). there are studies on specific metaphors, such as the locker
memory to teach dynamic memory (jiménez-peris, pareja-flores,
patiño-martínez, & velázquez-iturbide, 1997), or matrixes for eventhandling in java (milner, 2010). however, the use of metaphorical
language as a tool to teach basic concepts of computer science for
primary education, and the minimum age at which it can be used, have
not yet been researched in detail. therefore, we proposed and validated
a methodology called mecoprog (see description in section 3) to
teach programming to primary education students, using metaphors.
the purpose of the experiment described in this paper is to analyse
whether mecoprog has an impact on the students' programming
knowledge and whether it can improve computational thinking in
students.
3. method
3.1. participants
132 spanish primary education students (56.1% male and 43.9%
femal, aged 9 to 12), recruited in two parts, were asked to take part in
the experiment in order to assess whether their computational thinking
(ct) improved after teaching programming using the mecoprog
methodology based on metaphors.
the reason for having two different parts is that programming is not
compulsory in spanish schools. therefore, only a few students, usually
in private schools, have the opportunity to attend programming lessons.
we asked several private schools that offered programming to collaborate in the study; one school agreed because their programming
teacher was on sick leave and they required a skilled temporary teacher
for 4th, 5th and 6th grades. we were given permission to teach using
the mecoprog method during the six weeks the teacher needed to
convalesce.
in addition, and in order to provide other children with the opportunity to attend programming classes and to ensure a more heterogeneous sample, we offered other schools in madrid and the city
council of fuenlabrada (where the authors live) a cost-free programming camp to be held on three consecutive saturdays, which children
aged 10 to 12 could attend. this camp also used the mecoprog
methodology.
50% of our participants attended private schools and the rest attended 32 different public schools and were recruited as they participated in the programming camp. fig. 1 shows the distribution of the
students per grade (in spain, 4th grade corresponds to students aged
9–10, 5th grade corresponds to students aged 10–11, and 6th grade
corresponds to students aged 11–12). 18.2% were 4th grade students,
38.6% were 5th grade students, and 45.2% were 6th grade students.
3.2. design
the research model followed a longitudinal pretest-posttest quasiexperimental design, because the head-master of the private school did
not provide a control group and we could not randomly assign students
to each group.
similarly, we could not have a control group in the programming
camp or randomly assign students to each group, because one of the
city council's conditions to providing us with a class-room was that all
students must receive the same teaching. moreover, as rooms were only
available from 10:00 a.m. to 2:00 p.m., we had to divide students; thus,
students in the 5th grade attended from 10:00 a.m. to midday, whereas
those in the 6th grade attended from midday to 2:00 p.m. it was not
possible to recruit 4th grade students from the city council.
according to cook & campbell (1986), we could measure the impact of our intervention using mecoprog by following the quasi-experimental design outlined below. no rewards were offered.
3.3. materials
3.3.1. mecoprog
our main resource was mecoprog (pérez-marín et al., 2018).
table 3 summarises the metaphors used in mecoprog grouped into
three blocks: 1 – program, sequence, variable and input and output
instructions, 2 - conditional instructions and 3 - loops.
the process for each block was (1) introduce the concept by using
metaphors, and then (2), practice with scratch. see fig. 2 for a global
overview of mecoprog.
block 1 (2 h): first, the concept of programming was explained by
using the thermomix® (tx) cooking recipe metaphor. children were
explained that – just likewhen they are following steps in a tx recipe -
table 2
interest in teaching programming (based on heinz, mannila & färnqvist. et al., 2016).
country content form primary secondary
australia digital technologies own subject and integrated compulsory compulsory
england computing replaces existing subject compulsory
estonia programming integrated compulsory compulsory
finland programming integrated compulsory
new zealand programming and computer science own subject opcional
norway programming own subject opcional
sweden programming and digital competence integrated compulsory opcional
south korea informatics own subject compulsory opcional
finland computer science own subject compulsory compulsory
usa computer science own subject opcional
macedonia computers and basics of programing own subject compulsory
fig. 1. distribution of the participants in grades.
table 3
metaphors used in mecoprog for programming concepts.
block concept metaphor
1 program, sequence, memory
and variable
thermomix® (tx) recipe, pantry and box
input and output mouth and rectum (beginning and end of
the digestive system)
2 conditional intelligent fridge
3 loop hand mixer
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
3
the computer is able to execute the instructions of a program one step at
a time. no ambiguity is allowed as the computer does not understand
instructions that are not precise. additionally, just as the goal of following a recipe is to produce good food, a program always has a specific
output. the first program that they are asked to execute in scratch is to
say “hello!“.
scratch's “say” and “ask” instructions help to teach basic input/
output programming concepts. whenever students do not understand
them, the metaphor of input as eating something with their mouth, and
how their digestive system processes it until it passes through the
rectum (output) is used. that way, students understand that you can
enter data into the computer (input), execute a program and produce a
result (output).
the concept of sequence is also explained here, as the sentences in a
tx recipe/program must be executed one after another. students are
also asked whether they think that a computer has a memory.
surprisingly, not all students think they do. therefore, we help them
understand the concept of computer memory by using the pantry metaphor. the concept of data was explained by comparing the ingredients they need to carry out a tx recipe with the data a computer
needs to executes a program. moreover, the pantry metaphor can also
be used to explain the concept of variables as a boxes metaphor. just
like food is organised in the kitchen: eggs in their box, fruit in their
fruit-bowl, etc. so the computer organises data into boxes inside its
memory as variables. to illustrate the concept, we created the scratch
program shown in fig. 2 left.
block 2 (2 h): an intelligent fridge was used as a metaphor to explain conditionals. students were told that the fridge has a sensor to
detect how many pieces of food it contains. for instance, we told
children to imagine that they were in charge of serving dessert to their
family at dinner. an intelligent fridge would know how many family
members there are and thus how many pieces of fruit they would need.
if they were four family members, they would need at least four pieces
of fruit. if there were fewer than four pieces contained in the fridge, the
intelligent fridge will connect to internet to buy more fruit. to illustrate
the concept, we created the scratch program shown in fig. 2 center.
block 3 (2 h): for loops, a hand mixer metaphor was used. just like
a hand mixer repeats the same movement over and over again, a loop
repeats the same command over and over again until a condition is
fulfilled. students are told that the condition in the case of the hand
mixer is to whip the eggs five times. to illustrate the concept, we created the scratch program shown in fig. 2 right.
following the 3d ct model (see table 1) for concept dimensions
the methodology covers sequences, loops, conditionals, operators and
data (see table 4 left). mecoprog also covers the first three practices
of the practices dimension (see table 1). all students were encouraged
to revisit their programs and incrementally improve them as they learnt
new concepts. all the examples involved testing and debugging when
simple coding was reused and incorporated into more complex ones
(see table 4 top right).
in regard to the perspective dimension, the metaphor methodology
also allows questioning (giving solutions to a proposed guided methodology) and expressing (giving solution to a problem using the computer) (see table 4 right bottom).
fig. 2. overview of mecoprog blocks: up (first) concept (second) scratch. from left to right: sample script to work with input/output (block 1), sample script to
work with conditionals (block 2), sample script to work with loops (block 3).
table 4
concepts, practices and perspectives covered by mecoprog, highlighted in
underlined, in the 3d ct model proposed by brennan and resnick (2012).
•concepts:
− sequences
− loops
− parallelism
− events
− conditionals
− operators
− data
• practices:
− incremental & iterative development
− test & debugging
− mix & reuse
− abstract & encapsulate
• perspectives:
− to express
− to connect
− to question
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
4
during the experiment, cutting cross all three blocks, we occasionally used an application named compthink app in our sessions (2018),
developed ad-hoc for the improvement of children's computational
thinking. the app works with seven aspects, all focused on improving
the students' computational thinking (see fig. 3):
1 loops: students select an element and set the number of times that
the element will repeat the action. then, they can watch an animation of the action being repeated the selected number of times.
2 algorithms: students establish the order of a finite set of steps to
carry out a certain activity, such as cooking a recipe, or planting a
tree.
3 patterns: students choose the different features of a face out of a
variety of options to create a face. they choose between different
types of hair, eyes or mouths, and the outcome is an animated gif
with the selections they have made.
4 conditionals: students drag and drop images according to the options given in “if/else” branches. for instance: “if the weather is cold
(scarfs, coat and boots), else (t-shirts, bathing suit and shorts)“.
5 steps: students select which part is missing from several possibilities
in the picture. in fig. 3, for example, cream and a cherry is needed
to complete the cupcake.
6 instructions: students find the final position on a map, divided in
squares, after following a set of movement instructions.
7 automats: students select the correct order to follow a path from
one place to another with certain restrictions.
compthink app (compthink app, 2018) is a drag-and-drop visual
interface for android tablets or smartphones. table 1 shows the 3-d ct
dimensions model (brennan & resnick, 2012). table 5 presents the
concepts that each part of the app covers including those proposed by
brennan and resnick (op. cit.).
3.3.2. tests
three tests have been used to measure the impact of our intervention that used mecoprog to teach students programming concepts
and skills and to improve their computational thinking.
we used the cont1 questionnaire to measure participants' knowledge of programming concepts (measures the con variable as explained in section 3.5). cont tests the participants' knowledge of
programming, sequence, memory & variables, input & output instructions, conditionals, and loops. the question formats are as follows: “what do you think a program is? can you give an example?“,
and seek to measure students' knowledge of those areas.
two tests were used to measure computational thinking. the first
test is called romt2 (measures the rom variable as explained in section 3.5). romt is a validated test with 28 items that measures the
computational thinking of children aged over 10 (román-gonzález,
pérez-gonzález, & jiménez-fernández, 2017). fig. 4 shows a sample
question in romt. questions are based on scratch code blocks and
cover certain ct areas.
given that romt cannot evaluate computational thinking in
children younger than 10, we also used a second validated test suitable
for those students. however, as far as we know, no test has been validated to measure ct in children younger than 10. therefore this study
proposed using a new test to measure ct created for children of this
age. it is called pcnt3 and measures the pcn variable as explained in
section 3.5. fig. 5 shows an example pcnt question.
pcnt has 14 exercises grouped into the categories outlined in
section 3.3.1 for the compthink app (2018), to cover the 3-d ct dimensions model created by brennan and resnick (2012) to assess
computational thinking. unplugged approaches use these types of exercises to develop ct (brackmann et al., 2016).
we debated whether to use pcnt exclusively for all students regardless of their age. however, we decided against that idea as romt is
a validated test, and we wanted to ensure that the results provided by
both tests could be correlated.
3.4. procedure
fig. 6 shows the experimental procedure. at the start of the experiment, all students took three tests:
• romt: a validated test for children to measure computational
thinking (román-gonzález et al., 2017).
• cont: a concept test created ad-hoc for the experiment.
• pcnt: a new test to measure ct based on the field's literature.
students from 4th to 6th grades in spanish primary education (aged
9–12) attended classes that taught programming through the mecoprog pedagogical method. certain students, who had chosen
programming as one of their optional school subjects, attended as part
of their schooling while the remaining students, who did not take
programming as a subject (as it is not compulsory in spain), were
grouped into a programming camp on saturdays. all of them used
scratch.
after 6 weeks/1 h per week in the private school and 3 2 h-sessions
in the camp, all students took those same three tests again. we had
previously decided to use the same tests again to guarantee that the
post-tests had the same level of difficulty as the pre-tests.
in order to avoid student boredom of taking the same tests again, we
waited a minimum of 3 weeks before asking them to take the post-test.
in addition, during the first test session we did not resolve any questions
they had from taking the pre-tests to avoid giving solutions to the posttest.
3.5. measures
the variables were the scores achieved by the students in the cont,
romt and pcnt tests. specifically, the following:
• con: students' knowledge test (cont) score
• rom: students' validated ct (romt) score
• pcnt: students' new ctt test score (pcnt)
3.6. data analysis
a comparative study using non-parametric tests to measure the
hypothesis contrast between the pre-post pcn, con and rom values
was performed. non-parametric tests were used because when the data
gathered was analysed, we saw that they had not come from a normal
distribution, and we did not have enough data to assume normality.
4. findings
4.1. overall results
table 6 shows the means, medians (more representative than the
mean in asymmetric distribution), and standard deviation for pre-test
and post-test of pcn, con and rom.
without making distinctions per grade, table 6 reveals a clear increase in the post-test results in the three variables, showing a greater
improvement in con variable, and a smaller improvement in rom
variable. standard deviation slightly increases in all the variables, except in pcn, where it is more reduced in the post-test.
fig. 7 shows box-plots for these three variables, both in the pre-test
and post-test. graphically, 50% of the central data are represented in
1 https://tinyurl.com/mecoprogct (in spanish). 2 https://tinyurl.com/mecoprogtrg (in spanish). 3 https://tinyurl.com/mecoprogctl (in spanish).
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
5
the box, and the median are marked with a line as representative
measure. the highest and lowest values for each box-plot correspond to
values which are not less than q1-1.5·(q3-q1) and not greater than
q3+1.5·(q3-q1). some outliers are marked with the case number.
after analysing the data using the shapiro-wilk test, we found that
the distribution of the variables under study did not come from a
normal distribution, except in post_con variable (p = 0.292) and
post_rom (p = 0.203). therefore, and without having a high enough
number of population, nonparametric tests were chosen for the study to
guarantee the robustness of the results.
spearman's rank correlation coefficient shows a significant correlation (p < 0.001) between pre and post-tests in pcn, con and rom
variables. the wilcoxon signed-rank test is used to compare two related
samples, in this case the pre and post-tests, and evaluate whether there
is any statistically-significant difference in the pre and post-tests in the
three variables studied.
table 7 shows a significant improvement for all tests. the rom pvalue is much higher than the others. therefore, con variable is the
most significant. consequently, we could conclude that the population
saw a significant improvement in the tests.
some additional information to size the effect is the r value, introduced by rosenthal in 1991. pcn had a value of r = 0.15 corresponding to a small effect, r = 0.55 for con variable, corresponding to
a large effect, and, finally, r = 0.16 for rom variable, indicating a small
effect.
4.2. results per grades
first, a descriptive analysis for each variable in the three grades is
presented. tables 8–10 show the median, mean and standard deviation.
con variable shows a large increase for all grades, in addition to
increasing data dispersion (see table 9). in rom variable, 5th and 6th
show an increase for the median, as well as the standard deviation. boxfig. 3. compthink app (2018), an example of the games for each of the seven options available.
table 5
concept dimension covered of 3-d ct dimensions model by compthink app.
compthink app brennan and resnick concept dimension on ct
loops loops and data
algorithms sequences
pattern sequences and data
conditionals conditionals
steps sequences and operators
instructions sequences
automats sequences and conditionals
fig. 4. an example of a romt question (“what instructions can you give pacman to reach the ghost?” choose from: a, b, c or d).
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
6
plots confirm this statement (see table 10). pcn variable shows a large
increase in 5th grade, followed by 6th grade. standard deviation is
reduced. no improvement is observed for 4th grade students (see
table 8).
box-plots confirm this reasoning and show the existence of several
outliers related to low marks for the three grades, especially in 4th
grade.
again, spearman's rank correlation coefficient shows a significant
correlation (p < 0.001) between pre and post-tests in pcn and con in
all the grades, and in 5th and 6th grades in rom. the wilcoxon signedrank test is used to compare two related samples, in this case pre and
post-test, and evaluate whether there is any statistically significant
difference in pre- and post-tests in the three variables studied for each
grade.
table 11 shows significant differences in different grades: there is a
significant improvement in pcnt variable in 5th (p = 0.008), as well as
romt variable, although with a higher p-value (p = 0.023). in the case
of con variable, the improvement is significant in all grades
(p = 0.000).
rosenthal r value quantifies the improvement where it happens. in
4th grade, a large improvement, close to very large, is observed in con
variable (r = 0.62). in 5th grade, there is a small increase, near to a
fig. 5. example of a pcnt question (“do you know what steps you need to take
to plant a tree? place the following four actions into order: 1) take a shovel, 2)
water the tree, 3) plant the tree, 4) dig a hole”).
fig. 6. flow diagram of the experiment.
table 6
median, mean and standard deviation in pre- and post-tests pcn, con and
rom.
pcn con rom
mdn m sd mdn m sd mdn m sd
pre 8.57 8.37 1.25 2.69 2.77 1.32 4.28 4.23 1.36
post 9.28 8.99 1.05 5 5.08 1.59 4.64 4.77 1.56
fig. 7. box-plot for variables pcn, con and rom in pre and post-test.
table 7
comparative study using wilcoxon test.
pcn con rom
z −2.830 −8.543 −2.294
p-value 0.005 0.000 0.022
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
7
medium increase in pcn variable (r = 0.27). a large increase occurs in
the con variable (r = 0.57) and a small increase in the rom variable
(r = 0.23). finally, in 6th grade, a large effect is found, with r = 0.55.
4.3. synopsys table
table 12 gathers the increase of the scores in the three tests taken by
the students before and after mecoprog.
finally, in response to our question regarding the relationship between pcnt and romt, there is a low lineal correlation between them
(spearman r = 0,248 p < 0.01).
5. discussion
this paper explored whether primary education students' ct can be
improved and, to what extent primary education students are able to
learn programming concepts. it included factors such as grade and used
tests to measure children's’ knowledge and computational thinking.
one important conclusion is that there is a statistic significant increase in children's post-test results both in knowledge (according to the
cont knowledge test), and ct values for all grades (according to pcnt
and romt ct tests). this suggests that even in a short period of time it
is possible to teach children basic computer programming concepts
such as memory, programming, conditionals or loops, and improve
their ct, with children as young as nine.
it is worth noting that although there is a general consensus regarding the need to foster children's ct (román-gonzález, 2015), and
the results reported in this study significantly contribute to the literature in this sens, there is still much controversy surrounding the definition of the term ct and how and when to integrate it into the curriculum (gouws, bradshaw, & wentworth, 2013).
since this study required a practical definition of what comprises ct
in order to work with children and anaylse what parts of ct could be
improved and how, we chose the 3d ct model (brennan & resnick,
2012; see table 1). the reason for selecting that model was that it had
been created by the authors of scratch, a program that allows children
to program.
as noted by vico (2017) (translated from spanish); “a child who
does not learn how to program will have the same handicap as a
spanish child who is not able to understand english”. this is also why
we wanted to foster an interest in ct, so that children can become
programmers. otherwise, it seems as though we have only taught our
pre-school children to read, but not how to write.
however, some computer science educators have argued that programming is not necessary to teach computational thinking (lu &
fletcher, 2009; yadav, zhou, mayfield, hambrusch, & korb, 2011).
some have even suggested that teaching programming to foster ct
could deter students as some may find computer science and programming boring (lu & fletcher, 2009).
in light of our results, and from our experience with children age 9
to 12, learning how to program is engaging and helps them focus on
problems. all children payed attention during the lessons regardless of
their grade. in general, it is well known that children love computers
and do not think that they are difficult or boring to use. this could be
used as a base to start working with children, who are naturally fascinated by technology.
this study is particularly relevant for teachers and national curriculums as it shows that children can enjoy learning about programming. until recently, it was unconceivable to think children could learn
about programming. on the contrary, children were not taught these
concepts until secondary school, or even university, at an age that
students begin to find these complex ideas difficult to understand, in
contrast to younger children, who can easily absorb them when adapted
to their age.
it has also become evident that teachers need guidance in their
approach to this task. according to this study, students are able to learn
programming concepts if they are taught with methodologies such as
mecoprog with scratch and those that use metaphors. teachers must
be trained in those methodologies if we want to reach primary
table 8
median, mean and standard deviation for pre-test and post-test for pcn, per
grades.
pcn
4th 5th 6th
mdn m sd mdn m sd mdn m sd
pre 9.28 8.60 1.42 7.85 8.26 1.12 8.57 8.45 1.34
post 9.28 8.75 1.68 9.28 9.03 1.01 9.28 8.95 1.09
table 9
median, mean and standard deviation for pre-test and post-test for con, per
grades.
con
4th 5th 6th
mdn m sd mdn m sd mdn m sd
pre 2.69 2.50 1.01 2.31 2.74 1.67 2.69 2.80 0.99
post 5.19 5.09 1.28 4.80 5.01 1.68 5.19 5.14 1.54
table 10
median, mean and standard deviation for pre-test and post-test for rom per
grade.
rom
5th 6th
mdn m sd mdn m sd
pre 4.28 4.43 1.54 4.11 4.08 1.21
post 5.00 5.17 1.71 4.64 4.46 1.38
table 11
comparative study using wilcoxon test.
pcn con rom
4th 5th 6th 4th 5th 6th 5th 6th
z −0.515 −2.674 −1.362 −4.204 −4.845 −5.715 −2.274 −0.928
p-value 0.607 0.008 0.173 0.000 0.000 0.000 0.023 0.354
table 12
rosenthal r to quantify the improvement detected in the three tests.
n dpcn dcon drom
4th 23 – 0.62 –
5th 38 0.27 0.51 0.23
6th 50 – 0.55 –
all 85 0.15 0.55 0.16
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
8
education students. therefore, and in line with the digital competence
that teachers should develop, we should include this training in their
pedagogical education (intef, 2017).
measuring the progress of ct is also necessary. the tests used for
this could differ depending on the definition of ct and the age of the
students. for instance, the test created by korkmaz, çakir, and özden
(2017) is limited to the sub-skills comprising the iste (2015) definition.
in addition, it is limited to associate students and older students.
only one validated test was found to measure ct according to the
3d ct model and to be useful for young children. the authors of this
test kindly allowed us to use it (román-gonzález et al., 2017) for this
study. however, the test (romt) is only validated for children older
than 10. for younger students, we tried a new test (pcnt), as explained
above, which was also in line with the published 3d ct model.
the results gathered both from romt and pnct proved that ct can
be improved by using mecoprog. however, given the low correlation
found between pcnt and romt, more studies should be carried out
focusing on how to assess ct for young students, particularly those
aged under 9.
5.1. limitations and future work
we are aware that these measures would change if we use a different ct definition, and that the results may change if we use a different model, and/or a different computer program other than scratch.
furthermore, mecoprog can be used with different resources, and
may thus produce different results in each case. the core metaphors
used in this paper are based on cooking. different metaphors can be
used such as car metaphors: the door as input/output for the car,
junctions for conditionals, roundabouts for loops and so on. during
class, teachers are able to select the most adequate metaphor from
mecoprog, as published (pérez-marín et al., 2018).
the experiment has been described in great detail so that other
researchers are interested in repeating it with a different sample or to
test more advanced programming concepts, can do so easily. this study
experiment focused on basic introductory computer programming
concepts because it was the first contact with those particular students
and the project only had a limited amount of time.
the authors are currently also carrying out a multifactorial study to
determine whether other factors such as sex, motivation or effort might
have an impact on students' ct test scores. we would also like to
continue with the validation of pcnt, given the low correlation found
between pcnt and romt.
6. conclusions
the findings of this longitudinal pre- and post-test quasi-experiment
carried out with 132 primary education students (aged 9 to 12) positively confirmed the formulated research question: can computational
thinking be improved using a methodology based on metaphors and
using scratch to teach computer programming to children?
table 12 gathers the main results of the research study. here, both
the knowledge programming concept test and the ct tests (romt and
pcnt) found better post-test scores, when data were analysed for all the
grades. these results suggest that using metaphors and scratch is useful
for teaching computer programming concepts to primary education
students, and for improving students' ct, providing a positive answer to
the research question. it contributes to the area of study exploring how
to develop computational thinking by covering gaps in methodologies,
and uses, for the first time, metaphors to teach basic programming
concepts to primary education students, together with scratch.
when the analysis is carried out per grade, it shows that 4th grade
students can understand programming concepts. in fact, it seems to
show that these students are actually able to learn more about programming concepts, as their increase in cont knowledge improves
more than any other group. because we could not apply the romt test
to them as they were aged younger than 10, no conclusion could be
drawn from this test. when the results of the pcnt are analysed, no
significant results could be drawn either, indicating the need for more
studies to quantify the increase (if any) of the development of ct in
students aged younger than 10 when they learn programming concepts.
we cannot end without highlighting the fact that 5th grade students
improved their performance in all tests. not only did they learn more
programming concepts through mecoprog, but their scores in both
ct-measuring tests increased significantly. finally, 6th and 4th grade
students' knowledge of programming improved, but no significant improvement was found in romt or pcnt scores. this may indicate either that these students need more time to improve their ct, or that the
mecoprog metaphors methodology is more applicable to students
aged 10–11.
acknowledgments
research funded by the projects tin 2015-66731-c2-1-r and
s2013/ice-2715.
references
aho, a. v. (2012). computation and computational thinking. the computer journal, 55(7),
832–835.
balanskat, a., & engelhardt, k. (2015). computing our future. computer programming and
coding priorities, school curricula and initiatives across europe. brussels, belgium:
european schoolnet2015.
barker, l. j., mcdowell, c., & kalahar, k. (2009). exploring factors that influence computer science introductory course students to persist in the major. acm sigcse
bulletin: vol. 41, (pp. 153–157). acm no. 1.
bers, m. u. (2010). the tangiblek robotics program: applied computational thinking for
young children. early childhood research & practice, 12(2), 2.
bers, m. u., ponte, i., juelich, c., viera, a., & schenker, j. (2002). teachers as designers:
integrating robotics in early childhood education. information technology in childhood
education annual, 1(1), 123–145.
bers, m., rogers, c., beals, l., portsmore, m., staszowski, k., cejka, e., et al. (2006).
innovative session: early childhood robotics for learning. proceedings of iste, c.
2011. computational thinking in k–12 education leadership toolkit.
boero, p., bazzini, l., & garuti, r. (2001). metaphors in teaching and learning mathematics: a case study concerning inequalities. pme conference: vol. 2, (pp. 2–185).
brackmann, c., barone, d., casali, a., boucinha, r., & muñoz-hernández, s. (2016).
computational thinking: panorama of the americas. computers in education (siie),
international symposium on iee (pp. 1–6). .
brennan, k., balch, c., & chung, m. (2014). creative computing. cambridge [masachussets].
harvard graduate school of educationhttp://scratched.gse.harvard.edu/guide/files/
creativecomputing20141015.pdf [consulta: 30/05/2017].
brennan, k., & resnick, m. (2012). new frameworks for studying and assessing the development of computational thinking. proceedings of the annual meeting of the
american educational research association, vancouver, canada (pp. 1–25). .
campe, s., & denner, j. (2015). programming games for learning: a research synthesis.
paper presented at the annual meeting of the american educational research association,
chicago, il.
cook, t. d., & campbell, d. t. (1986). the causal assumptions of quasi-experimental
practice. synthese, 68(1), 141–180.
compthink app (2018). http://www.lite.etsii.urjc.es/tools/compthink-app/.
coull, n. j., & duncan, i. m. (2011). emergent requirements for supporting introductory
programming. innovation in teaching and learning in information and computer
sciences, 10(1), 78–85.
csta, & iste (2011). operational definition of computational thinking for k–12 education.
retrieved from http://csta.acm.org/curriculum/sub/currfiles/compthinkingflyer.
pdf.
cuny, j., snyder, l., & wing, j. m. (2010). demystifying computational thinking for noncomputer scientists. unpublished manuscript in progress, [on line]. available: referenced in http://www.cs.cmu.edu/∼compthink/resources/thelinkwing.pdf.
denning, p. j. (2009). the profession of it. beyond computational thinking.
communications of the acm, 52(8), 28–30.
espino, e., soledad, c., & gonzález, c. (2015). estudio sobre diferencias de género en las
competencias y las estrategias educativas para el desarrollo del pensamiento computacional. revista de educación a distancia, 46.
furber, s. (2012). shut down or restart: the way forward for computing in uk schools. [on
line]. available: retrieved from http://royalsociety.org/education/policy/
computing-in-schools/report/.
garcía-peñalvo, f. j. (2016). a brief introduction to taccle 3—coding european project.
computers in education (siie), international symposium on ieee (pp. 1–4). .
ginat, d. (2004). on novice loop boundaries and range conceptions. computer science
education, 14(3), 165–181.
google for education (2018). exploring computational thinking. retrieved from https://
www.google.com/edu/resources/programs/exploring-computational-thinking/.
gouws, l. a., bradshaw, k., & wentworth, p. (2013). computational thinking in
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
9
educational activities: an evaluation of the educational game light-bot. proceedings of
the 18th acm conference on innovation and technology in computer science education (pp.
10–15). .
grover, s., & pea, r. (2013). computational thinking in k–12. a review of the state of the
field. educational researcher, 42(1), 38–43.
heintz, f., mannila, l., & färnqvist, t. (2016). a review of models for introducing
computational thinking, computer science and computing in k-12 education. frontiers
in education conference (fie), 2016 (pp. 1–9). ieee.
intef (2017). marco común de competencia digital docente. https://intef.es/blog/marcocomun-de-competencia-digital-docente-septiembre-2017/.
iste (2015). ct leadership toolkit. available at: https://www.iste.org/docs/ctdocuments/
ct-leadershipt-toolkit.pdf%3fsfvrsn%bc;4.
jiménez-peris, r., pareja-flores, c., patiño-martínez, m., & velázquez-iturbide, j.á.
(1997). the locker metaphor to teach dynamic memory. acm sigcse bulletin: vol.
29, (pp. 169–173). acm no. 1.
jovanov, m., stankov, e., mihova, m., ristov, s., & gusev, m. (2016). computing as a new
compulsory subject in the macedonian primary schools curriculum. global engineering
education conference (educon), 2016 ieee (pp. 680–685). ieee.
kalelioğlu, f. (2015). a new way of teaching programming skills to k-12 students: code.
org. computers in human behavior, 52, 200–210.
kazakoff, e. r., sullivan, a., & bers, m. u. (2013). the effect of a classroom-based intensive robotics and programming workshop on sequencing ability in early childhood. early childhood education, 41, 245–255.
korkmaz, ö., çakir, r., & özden, m. y. (2017). a validity and reliability study of the
computational thinking scales (cts). computers in human behavior, 72, 558–569.
lahtinen, e., ala-mutka, k., & järvinen, h. m. (2005). a study of the difficulties of novice
programmers. acm sigcse bulletin: vol. 37, (pp. 14–18). no. 3.
lakoff, g., & johnson, m. (2008). metaphors we live by. university of chicago press.
lee, e., kafai, y. b., vasudevan, v., & davis, r. l. (2014). playing in the arcade: designing
tangible interfaces with makey makey for scratch games. playful user interfaces (pp.
277–292). springer singapore.
lee, i., martin, f., denner, j., coulter, b., allan, w., erickson, j., & werner, l. (2011).
computational thinking for youth in practice. acm inroads, 2(1), 32–37.
lu, j. j., & fletcher, g. h. (2009). thinking about computational thinking. acm sigcse
bulletings, 41(1), 260e264.
margulieux, l. e., catrambone, r., & guzdial, m. (2016). employing subgoals in computer programming education. computer science education, 26(1), 44–67. https://doi.
org/10.1080/08993408.2016.1144429.
special issue ii on computer science education in k-12 schools. r. mccartney (ed.).
transactions on computing education, acm, 14, 2.
special issue on computing education in (k-12) schools. transactions on computing
education. r. mccartney, & j. tenenberg (eds.). acm, 14, 2.
milner, w. w. (2010). a broken metaphor in java. acm sigcse bulletings, 41(4), 76–77.
ouahbi, i., kaddari, f., darhmaoui, h., elachqar, a., & lahmine, s. (2015). learning basic
programming concepts by creating games with scratch programming environment.
procedia-social and behavioral sciences, 191, 1479–1482.
papadakis, s., kalogiannakis, m., & zaranis, n. (2016). developing fundamental programming concepts and computational thinking with scratchjr in preschool education: a case study. international journal of mobile learning and organisation, 10(3),
187–202.
papert, s. (1980). mindstorms: children, computers, and powerful ideas. new york, ny:
basic books.
paris, n. a., & glynn, s. m. (2004). elaborate analogies in science text: tools for enhancing preservice teachers' knowledge and attitudes. contemporary educational
psychology, 29(3), 230–247.
pea, r. d., & kurland, d. m. (1984). on the cognitive effects of learning computer programming. new ideas in psychology, 2(2), 137–168.
pérez-marín, d., hijón-neira, r., & martín-lope, m. (2018). a methodology proposal
based on metaphors to teach programming to children. ieee revista iberoamericana de
tecnologías del aprendizaje, 13(1), 46–53.
putnam, r. t., sleeman, d., baxter, j. a., & kuspa, l. k. (1986). a summary of misconceptions of high school basic programmers. journal of educational computing
research, 2(4), 459–472.
resnick, m. (1996). new paradigms for computing, new paradigms for thinking. in y.
inkafai, & m. resnick (eds.). constructionism in practice: designing, thinking, and
learning in a digital world. mahwah, nj: erlbaum.
resnick, m., maloney, j., monroy-hernandez, a., rusk, n., eastmond, e., brennan, k.,
et al. (2009). scratch: programming for all. communications of the acm, 52(11),
60–67.
rodríguez diéguez, j. l. (1988). las metáforas en la enseñanza. enseñanza & teaching.
revista interuniversitaria de didáctica (pp. 223–240). universidad de salamanca 6.
román-gonzález, m. (2015). computational thinking test: design guidelines and content
validation. proceedings of edulearn15 conference (pp. 2436–2444). .
román-gonzález, m., pérez-gonzález, j. c., & jiménez-fernández, c. (2017). which
cognitive abilities underlie computational thinking? criterion validity of the computational thinking test. computers in human behavior, 72, 678–691. https://doi.org/
10.1016/j.chb.2016.08.047.
rosenthal, r. (1991). meta-analytic procedures for social research (2nd ed.). newbury park,
ca: sage.
sanford, j. p., tietz, a., farooq, s., guyer, s., & shapiro, r. b. (2014). metaphors we teach
by. proceedings of the 45th acm technical symposium on computer science education (pp.
585–590). acm.
seoane-pardo, a. m. (2018). computational thinking between philosophy and stem.
programming decision making applied to the behaviour of “moral machines” in ethical
values classroomieee-ritahttps://doi.org/10.1109/rita.2018.2809940.
seppälä, o., malmi, l., & korhonen, a. (2006). “observations on student misconceptions—a case study of the build–heap algorithm”. computer science education,
16(3), 241–255.
sović, a., jagušt, t., & seršić, d. (2014). how to teach basic university-level programming concepts to first graders? integrated stem education conference (isec), 2014
ieee (pp. 1–6). ieee.
strawhacker, a., portelance, d., lee, m., & bers, m. (2015). designing tools for developing
minds: the role of child development in educational technology. idc 2015 workshop.
available on-line at: http://everychildacoder.org.uk/wp-content/uploads/2015/05/
strawhacker_et_al_final.pdf last visit: november 23rd, 2017 .
thomas, g. p., & mcrobbie, c. j. (2001). using a metaphor for learning to improve
students' metacognition in the chemistry classroom. journal of research in science
teaching, 38(2), 222–259.
vico, f. (2017). el niño que no programe tendrá un hándicap como hoy lo tiene el que no
entiende inglés. entrevistas educación 3.0. https://www.educaciontrespuntocero.com/
entrevistas/francisco-j-vico-programacion/59063.html.
wing, j. m. (2006a). computational thinking. communications of the acm, 49(3), 33–35.
wing, j. m. (2006b). computational thinking. communications of the acm, 49(3), 33–35.
wing, j. (2008). computational thinking and thinking about computing. philosophical
transactions of the royal society of mathematical physical and engineering sciences, 366,
3717–3725.
wing, j. (2011). research notebook: computational thinking— what and why. [on line].
available: the link magazine, springpittsburgh: carnegie mellon university. retrieved
from http://link.cs.cmu.edu/article.php?a=600.
wing, j. m. (2016). computational thinking, 10 years later. http://www.microsoft.com/enus/research/blog/computational-thinking-10-years-later.
yadav, a., gretter, s., hambrusch, s., & sands, p. (2016). expanding computer science
education in schools: understanding teacher experiences and challenges. computer
science education, 1–20.
yadav, a., zhou, n., mayfield, c., hambrusch, s., & korb, j. t. (2011). introducing
computational thinking in education courses. proceedings of acm special interest group
on computer science education, dallas, tx.
d. pérez-marín, et al. computers in human behavior xxx (xxxx) xxxx
10"
"computational thinking
by susan german
students develop computational thinking by approaching new situations using a
variety of computer-based methods, including simulation, data
mining, networking, automated
data collection, gaming, algorithmic reasoning, robotics, and programming. computational thinking is different from mathematical
thinking. according to sneider et
al. (2014), students develop mathematical thinking when they attempt to approach a new situation
with their acquired math skills,
including counting, arithmetic, algebra, geometry, calculus, set theory, and topology. computational
thinking is part of the next generation science standards science and
engineering practices (see figure
1). computational thinking can be
used in conjunction with any of
the practices.
implementing
computational thinking
computer simulations provide
students with the opportunity to
model phenomena by changing
the input conditions and measuring the outcome. while i firmly
believe it is best for students to interact with physical phenomena, a
computer simulation can be more
time efficient and allows students
to try out “what if…?” scenarios
in a safe manner. computer simulations are best used in situations
where physical phenomena are
difficult to study directly, such
as the solar system or molecular
motion. however, while electric
circuits are directly observable,
using a simulation can bring the
unobservable parts of the phenomenon to an observable level.
i developed an assessment on
electric circuits after my students
completed a unit on electricity,
during which they learned about
series and parallel circuits. the
assessment used the phet circuit
construction kit: dc-virtual lab
(see resources), which allowed
students to virtually construct different types of circuits, adjust the
| figure 1: ngss sep: mathematical and computational
thinking (ngss lead states 2013, appendix f, p. 10).
mathematical and computational thinking in 6–8 builds on k–5 experiences
and progresses to identifying patterns in large data sets and using
mathematical concepts to support explanations and arguments.
• use digital tools (e.g., computers) to analyze extensive data sets for
patterns and trends.
• use mathematical representations to describe and support scientific
conclusions and design solutions.
• create algorithms (a series of ordered steps) to solve a problem.
• apply mathematical concepts and processes (e.g., ratio, rate, percent,
basic operations, simple algebra) to scientific and engineering questions
and problems.
• use digital tools and mathematical concepts and arguments to test and
compare proposed solutions to an engineering design problem.
36 teacher to teacher
number of resistors used, and add
switches. students studied and
measured the current (amps) and
voltage (volts) of the following
circuits: simple (figure 2), series
(figure 3), parallel (figure 4), and
complex (figure 5).
while building circuits and
measuring current and voltage,
students asked, “why are the
charges moving slower in the
series circuit than in the parallel
circuit?” to determine that the
chargers were moving slower,
students chose to use an ammeter to measure the current of the
circuit. when the ammeter measured lower amperage on wires
where the charges moved slower,
students were able to observe the
current and build a mental model of electric current. alternatively, students could work with
a physical circuit and set up the
series circuit and parallel circuit
with light bulbs. students would
be able to observe differences in
the brightness of the bulbs and
make measurements of the voltage and current in each circuit;
however, the actual movement
of charge would be based on a
student’s inference. using a computer simulation as a scientific
model allows unseen parts of the
circuit to be made visual.
to assess student understanding of series, parallel, and complex circuits, i asked them to build
models of a circuit of a flashlight
with three bulbs and specific design criteria. (figure 6). in the
simulation, students had access
to a large voltage battery as well
as a regular battery. while using a 100-v battery is beyond the
norm of flashlight batteries, allowing students to use the battery
forced students to think deeper
in constructing a circuit. in order to solve the problem created
by using a battery too large for a
flashlight, student needed to add
resistors in order for the circuit to
properly work. (students set a lot
of simulation circuit fires as they
worked on solutions.)
conclusion
computational thinking is more
than using a computer simulation to make observations. this
lesson required students to “use
digital tools and mathematical
concepts and arguments to test
and compare proposed solutions to an engineering design
problem” (ngss lead states,
appendix f, 2013). my students
used a simulation to explore their
“what if…?” questions when
they integrated the high-voltage
battery as the energy source for
their circuit and created a circuit
that meets the requirements of
the assessment.
furthermore, the problem was
engineering in nature. students
used a simulation to develop
and test ideas for how well they
met the defined criteria—a process made quicker by using a
simulation rather than physical
materials. the important step in
the lesson is for students to understand that the simulation is
programmed with algorithms
based on data for how a physical
circuit works and abstractions
that allow students to visualize
| figure 2: simple circuit
| figure 3: series circuit
| figure 4: parallel circuit
| figure 5: complex circuit
july 2019 37
teacher to teacher
| figure 6: flashlight problem
you want to create a flashlight using three bulbs. it will be essential to
control which lights are turned on (one light, two lights, or three lights). you
can use one or two batteries, no more than three switches, and as much wire
as necessary. the flashlight design should maximize the brightness of the
bulbs and be on one circuit.
use the simulation we have been working with to come up with a circuit
design.
• screenshots of your final design
• a written explanation of your final design
• claim-a statement describing your final design
• evidence-data from investigation that supports your design
• reasoning-connect the evidence to claim by describing the science
involved
• data on your final design (voltage and current)
the normally unseen portions of
the phenomenon. •
references
ngss lead states. 2013. next
generation science standards: for
states, by states. washington, dc:
national academies press.
sneider, c., c. stephenson, b. schafer,
and l. flick. 2014. teachers toolkit:
exploring the science framework and
ngss: computational thinking in the
science classroom. science scope
38 (03): 10–15.
yadav, a., h. hong, and c. stephenson.
2016. techtrends (2016) 60: 565.
resource
circuit simulation—https://phet.
colorado.edu/en/simulation/circuitconstruction-kit-dc-virtual-lab
susan german (sgerman@hallsville.org) is a science teacher at hallsville r-iv school district in hallsville, missouri.
grade level k–5
simulations • assessments • videos
be a sky sleuth helps
students fi gure out
how patterns can be
used to predict the
positions of the sun,
moon, and stars.
thinking
beyond
english language
arts connections
mathematics
connections
differentiated
learning
use activities in the teacher’s guides to implement
three-dimensional learning in your classrooms.
stem for kids! phenomenon-based, three-dimensional learning content that’s designed using the 5e model and
 incorporates the science and engineering practices (seps), crosscutting concepts (cccs), and disciplinary core ideas
(dcis). comprehensive teacher’s guides are available. each teacher’s guide provides connections to the grade-level
content (including science, ela, and mathematics) plus tips and practical information to enhance the e-book experience.
use activities in the teacher’s guides to implement three-dimensional learning in your classroom.
lexile level: 500l
visit www.nsta.org/ebooks/gradesk-5
to learn more and order.
purchases of 10+ e-books of a single title will include
a detailed teacher's guide specifi c to that e-book.
38
reproduced with permission of copyright owner. further reproduction
prohibited without permission."
"computational thinking and tinkering: exploration of an early
childhood robotics curriculum
marina umaschi bers, louise flannery, elizabeth r. kazakoff*, amanda sullivan
tufts university, medford, ma, usa
article info
article history:
received 30 january 2013
received in revised form
22 october 2013
accepted 29 october 2013
keywords:
elementary education
interactive learning environments
pedagogical issues
teaching/learning strategies
robotics
programming
early childhood
abstract
by engaging in construction-based robotics activities, children as young as four can play to learn a range
of concepts. the tangiblek robotics program paired developmentally appropriate computer programming and robotics tools with a constructionist curriculum designed to engage kindergarten children in
learning computational thinking, robotics, programming, and problem-solving. this paper documents
three kindergarten classrooms’ exposure to computer programming concepts and explores learning
outcomes. results point to strengths of the curriculum and areas where further redesign of the curriculum and technologies would be appropriate. overall, the study demonstrates that kindergartners were
both interested in and able to learn many aspects of robotics, programming, and computational thinking
with the tangiblek curriculum design.
 2013 elsevier ltd. all rights reserved.
1. introduction
for decades, early childhood (preschool to grade two) curricula have focused primarily on literacy and math, especially with the
educational reforms of no child left behind (zigler & bishop-josef, 2006). however, there has been some recent attention to science,
technology, engineering, and math (stem) learning for young children (gelman & brenneman, 2004; sesame workshop, 2009; white
house, 2011). furthermore, new technology learning standards and best practices for integrating technology into early childhood education have been developed (barron et al., 2011; international society for technology in education (iste), 2007; naeyc & fred rogers center
for early learning and children’s media, 2012; u.s. department of education, 2010). of note, the technology policy statement from naeyc &
fred rogers center for early learning and children’s media (2012) provides a guide for early childhood education professionals in using
interactive digital technologies in balanced and developmentally appropriate ways. it addresses important issues related to using digital
technology with children ages three–eight years, including the needs for technology use to serve the needs of the children, and for educators
to be able to understand, evaluate, and integrate developmentally appropriate technologies in their classrooms. however, there is little
research on computer programming specifically for early childhood, the subject this paper explores.
as new devices, from smartphones and tablet computers to electronic learning toys, find new audiences with increasingly young
children, challenging question arise about how to define developmentally appropriate activities and content for children of different ages.
while the majority of research on robotics and programming in education focuses on later schooling, teaching these subjects during
foundational early childhood years can be an engaging and rewarding experience for young learners (bers, 2008). previous research has
shown that children as young as four–six years old can build and program simple robotics projects (bers, ponte, juelich, viera, & schenker,
2002, pp. 123–145; cejka, rogers, & portsmore, 2006; kazakoff, sullivan, & bers, 2012; perlman, 1976, p. 260; wyeth, 2008) as well as learn
powerful ideas from engineering, technology, and computer programming while also building their computational thinking skills (bers,
2008). robotic manipulatives allow children to develop fine-motor skills and hand–eye coordination while also engaging in collaboration and teamwork. additionally, robotics can provide a fun and playful way for teachers to integrate academic content with the creation of
* corresponding author. devtech research group, eliot pearson department of child development, 105 college ave., medford, ma 02155, usa. tel.: þ1 617 347 5746.
e-mail address: elizabeth.kazakoff@tufts.edu (e.r. kazakoff).
contents lists available at sciencedirect
computers & education
journal homepage: www.elsevier.com/locate/compedu
0360-1315/$ – see front matter  2013 elsevier ltd. all rights reserved.
http://dx.doi.org/10.1016/j.compedu.2013.10.020
computers & education 72 (2014) 145–157
meaningful projects. through robotics, young children can experiment with concepts of engineering as well as storytelling by creating
narrative contexts for their projects (bers, 2008). by engaging in these types of robotics projects, young children play to learn while learning
to play in a creative context (resnick, 2003).
computers offer new ways of representing and interacting with information and an entirely new category of “objects to think with”
(papert, 1980). in the form of programmable and interactive robots, computers can become powerful learning tools. robotics offers children
the opportunity to engage with content from the domain of computer science, practice problem-solving skills, and work on fine-motor skills
and eye–hand coordination. the tangiblek robotics program, a design-based research initiative now in its fifth year, has paired developmentally appropriate programming and robotics tools with a curriculum to engage kindergartners in learning computational thinking,
robotics and programming concepts, as well as problem-solving and reasoning. the goal of this paper is to present young children’s learning
outcomes on computer programming concepts as taught through the tangiblek curriculum in order to highlight the potential for learning of
integrating computer programming and robotics into the early childhood classroom.
1.1. theoretical framework: constructionism and positive technological development
the theoretical approach used for designing the educational intervention and curriculum and for integrating the tangiblek robotics
program into early childhood classrooms incorporates elements from papert’s (1980) constructionist framework, which states that children
can learn deeply when they build their own meaningful projects in a community of learners and reflect carefully on the process.
papert’s (1980) constructionism is rooted in piaget’s (1954) constructivism – which conveys the idea that the child actively builds
knowledge through experience – and the related “learn-by-doing” approach to education. while piaget’s (1954) theory was developed to
explain how knowledge is constructed in an individual’s mind, papert (1980) expands on it to focus on the ways that internal constructions
are supported by constructions in the world, including through the use of computers and robotics. a constructionist teaching approach
provides children the freedom to explore their own interests through technologies (bers, 2008) while investigating domain-specific content
learning and also exercising meta-cognitive, problem-solving, and reasoning skills (e.g., clements & gullo, 1984; clements & meredith,
1992). papert (1980) discussed that well-designed constructionist activities have embedded in them ‘powerful ideas’, central concepts
within a domain that are both epistemological and personally useful, interconnected with other disciplines, and have roots in intuitive
knowledge that a child has internalized over a long period of time (bers et al., 2002; papert, 1980). an idea may be considered powerful to
the degree that it is useful in building and extending further knowledge (papert, 2000). the robotics curriculum described in this paper is
composed of powerful ideas from the domains of computer science and engineering (e.g., the engineering design process, debugging,
robotic motion and sensing, using programming instructions, control flow by sequence, control flow by specific instructions).
classroom activities designed to impact learning outcomes and cognitive growth, also have an impact on (and are influenced by)
children’s social, emotional, and moral development. as a framework to guide the design and implementation of a robotics curriculum that
also focuses on these dimensions of the child, bers’ (2010, 2012) positive technological development (ptd) was utilized. ptd takes into
consideration the learning environment and pedagogical practices, as well as cultural values and rituals, which mediate teaching and
learning (bers, 2008; rogoff, goodman turkanis, & bartlett, 2001). the educational experience proposed by the presented robotics curriculum was structured using the ptd framework to encourage six behaviors, which in turn foster the development of beneficial core
cognitive and social traits. specifically, engaging in content generation, creative design and problem-solving, collaboration, communication,
choices of conduct, and community-building may lead to a sense of competence and confidence, the ability to connect with and care about
others, contribution to entities outside the self, and moral character (bers, 2010, 2012). for instance, by iteratively planning and revising a
robotics project in a supportive environment, children may gain confidence in their abilities to learn and solve problems. alternatively,
discussions of how to share limited resources fairly amongst the class are opportunities for positive moral development.
1.2. learning through computer programming
embedded in the exploration of computer programming and robotics, the tangiblek curriculum also fosters computational thinking. this
term has been defined in many ways and encompasses a broad and somewhat debated range of analytic and problem-solving skills, dispositions, habits, and approaches used in computer science (barr & stephenson, 2011; international society for technology education and
the computer science teachers association, 2011; lee et al., 2011). the tangiblek curriculum specifically fosters computational thinking
skills such as: problem representation; systematicity in generating and implementing solutions; exploring multiple possible solutions;
problem-solving on multiple levels – from approaching the overall challenge to “debugging” or trouble-shooting specific difficulties with a
given solution’s implementation; productive attitudes toward “failure” and misconceptions uncovered along the route to a successful
project; and strategies for approaching open-ended and often difficult problems. such skills are of general applicability beyond robotics and
computational thinking.
1.3. the tangiblek robotics program
the tangiblek robotics program, whose design is informed by the theoretical frameworks of constructionism and ptd, has iteratively
implemented and assessed a set of programming and robotics tools, curricula, and pedagogical approaches in close collaboration with
hundreds of children and dozens of teachers over the course of five years. the research goals of the tangiblek robotics program are to:
1) provide an evidence-based description of young children’s learning trajectories in computational thinking and capacity to understanding computer programming and robotics concepts when given developmentally appropriate materials,
2) develop and test an early childhood curriculum to teach developmentally appropriate concepts from computer programming and
robotics to children in kindergarten through second grade,
3) investigate the design features of the programming interface and the mediating role interface design plays in learning to program.
146 m.u. bers et al. / computers & education 72 (2014) 145–157
this paper addresses the first of these goals, to describe young children’s learning trajectories in computational thinking and capacity to
understand computer programming and robotics concepts. this understanding will allow further revision to the tangiblek curriculum.
the tangiblek robotics project makes use of commercially available robotics construction kits and the cherp (creative hybrid environment for robotics programming) language to give behaviors to the robotic constructions (bers, 2008; bers & horn, 2010; horn et al.,
2011; kazakoff & bers, 2012; kazakoff, sullivan, & bers, 2012). cherp is a hybrid tangible and graphical computer language designed to
provide young children with an engaging introduction to computer programming in a developmentally appropriate way. the software
allows children to create programs to control their robots from tangible wooden blocks and/or graphical, on-screen icons. the design of
cherp avoids the technical and syntax-related challenges of text-based programming languages. furthermore, the hybrid interface allows
children to choose the interface that best suits their changing preferences as physical abilities, perceived social appeal, and the level of
challenge of the activity at hand evolve (horn et al., 2011), because both tangible and graphical interfaces can represent the same concepts.
the tangiblek curriculum introduces increasingly complex powerful ideas from computer science in a robotics context in a structured,
developmentally appropriate way. the powerful ideas from computer science addressed in this curriculum include: the engineering design
process and debugging (trouble-shooting), robotic motion and sensing, and three aspects of programming: choosing the correct programming instructions, controlling the flow of actions by sequencing the action instructions accordingly, and controlling the flow of actions
by using special control flow instructions. section 2.3 contains more detailed definitions of each powerful idea. in addition to the concrete
robotics and programming concepts and skills introduced in each activity, skills such as observation, reflection, and decomposition of
complex processes are interwoven throughout the curriculum.
the curriculum, which takes approximately 20 h of classroom work, includes six structured 60- to 90-min activities and a culminating
interdisciplinary project. all the activities focus on building and programming a robotic vehicle to accomplish a particular goal. each lesson
addresses one or more powerful idea(s) within the context of a narrative theme. the six lesson activities and their embedded content are as
follows:
 lesson 1: the engineering design process
children build sturdy, non-robotic vehicles to transport toy people on a floor map. children apply the stages of the engineering design
process to plan, test, and improve their vehicles.
 lesson 2: robotics
children share and learn ideas about what robots are and are not. they explore robotic parts by designing and building their own robots.
they learn to appropriately connect robotic parts (e.g., snap-together wires and motors) to make a robot that moves.
 lesson 3: choosing and sequencing programming instructions
in this activity, children program their robots to dance the “hokey-pokey” by choosing relevant instructions and putting them in the
correct order or sequence.
 lesson 4: looping programs (control flow instructions 1)
children use “repeat” instructions to program their robots to move forward forever. next, they program their robot to move forward only
a particular number of times to reach a fixed location.
 lesson 5: sensors
children use light sensors to program their robots to turn its light on when it is dark out and vice versa. they draw comparisons between
robotic sensors and the five human senses.
 lesson 6: branching programs (control flow instructions 2)
children are introduced to a pair of conditional control flow instructions, “if” and “if not”, which are also used with a sensor to make
programs that incorporate environmental conditions into the robot’s behavior.
in addition to the structured activities described above, the tangiblek curriculum includes songs, games, and free-play with the robotics
and programming materials in order to foster a playful learning environment for children. for example, in lesson 3, children sing and dance
the “robot hokey-pokey” and play simon says with the cherp programming commands to recall and apply the programming instructions.
throughout the 20 h curriculum, children have ample opportunity to freely build and design with the robotics materials and to create their
own cherp programs, beyond those that are set forth in each of the structured lessons.
after completing the six lessons described above, each classroom embarks on a culminating, interdisciplinary project, which invite
children to apply the now familiar powerful ideas to a particular theme or context. the teacher decides on a theme drawn from other
subjects studied during the year, and each child chooses a challenge within this theme. past classrooms have selected topics such as animal
behaviors, vehicles that help the community, or “who am i?” children created projects representing snakes that slither, recycling trucks that
collect refuse, and sewing needles that travel back and forth through fabric, among many others. the projects allow children to demonstrate
the powerful ideas they learned over the six activities as well as to apply them and continue learning about them in a new context.
having introduced an overview of the tangiblek robotics program, including its technological, curricular, and theoretical components,
we now present a study of three kindergarten classrooms in which the tangiblek robotics program was implemented. the following
sections report the distribution of achievement scores children attained on selected computer programming concepts and skills tied to the
m.u. bers et al. / computers & education 72 (2014) 145–157 147
powerful ideas listed above. achievement scores form the basis on which to discuss the curriculum structure and content and consider the
implications for understanding children’s early learning trajectories of computational concepts and for further adaptation of the curriculum.
2. study design
within the design-based research tradition of iterative testing, analysis, and refinement of an intervention, (see, e.g., cobb, confrey,
disessa, lehrer, & schauble, 2003), the tangiblek robotics program has spent five years exploring what children are capable of learning
and accomplishing in the domains of robotics and programming. the study described in this paper examines how successfully children
learned the core concepts (powerful ideas) of robotics and programming in the tangiblek curriculum. the study took place during the fourth
year of the overall project, following piloting and refinement of the software and curriculum in a range of settings, from classrooms and
after-school/summer programs to the research lab. the extensive testing, exploration, and refinement of the preceding study iterations also
laid a foundation for understanding how young children learn and think about core concepts of programming and robotics. for instance,
several of the curricular activities were simplified to enable better focus on the target concepts; movement games and songs were added to
the curriculum to engage children in multiple modes of understanding concepts and to provide reinforcement for basic knowledge. in
addition, some of the programming icons were revised to use more familiar imagery for children.
2.1. participants
each of the three teachers involved in this study volunteered to participate following email notification of the opportunity to principals of
a limited number of schools in the greater boston area. all children in each classroom participated in the curriculum, but each family had the
option to allow or decline data collection. according to school community needs, consent materials were available in english, portuguese,
and spanish.
children in the study attended one of three greater boston area kindergarten classrooms, two of which were at a public urban school, and
one at a private suburban school. from a total of 63 children enrolled in the three classes during the study, 53 are included in data analysis.
children were included in data analysis unless they missed more than one activity or if data was not collectible for more than one activity.
attrition was due to typical classroom absences as well as the difficulty of collecting data with limited researchers in a bustling classroom
environment.
classroom 1, a kindergarten in an independent, k-8, religious-based, private school in a suburb of boston, ma, had 23 children, 18 of
whom are included in data analysis. the student population at this school was 97% white, 1% as asian, 1% as black, 1% hispanic (http://nces.
ed.gov/globallocator/). of the children in the kindergarten class, 50% were male and 50% were female. they ranged from ages 4.9 to 6.2 years
at the start of the study, with a median age of 5.6 years. the only kindergarten classroom at this school, this class was taught by a male
teacher with seven years of teaching experience, who, on a scale from 1 (none) to 5 (expert), rated his computer experience as 5, programming experience as 3, and robotics experience as 1.
classrooms 2 and 3 were located at the same urban k-8 school (nclb level 3), located just outside of boston, ma. the makeup of this
school during the 2010–2011 school year was 38.9% white, 36.3% hispanic, 16.2% african american, 7.0% asian american, and 1.7% multirace. the school was comprised of 41.1% english-language learners and 64.4% of students were classified as low income (massachusetts
department of education, 2006).
a female teacher with six years of teaching experience taught classroom 2. she rated her computer experience as a 4, robotics experience
as a 2, and programming experience as a 2. this classroom had 19 children enrolled, 17 of whom are included in the data analysis. of those 17
children, 59% were male and 41% were female. at the start of the curriculum, the children in this classroom ranged in age from 4.9 to 6.2
years old, with a median age of 5.6 years.
a female teacher with 15 years of teaching experience taught classroom 3. she also rated her computer experience as a 4, robotics
experience as a 2, and programming experience as a 2. the data analysis includes 18 of 21 children enrolled in this classroom. of the 18
participants, 44% were female and 56% were male. the children’s ages at the start of the curriculum in classroom 3 ranged from 5.6 to 6.5
years, with a median age of 6.0 years old.
the overall age range for the 53 children included in data analysis was 4.9–6.5 years, and their average age at the start of the curriculum
was 5.7 years old. over the three classrooms as a whole, 45% of the children were female and 55% male. the participants in this study are
thought to be generally representative of the general kindergartners population, as the sample includes both public and private school
students, both male and female teachers, a fairly even proportion of male and female students, and, as described above, a diverse range of
ethnic and socioeconomic backgrounds, particularly at to the participating public school.
2.2. procedure
each classroom’s head teacher and all research assistants (nearly 20 research collaborators in total) received training to prepare them for
teaching or assisting the robotics curriculum and participating in the research and data collection. the high number of assistants was needed
for two reasons. first, a low student-to-adult ratio in each lesson ensured adequate observation and documentation of students’ work.
secondly, most research assistants had limited availability across the full set of study sessions. therefore, attention was given to all collaborators’ to ensure they received careful and detailed training. the 3-h introductory training covered technical, curricular, and pedagogical
aspects of the program including how to use the cherp programming language and lego robotics kits as well as activity content and
training on the structure and the teaching approach framed by the ptd model presented earlier. the training also included explanation and
examples of how to score children’s work in each activity according to a scale of understanding levels, described below.
the teachers then implemented the tangiblek curriculum in their own classrooms with technical support from trained research assistants. two teachers used the curriculum with the whole class working together. the third teacher worked with half of the class at a time,
finishing the entire curriculum with one group before starting it with the other. each curricular activity took one to two 60–90 min session(s). the teacher introduced key concepts and the day’s activity in a whole-group setting along with a short song or game to reinforce the
148 m.u. bers et al. / computers & education 72 (2014) 145–157
concepts. as mentioned earlier, in lesson 3, each class sang and danced the “hokey-pokey” before programming their robots to do this
dance. additionally, the game “simon says” was often used in lessons 3–6 to reinforce the cherp programming instructions and their
corresponding robotic actions. after the whole-group activities, children built and/or programmed their own robotic vehicles. the children
worked independently on their projects but sat in groups of four and received support as needed from the research assistant or classroom
teacher at their group while also interacting with their peers. with the variety of coders evaluating children’s work, we systematically
accounted for potential intercoder differences by varying which adult worked with which children during each lesson. each session’s work
ended with a group discussion for children to share progress, questions, and successful strategies, and for the teacher to help reinforce the
core robotics and programming concepts and the engineering design process.
to assess learning outcomes after each activity, research assistants evaluated the robot and/or program made by each child. they
assessed the child’s level of understanding of selected core concepts as seen by successful application of the concepts in the robot or
program. if needed, they also talked with children to gain more information about their work and understandings. by examining, for
instance, the child’s program for correct selection and sequencing of action instructions or proper use of the “repeat” instruction, research
assistants scored each child’s achievement of the core goals of the lesson using the following 6-point likert scale designed to document the
thoroughness of the child’s understanding and application of activity-specific concepts and skills as well as their use of general problemsolving skills. a score of 4 or higher was defined as the target level of achievement.
5 complete achievement of the goal, task, or understanding
4 mostly complete achievement of the goal, task, or understanding;
3 partially complete achievement of the goal, task, or understanding;
2 very incomplete achievement of the goal, task, or understanding;
1 did not complete the goal, task, or understanding;
0 did not attempt/other.
in each lesson, children were scored on multiple concepts using this likert scale. for example, in lesson 3, children programmed their
robots to dance the “hokey-pokey” by 1) choosing the correct instructions (a skill referred to here as correspondence) and 2) putting the
instructions in the correct order (sequencing). the concepts of sequencing and correspondence are described in more detail in sections 2.3.2
and 2.3.3. as an illustration of the general scale, children received one point on the correspondence scale for each programming instruction
that correctly matched a line of the song. below are examples of children’s programs that were scored at each level of correspondence in
lesson 3:
5 begin, forward, backward, forward, shake, spin, end (all correct);
4 begin, forward, forward, forward, shake, spin, end (second forward should be backward);
3 begin, forward, backward, shake, end (missing forward and spin);
2 begin, shake, spin, end (missing forward, backward, forward)
1 begin, shake, end (missing forward, backward, forward, and spin).
0 despite assistance and prompting, the child did not attempt hokey-pokey task.
these same programs also received a 0–5 score for sequencing in lesson 3.
2.3. variables examined
to examine children’s growing computational thinking ability throughout implementation of the tangiblek curriculum, four key variables were observed and assessed: debugging, correspondence, sequencing, and control flow.
2.3.1. debugging
when faced with a difficult problem or task, children (and adults) are often unable to determine a suitable solution on the first attempt.
in these situations, “debugging” skills can be helpful. debugging, or trouble-shooting, is a form of problem-solving used in the fields of
engineering and computer science. it encompasses four steps: 1) to debug a problem, the child must first recognize that something is not
working or not meeting the stated goal. for example, a child programming her robot to dance the hokey-pokey in lesson 3 watches her
program running and realizes that the robot does not “shake it all about”. 2) in step 2 of the debugging process, children either decide to
keep their original goal or switch to an appropriate alternative. this child might continue to pursue the original plan of making the robot
dance all the parts of the hokey-pokey, or, as is common at this age, she might come up with an alternative, such as having their robot do a
different dance. 3) the third stage of debugging is generating a hypothesis as to the cause of the problem. the child in our example may
hypothesize that the program is missing an instruction that would make their robot shake. 4) finally, the last aspect of debugging is
attempting to solve the problem. the child might put a “shake” block in different positions in the program until the program fully matches
the song. debugging skills are not limited to the arena of engineering and computer science. previous research has found that children can
acquire and transfer debugging skills to activities outside of the programming context with appropriate support, including explicit instruction (klahr & carver, 1988; salomon & perkins, 1987).
the steps of the debugging process are a critical component of the engineering design process, which refers to the cyclical or
iterative process engineers use to design an artifact in order to meet a need (massachusetts department of education, 2006). as defined
by the ma curriculum frameworks, its steps include: identifying a problem, looking for ideas for solutions and choosing one, developing a prototype, testing, improving, and sharing solutions with others (see fig. 4). the steps of testing and improving, which require
debugging, are particularly important in establishing a learning environment where failure – rather than immediate success – is
expected and seen as necessary for learning. with the engineering design process, children are not expected to “get it right” the first
time.
m.u. bers et al. / computers & education 72 (2014) 145–157 149
in the tangiblek curriculum, debugging and the engineering design process were first introduced in lesson 1, and the concepts and skills
were applied throughout the rest of the curriculum. children were assessed on their ability to apply the four core aspects of debugging
(described above) in each lesson and final project.
2.3.2. correspondences between actions and instructions
a program is a sequence of instructions that a computer (in this case, a robot) acts out in an order specified by the programmer (stair &
reynolds, 2003). each instruction has a specific meaning, and the order of the instructions leads to the robot’s overall actions. making
correspondences between actions and instructions encompasses the understanding that each programming instruction represents a
specific action carried out by the robot.
another way to understand the process of correspondence is to frame it with the notion of symbols, a core concept that children
are learning in kindergarten in both math and literacy. each programming instruction is a symbol for the action the robot will
carry out. in order to program a robot’s behavior, children must understand in general that people use symbolic language to
communicate with computers, and they must select specific instructions to accurately represent their intended outcome for the robot’s
behavior.
correspondence was first introduced in lesson 3 of the curriculum, when students choose and sequence programming instructions to
make a robot dance the hokey-pokey. accomplishing this task requires children to identify the corresponding programming instruction for
each line of the “robot hokey-pokey” verse/dance. for example, a child who understands the correspondence between actions and instructions would find the programming instruction block with the “shake” symbol to recreate the line in which the robot “shakes it all
about”. to measure correspondence, children were assessed on how many of the correct instructions they chose.
2.3.3. sequencing instructions
sequencing is a component of planning, and involves putting objects or actions in the correct order (zelazo, carter, reznick, & frye, 1997).
to create a successful program, children must use procedural thinking and plan their programs in terms of a sequence of what happens next,
before, or until another action (pea & kurland, 1984). in both literacy and mathematics, sequencing is essential: for putting phonemes, letters,
words, or elements of a formula in the appropriate order (neuman & dickinson, 2002). prior research with the tangiblek project showed
that children who participated in the program earned significantly higher scores on a test of story sequencing than children who did not
(kazakoff & bers, 2012; kazakoff, sullivan, & bers, 2012).
in this curriculum, children were first introduced to the idea of sequencing instructions in lesson 3’s “hokey-pokey” challenge (described
above). sequencing was also a core component of lessons 4–6, in which children had to properly arrange action instructions and
increasingly complex control flow instructions in the correct order to achieve particular outcomes in the robot’s behavior.
2.3.4. use of control flow instructions
“control flow” refers to the concept that programmers can control the order in which a robot follows the instructions in its program
through various programmatic methods. this curriculum introduced children to control flow instructions and parameters. control flow
instructions allow the robot to carry out instructions non-sequentially, e.g., in a loop, or only under certain conditions. for example, a
cherp program can include a “repeat” control flow instruction in the following way: “begin, forward, repeat 3 shake, end-repeat,
sing, end”, to make the robot shake three times and then sing once. with the attachment of a light or touch sensor to the robot,
sensor parameters can also be used to qualify the control flow instructions based on environmental stimuli. for instance, a child can
program a robot to carry out an action or set of actions only “if (the environment is) dark” or “if light”, and another set of actions “if not
(light/dark)”. while there are currently no curriculum frameworks explicitly addressing control flow, these activities connect to
mathematics, by reinforcing number sense and estimation, or to natural science, by comparing human and animal sensory functions
with robot sensors. children are also able to compare and contrast repeating or looping programs to patterns, cyclical events in the
natural world, and calendar time. children were assessed on their correct use of control flow structures in lessons 4–6 and the final
project.
3. results
this section presents and compares children’s achievement on programming and debugging concepts and other skills taught using the
tangiblek robotics curriculum. since the focus of this work is on computational thinking in a robotic context, the assessments presented
here evaluate programming concepts instead of robotics knowledge. children’s work in each introductory lesson was assessed for two
relevant programming concepts. these concepts, seven in total, were reassessed in the final project. additionally, four debugging skills were
assessed in all lessons and the final project. each measure uses the likert scale shown above, which ranges from 0 (did not attempt the task)
or 1 (did not complete the goal, task, or understanding) to 5 (completely achieved the goal, task, or understanding). analysis was conducted
by aggregating scores from all classrooms and using paired-sample t-tests to compare scores on each concept from one lesson to the next.
findings are grouped by the powerful idea to which they relate. note that the teacher in classroom 1 chose not to formally teach activity 6,
so data for that activity’s items come only from two classrooms. a discussion about this choice is provided later in the paper.
3.1. debugging
average scores on the various debugging measures fell in the range of partial to mostly complete understanding and application of the
skill (see table 1). there was little variation in debugging scores between consecutive activities (see fig. 1), with the exception that the
average score on keeping the original goal was higher in activity 4 than in activity 5 (marked in table 1). in other words, children’s ability to
keep working on the original goal (or choose an acceptable alternative) was higher in activities that did not require the use of sensors and
sensor parameters. scores on the other three components of debugging remained steady in the mid-to-upper range of the achievement
scale across lessons.
150 m.u. bers et al. / computers & education 72 (2014) 145–157
repeated measures anova analyses (see table 2) were run for the four debugging skill variables across activities. the analyses were run
across all seven activities (or in the case of debugging skill 1, across the four activities where this skill was assessed). in addition, a separate
repeated measures anova was run for each debugging skill variable for just activities 1–5 since once classroom did not participate in lesson
6 and the project lesson was unstructured.
average debugging score did not vary significantly across activities when all lessons were considered. however, when removing the
challenge activity and lesson 6 where one class did not participate, a repeated measures anova for each debugging variable did show a
change across time, meaning there was, perhaps variation in debugging score across the more structure lessons, but, this variation averaged
out when children worked on their own projects.
3.2. powerful ideas of programming
in activities 3 through 6 and in the culminating project, students completed specific programming challenges and were assessed on their
ability to select instructions and put them in the order that would result in the goal behavior for the robot. activities 4–6 also used special
“control flow” instructions, which can tell the robot to loop through a set of actions repeatedly or to follow one “branch” of instructions or
another based on sensor data.
3.2.1. choosing the correct programming instructions
the overall mean score on students’ abilities to choose the correct instructions started off high in activity 3. scores then dropped, on
average, over activities 4 through 6, and returned to starting levels in the project (see table 3 for detailed means). as mean scores fell to
statistically significantly lower levels in activity 4 and again in activity 5, the percent of students reaching the target level of achievement
also dropped. seventy-six percent of students achieved in the target range on choosing programming instructions in activity 3, which used
only action instructions. in activity 4, which introduced the first of the control flow instructions, 70% of children achieved the target level, as
did only 46% in activity 5, which added the use of sensors and sensor parameters, and 62% in activity 6, which used a second, more
challenging type of control flow instruction. however, 77% of children reached the target level of achievement on their projects – a similar
rate to that in lesson 3, the first activity to require choosing programming instructions (see fig. 2).
3.2.2. control flow by sequencing
sequencing ability was also introduced in activity 3, along with making correspondences between intended robotic actions and programming instructions, when children made their robots dance the “hokey-pokey”. three-quarters of all students achieved in the target
range in this first programming activity. sequencing was also a core component of activities 4–6, in which children had to properly arrange
table 1
student scores on debugging.
debugging step 1 debugging step 2 debugging step 3 debugging step 4
n mean sd n mean sd n mean sd n mean sd
activity 1 43 4.19 0.98 45 4.22 0.80 42 4.00 1.08 43 4.16 1.05
activity 2 48 4.35 0.76 49 4.16 0.87 46 3.76 0.97 46 3.91 1.00
activity 3 31 3.97 1.11 39 4.21 0.95 33 3.67 1.27 34 3.77 1.28
activity 4 43 3.93 1.26 44 3.87* 1.23 43 3.46 1.32 43 3.72 1.30
activity 5 30 3.53 1.17 36 3.50* 1.23 27 3.22 1.19 30 3.50* 1.23
activity 6 27 3.44 1.25 28 3.89 1.23 26 2.96 1.28 27 3.41 1.42
project 28 3.97 0.92 29 4.42* 0.64 27 3.93 0.92 26 4.08* 0.69
note. classroom 1 did not do activity 6.
*denotes significant differences in the mean scores of the paired items at the p < 0.05 level. for debugging step 2 between activities 4 and 5, t(28) ¼ 2.04 and p ¼ 0.05. for
debugging step 2 between activity 5 (the last activity completed by all classes) and the project, t(19) ¼ 3.12 and p ¼ 0.01. for debugging step 4 from activity 5 to the project,
t(15) ¼ 2.55 and p ¼ 0.02.
fig. 1. mean achievement on debugging across activities. average debugging scores for each activity and project. all four debugging components appear to follow a similar trend,
but only the scores for keeping the original goal and attempting to solve the problem had statistically significant changes.
m.u. bers et al. / computers & education 72 (2014) 145–157 151
both actions and increasingly complex control flow instructions in the correct order. in these activities, 59%, 53%, and 68% of children,
respectively, achieved at the target level. fewer children were able to reach the target level of achievement for sequencing in these activities
than in activity 3. a comparison of mean scores on sequencing from one activity to the next revealed a statistically significant drop between
activities 3 and 4, differentiating programs with actions only from those requiring two-part control instructions as well (see table 4). as was
seen with correspondence scores, the average sequencing score on children’s projects was statistically significantly higher than the average
score in activity 5 (see fig. 2).
3.2.3. control flow by special instructions
activities 4–6 each introduced a new control flow instruction for creating looping or branching programs. students, on average, achieved
a “partially” complete understanding of the concepts (see table 5 for detailed means). less than 60% of students reached the target (“mostly”
complete) level of understanding on all but one of these measures. (this degree of understanding was reached by 53% for looping, 60% for
numeric parameters, 54% for sensor parameters, 68% for the first half of the conditional statement, and 41% for the second half of the
conditional statement.)
there were no differences in average scores found between looping and conditional instructions or comparing the different types of
parameters (see fig. 3). the only statistically significant difference in scores was between the two parts of the conditional statement (“if”
versus “if not”). that is, children were, on average, more comfortable making the programming equivalent of the statement “if it’s dark out,
turn the light on” and less comfortable appending “if not, turn the light off” to that first statement.
3.3. comparison of concepts between activities and projects
differences in children’s achievement on each of the above concepts from the introductory activities to the culminating projects were
examined in two ways. first, children’s scores from activity 5 (the last activity completed by all classes) were compared to children’s scores
on the final project. this continued the comparison of scores on consecutive activities. secondly, scores from the first activity that introduced
a particular concept were compared to corresponding scores from the final project. for example, sequencing scores from activity 3 (the first
activity using that concept) were compared to sequencing scores on the final project. this comparison was done to address how children’s
scores on the same concepts might change with time and exposure. we should note that due to the self-selected nature of the final projects,
not all children employed every concept to complete them, so n is relatively lower on these comparisons.
there were some statistically significant increases in scores from the final introductory activity completed by all classrooms to the
culminating projects were seen on two overarching programming concepts: choosing the correct instructions (see table 3) and sequencing
the instructions to accomplish the goal (see table 4), as well as on two elements of debugging (see table 1): sticking with the original goal or
choosing an acceptable alternative and taking steps to attempt to solve the problem. in fact, after these scores had dropped over the course
of the activities, they returned to starting levels in the final projects (as described in the relevant sections above).
table 2
repeated measures anovas by debugging steps.
a repeated measures anova was conducted to see if there was a significant difference in means of debugging level over time.
all possible activities without lesson 6 or project
df f p df f p
debugging step 1
sphericity assumed (4, 16) 1.559 0.23 (2, 50) 5.122 0.01**
debugging step 2
greenhouse-geisser correction (2, 4) 5.740 0.07 (3, 68) 5.157 0.00**
debugging step 3
greenhouse-geisser correction (2, 4) 4.586 0.10
sphericity assumed (4, 84) 9.192 0.00**
debugging step 4
greenhouse-geisser correction (1, 3) 2.682 0.23
sphericity assumed (4, 88) 6.404 0.00**
notes. classroom 1 did not do activity 6. the project was open-ended (children could choose to use less difficult blocks).
**denotes significance at the p < 0.01 level.
table 3
student scores on selecting programming instructions.
selecting instructions comparison to subsequent activity
n mean sd activity df t p
activity 3 45 4.24 1.07 – –– –
activity 4 50 3.88 1.04 3 42 2.47 .02*
activity 5 41 3.34 1.20 4 38 2.77 .01**
activity 6 34 3.65 1.30 5 25 0.73 0.47
project 48 4.15 0.92 6 29 1.19 0.25
5a 35 3.12 .00**
note. classroom 1 did not do activity 6.
**denotes significance at the p < 0.01 level; *denotes significance at the p < 0.05 level. a this comparison was made as an alternative to the activity 6-to-project comparison as it was the last activity completed by all three classrooms prior to the project.
152 m.u. bers et al. / computers & education 72 (2014) 145–157
it was anticipated that the children’s scores on the same concepts might increase with exposure, so comparisons were made between
children’s score on a concept in the activity that introduced it and the score on that same concept in the final project. however, there were
no statistically significant differences seen in any such comparisons (see table 6).
in summary, many children in each class reached the target level of achievement on the programming tasks over the course of the
curriculum’s six activities and culminating project. in the first three activities, which introduced the engineering design process, robotics,
and programming, children’s levels of achievement were particularly high (75%, on average, reaching target level of achievement). in activities 4–6, which introduced more sophisticated concepts and programming instructions, fewer children (56%, on average) attained the
same level of understanding.
many children achieved high scores on properly selecting and sequencing instructions when the programming activities involved only
action instructions (w75% for both skills) and in the final projects. achievement was comparatively lower in activities which involved the
conceptually and functionally more complicated control flow instructions and/or sensors (59% for both skills). programs that use special
control flow instructions visually appear linear, but the robot does not carry out one action per programming block, as it does with a
program containing only actions instructions; the logical flow of the program may be a loop or forked path rather than a line. this introduces
a conceptual complexity to programming with control flow instructions that does not exist with action instructions alone. similarly, it
appears based on relative scores that using the “if” instruction was simpler than using the “if not” instruction (68% versus 41% target
achievement). the complexity of each programming concept appears to be reflected in the portion of students who reached target levels of
understanding.
4. discussion
the results provide critical information on the accessibility of selected concepts from the fields of robotics and computer science for
kindergarten children, adding clarity to developmentally appropriate learning expectations in order to revise and improve both the
curricular activities and design features for early childhood robotics and programming technologies. the results also shed light on some of
the challenges of conducting design-based research in a classroom setting.
one interesting feature of the results is the trend of decreasing achievement scores across lessons 3–6. this is possibly related to
the amount of time spent on each topic. each activity in the curriculum introduced a progressively more challenging concept
than the activity before it. in the later lessons, children were asked to build on concepts they had only recently learned. while
each lesson was carefully designed to teach a particular topic and provide a space for exploration of it, these concepts may not
have been fully ingrained or mastered yet while new material was introduced. this could also help explain lower scores in the later
lessons.
another interesting result relates to the several concepts for which children’s average achievement scores increased from the final
introductory lesson to the culminating project. with statistical significance, children averaged higher scores on choosing and sequencing
fig. 2. mean achievement on choosing and sequencing instructions average scores for choosing and sequencing programming instructions according to the goal. the dip on both
choosing instructions (marked with *) and sequencing them (marked with þ) at activity 5 represents significantly lower scores as compared to activity 4 and the project. the drop
in score for choosing instructions at activity 4 is also statistically significant.
table 4
student scores on using sequencing for control flow.
sequencing instructions comparison to subsequent activity
n mean sd activity df t p
activity 3 49 4.23 1.16 – –– –
activity 4 40 3.69 1.14 3 41 2.79 .01**
activity 5 40 3.50 1.20 4 38 1.07 0.30
activity 6 34 3.74 1.19 5 25 0.53 0.60
project 49 4.08 1.04 6 30 0.25 0.80
5a 35 2.14 .04*
note. classroom 1 did not do activity 6.
**denotes significance at the p < 0.01 level; *denotes significance at the p < 0.05 level. a this comparison was made as an alternative to the activity 6-to-project comparison as it was the last activity completed by all three classrooms prior to the project.
m.u. bers et al. / computers & education 72 (2014) 145–157 153
instructions during the final project than in any introductory activity except the first (and simplest) programming activity. while assistant
from adults remained stable throughout all aspects of the curriculum and final projects, some other circumstances were different in the
project compared to the lessons. the improved scores might be attributed to the fact that children had more enthusiasm for these
personally-selected projects that would soon be part of a show-and-tell celebration as well as more time to experiment at their own pace
than in the lessons. alternatively, assuming children chose projects well-matched to their level of expertise, it would be reasonable to expect
higher demonstrated levels of achievement as their projects likely focused on concepts children already felt more comfortable using.
however, there were no statistically significant differences seen in comparisons of control flow instruction and sensor-related measures
between the activity that introduced each concept and the culminating project. it is possible that even more time exploring these concepts
was needed for significant learning gains to occur.
surprisingly, children did not always perform better on simpler concepts than on more complex ones. for example, the lack
of statistically significant differences between children’s understanding of looping versus conditional programs and between numeric
versus sensor parameters is unexpected both theoretically and based on anecdotal observations of these activities by researchers
present during the activities. the concepts associated with looping and numeric parameters should, in principle, be more straightforward than those involved in programming with conditional statements and sensor parameters. thus, at least somewhat higher
levels of achievement on looping and numeric parameters had been expected compared to conditional statements and sensor
parameters.
in some of the comparisons described above, the low n (less than half the overall study sample size) may have impacted the results. the
statistically significant findings may have varied if, for instance, the students for whom researchers could not collect data tended to have
above- or below-average achievement levels. as the activities in the curriculum increased in difficulty, the research assistants tended to
provide increased support for children with questions, leaving less time to equally observe and assess all children. in fact, it was also
observed that some children who perceived an activity to be difficult refrained from attempting it, resulting in no achievement scores for
that activity and a lower n on those measures.
4.1. curriculum discussion
while it is beyond the scope of this paper to fully evaluate the tangiblek robotics curriculum, results indicate that the curriculum was
generally engaging and developmentally appropriate for kindergarten students. results point to kindergarten teachers being able to
effectively implement the curriculum and to kindergartners being both interested in and able to learn and apply many aspects of robotics,
programming, and computational thinking. however, the fact that fewer children achieved the target level of understanding on more
complex topics than on the introductory concepts might indicate that the curriculum should devote more time for children to build up to
and fully explore the complex material in order to fully understand it. in order to test this, a new iteration of the curriculum is currently
table 5
student scores on using special instructions for control flow.
control flow instructions comparison to analogous concept
n mean sd concept df t p
looping instruction 49 3.61 1.17 – –– –
numeric parameters 50 3.76 1.17 – –– –
sensor parameters 41 3.59 1.12 numeric parameters 38 0.87 0.42
conditional (if) 34 3.74 1.24 looping instruction 31 0.00 1.00
conditional (if not) 22 3.32 1.21 conditional (if) 20 2.17 .04*
looping instruction 19 0.65 0.53
note. classroom 1 did not use conditional statements.
*denotes a statistically significant difference at the p < 0.05 level.
fig. 3. mean achievement on control flow concepts. a comparison of average scores for the different types of control flow instructions and parameters. the only significant difference in scores was between the two conditional instructions (marked with *).
154 m.u. bers et al. / computers & education 72 (2014) 145–157
being developed that will divide the prior curriculum based on action and sensing, and expand the number of lessons and amount of time
spent exploring each topic (particularly the more complex ones) in both structured and free-play-based formats to provide further opportunities for students’ investigation of concepts and to reinforce their learning. additional supporting activities will also be added.
kindergarteners vary widely in their levels of cognitive development and learning abilities, and such adaptations to the tangiblek curriculum may address this range even more than the current format already does.
the results also demonstrate the complexity of assessing sophisticated learning processes in a classroom setting. there was a necessary
trade-off built into the study design: gathering an adequately detailed picture of children’s learning had to be balanced with keeping data
collection feasible given that each adult was working with several children in the context of a full classroom. in some cases (particularly the
later activities), a different setting, such as individual-child sessions, may have provided a better context for some students to demonstrate
their abilities. however, the goal of the study was to examine the tangiblek program in a typical kindergarten classroom, and this endeavor
was successful. although ultimately some data could not be collected from every student on every measure, information was gathered about
the reality of implementing the curriculum in classroom settings and the supports necessary to meet the needs of all students.
4.2. limitations of the study and future directions
the tangiblek curriculum was taught during regular school hours in three schools in the greater boston area. there were both benefits
and drawbacks to conducting research in a school setting rather than an experimental setting. by testing the curriculum as taught by
kindergarten teachers, in both public and private schools, we have demonstrated that, given professional development in robotics education, a dedicated teacher can successfully teach this content in her or his own classroom. however, as with any study that takes place in a
school setting, the present study faced several environmental limitations. while each of the participating teachers taught the same curriculum, it is impossible to control for all teacher, classroom, and school variations that may have influenced results. for example, the three
teachers in this study were very different from one another. while some teachers allowed their class to work through difficult concepts on
their own, others gave more step-by-step instructions. teachers were given leeway to teach the curriculum in whatever way they believed
best suited the needs of their classrooms, however, this causes methodological issues for data analysis. further research should be conducted with a focus on how teaching styles and classroom culture serve to enhance or hinder a robotics curriculum.
fig. 4. an illustration of the engineering design process.
table 6
students scores on concepts in culmination project.
project scores comparison to introductory activity
n mean sd % scoring 4þ activity df t p
choosing instructions 48 4.15 0.92 77.0 3 40 0.70 0.49
sequencing 49 4.08 1.04 73.5 3 40 0.78 0.44
repeats 40 3.75 1.26 62.5 4 36 0.77 0.45
numeric parameters 32 3.94 1.22 65.6 4 30 0.77 0.45
sensors 18 4.05 0.73 83.4 5 15 0.94 0.36
sensor parameters 20 3.90 0.85 70.0 5 17 0.36 0.73
ifsa 14 3.57 0.80 78.6 6 (if) 13 0.27 0.79
note. classroom 1 did not do activity 6. a there was no separate measure for using “if not” instructions in the projects.
m.u. bers et al. / computers & education 72 (2014) 145–157 155
another drawback the study encountered was a fluctuating number of daily participants. children were fairly regularly absent,
temporarily out of the classroom, or otherwise unable to participate in the class. other times, the busy classroom and divided adult attention
prevented assessments from being collected for all children, particularly if an assessment required long and sustained periods of observation. teacher differences also impacted the low number of participants in some activities. for example, one teacher chose not to teach
lesson 6 in order to have more time to review previous concepts before the final project, drastically lowering the n for that lesson. further
research should be done expanding the scope of this study by gathering more participants and, if possible, ensuring more consistent
completion of each activity.
the present study inspires additional research agendas. while the focus of this work is on kindergartners, further investigations should
look at the way younger (prek-k) and older (1st–2nd grade) students are able to learn and apply the same powerful ideas. it would be
important to determine whether some of the concepts that were particularly challenging to the kindergartners in this study pose less of a
challenge with longer exposure or if introduced when children are older. further research will also expand the overall sample size as well as
the age and experience range of the sample. other work should attempt to assess the feasibility of implementing this curriculum for a
classroom teacher with typical support staff, that is, with minimal involvement of research assistants except for training teachers and
conducting data collection. in the present research, participating teachers each had about three trained assistants in the classroom to help
troubleshoot technology issues, assess the children’s progress, and provide one-on-one help as needed. for this curriculum to become
widespread, it will be necessary to know more about what supports teachers need (modifications to the curriculum, classroom management
alternatives, additional adult support, etc.) to successfully implement the curriculum. finally, it is beyond the scope of this current study, but
a follow-up study could look at longitudinal or transfer effects of the tangiblek curriculum. what concepts do the students retain? how is
computational thinking having an impact in other areas of their academic and extra-curricular lives? are children able to apply the engineering design process to other subject areas after completing this curriculum? further research should look at the long-term benefits of
incorporating programming and robotics into early childhood education.
it is important to note that many of the challenges that arose as part of the present study were posed by the robotics hardware itself, and
not the curricular activities. this highlights the importance of making developmentally appropriate hardware and software specifically
designed for young children. results show that for the children in this study, correctly connecting robotic parts proved more challenging
than understanding the function of each part or the underlying computational concept. this result is not surprising since the cherp
programming interface and the curricular activities introducing the robot’s parts and their purposes were specifically developed for kindergartners as part of this research project, while the robotics kit hardware was designed for older children as part of a commercially
available lego product. furthermore, children spent a significant amount of time fixing their robots, which came apart frequently. it was
challenging for many children to assemble some of the pieces on their own, and they needed adult help. if children had spent the robot
repair time working on their computer programs instead (and if teachers were able to spend that time providing support for learning the
central concepts rather than helping re-build robots), perhaps children would have attained higher levels of achievement in their understanding of complex powerful ideas involved in computational thinking.
the findings from this study have informed the tangiblek project, in which early childhood teachers (pre-kindergarten through 2nd
grade) will systematically implement a robotics curriculum revised according to several of the points outlined above. the teachers will
document their experiences and their students’ learning outcomes over the course of a school year using kiwi, a developmentally
appropriate robotics hardware that will replace the lego hardware used in this current study.
despite the limitations of the study described in this paper, post-study data collected from the teachers speaks to the success of the
tangiblek robotics program. all the teachers said they would participate in tangiblek again if given the chance. along with the general
success and enthusiasm of the children, this feedback highlights the overall positive and educational nature of the experience.
5. conclusion
the early childhood classroom is not typically a place where we expect to find students programming robots. yet, with the availability of
developmentally appropriate technologies, this is increasingly possible, and the result may be the advancement of technological fluency in
our nation’s youth. this paper explored the tangiblek robotics program as a viable option for classroom teachers to integrate developmentally appropriate technology education into the early childhood classroom.
with cherp, children spend their time building a robot, planning its actions, using physical wooden block or the computer screen to
construct programs, and iteratively improving the robot and programs according to initial goals and subsequent discoveries. because the
tangible programs and robots exist off-screen, children are drawn to investigate the work of other children, work collaboratively, and
negotiate sharing materials, as well as develop their fine-motor skills. these artifacts serve as points of discussion and reminders of the
activity content even after the computer has been turned off. as the analysis presented in this paper has explored, in this rich process of
creation in both the physical and digital worlds, children actively engage in problem-solving and learn powerful ideas from computer
science and robotics, including core concepts of computational thinking.
research is essential to understanding the impact of new technologies on the development of children and how children are using and
could be using these tools. as parents, educators, policymakers, and researchers it is our responsibility to ensure our children receive the
technological education needed for healthy development and a successful future. the tangiblek robotics program introduced in this paper
shows that when given age-appropriate technologies, curriculum and pedagogies, young children can actively engage in learning from
computer programming as applied to the field of robotics. they can then take their first steps into developing computational thinking.
acknowledgments
the tangiblek project was supported by national science foundation (nsf) drl-0735657. any opinions, findings, and conclusions or
recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the national science
foundation.
the authors would like to thank participating schools and teachers for their commitment to and participation in this project.
156 m.u. bers et al. / computers & education 72 (2014) 145–157
references
barron, b., cayton-hodges, g., bofferding, l., copple, c., darling-hammond, l., & levine, m. (2011). take a giant step: a blueprint for teaching children in a digital age. new york:
the joan ganz cooney center at sesame workshop.
barr, v., & stephenson, c. (2011). bringing computational thinking to k-12: what is involved and what is the role of the computer science education community? acm inroads,
2(1), 48–54. http://dx.doi.org/10.1145/1929887.1929905.
bers, m. u. (2008). blocks, robots and computers: learning about technology in early childhood. new york: teacher’s college press.
bers, m. u. (2010). beyond computer literacy: supporting youth’s positive development through technology. new directions for youth development, 128, 13–23.
bers, m. u. (2012). designing digital experiences for positive youth development: from playpen to playground. oxford university press.
bers, m. u., & horn, m. s. (2010). tangible programming in early childhood: revisiting developmental assumptions through new technologies. in i. r. berson, & m. j. berson
(eds.), high-tech tots: childhood in a digital world (pp. 49–70). greenwich, ct: information age publishing.
bers, m. u., ponte, i., juelich, k., viera, a., & schenker, j. (2002). teachers as designers: integrating robotics into early childhood education. information technology in childhood
education.
cejka, e., rogers, c., & portsmore, m. (2006). kindergarten robotics: using robotics to motivate math, science, and engineering literacy in elementary school. international
journal of engineering education, 22(4), 711–722.
clements, d. h., & gullo, d. f. (1984). effects of computer programming on young children’s cognition. journal of educational psychology, 76(6), 1051–1058. http://dx.doi.org/
10.1037/0022-0663.76.6.1051.
clements, d. h., & meredith, j. s. (1992). research on logo: effects and efficacy. retrieved from http://el.media.mit.edu/logo-foundation/pubs/papers/research_logo.html.
cobb, p., confrey, j., disessa, a., lehrer, r., & schauble, l. (2003). design experiments in educational research. educational researcher, 32(1), 9–13.
gelman, r., & brenneman, k. (2004). science learning pathways for young children. early childhood research quarterly (special issue on early learning in math and science),
19(1), 150–158.
horn, m. s., davis, p., hubbard, a., keifert, d., leong, z. a., & olson, i. c. (june 2011). learning sustainability: children, learning, and the next generation eco-feedback
technology. in proc. 10th international conference on interaction design and children (short paper). ann arbor, mi.
international society for technology in education. (2007). nets for students 2007 profiles. washington, dc: iste. retrieved from www.iste.org/standards/nets-for-students/
nets-for-students-2007-profiles.aspx#pk-2.
international society for technology in education and the computer science teachers association. (2011). operational definition of computational thinking for k-12 thinkingoperational-definition-flyer.pdf. international society for technology in education and the computer science teachers association.
kazakoff, e., & bers, m. (2012). programming in a robotics context in the kindergarten classroom: the impact on sequencing skills. journal of educational multimedia and
hypermedia, 21(4), 371–391.
kazakoff, e., sullivan, a., & bers, m. (2012). the effect of a classroom-based intensive robotics and programming workshop on sequencing ability in early childhood. early
childhood education journal, 41(4), 245–255.
klahr, d., & carver, s. (1988). cognitive objectives in a logo debugging curriculum: instruction, learning, and transfer. cognitive psychology, 20, 362–404.
lee, i., martin, f., denner, j., coulter, b., allan, w., erickson, j., et al. (2011). computational thinking for youth in practice. acm inroads, 2(1), 32–37.
massachusetts department of education. (2006). massachusetts science and technology/engineering curriculum framework. retrieved from. massachusetts department of
education http://www.doe.mass.edu/frameworks/scitech/1006.pdf.
naeyc & fred rogers center for early learning and children’s media. (2012). technology and interactive media as tools in early childhood programs serving children from birth
through age 8. joint position statement. washington, dc: naeyc. latrobe, pa: fred rogers center for early learning at saint vincent college. retrieved from www.naeyc.
org/files/naeyc/file/positions/ps_technology_web2.pdf.
neuman, s. b., & dickinson, d. k. (eds.). (2002). handbook of early literacy research. new york: guilford press.
papert, s. (1980). mindstorms. children, computers and powerful ideas. new york: basic books.
papert, s. (2000). what’s the big idea? toward a pedagogy of idea power. ibm systems journal, 39(3 & 4), 720–729. http://dx.doi.org/10.1147/sj.393.0720.
pea, r. d., & kurland, d. m. (1984). on the cognitive effects of learning computer programming. new ideas in psychology, 2(2), 137–168. http://dx.doi.org/10.1016/0732-
118x(84)90018-7.
perlman, r. (1976). using computer technology to provide a creative learning environment for preschool children. logo memo no 24. cambridge, ma: mit artificial intelligence
laboratory publications.
piaget, j. (1954). the construction of reality in the child. new york: basic books.
resnick, m. (2003). playful learning and creative societies. education update, 8(6). retrieved from http://web.media.mit.edu/wmres/papers/education-update.pdf.
rogoff, b., goodman turkanis, c., & bartlett, l. (2001). learning together: children and adults in a school community. new york, ny: oxford university press.
salomon, g., & perkins, d. n. (1987). transfer of cognitive skills from programming: when and how? journal of educational computing research, 3, 149–169.
sesame workshop. (2009). sesame workshop and the pnc foundation join white house effort on stem education. retrieved from http://www.sesameworkshop.org/
newsandevents/pressreleases/stemeducation_11212009.
stair, r. m., & reynolds, g. w. (2003). principles of information systems (6th ed.). boston, ma: course technology – itp.
u.s. department of education, office of educational technology. (2010). transforming american education: learning powered by technology. washington, dc: u.s. department
of education, office of educational technology. retrieved from http://www.ed.gov/technology/netp-2010.
white house. (2011). educate to innovate. retrieved from http://www.whitehouse.gov/issues/education/educate-innovate.
wyeth, p. (2008). how young children learn to program with sensor, action, and logic blocks. international journal of the learning sciences, 17(4), 517–550.
zelazo, p. d., carter, a., reznick, j. s., & frye, d. (1997). early development of executive function: a problem-solving framework. review of general psychology, 1(2), 198–226.
zigler, e. f., & bishop-josef, s. j. (2006). the cognitive child vs. the whole child: lessons form 40 years of head start. in d. g. singer, r. m. golinkoff, & k. hirsh-pasek (eds.),
play ¼ learning: how play motivates and enhances children’s cognitive and social-emotional growth (pp. 15–35). new york, ny: oxford university press.
m.u. bers et al. / computers & education 72 (2014) 145–157 157"
"computers in human behavior xxx (xxxx) xxx
please cite this article as: charoula angeli, michail giannakos, computers in human behavior, https://doi.org/10.1016/j.chb.2019.106185
available online 1 november 2019
0747-5632/© 2019 elsevier ltd. all rights reserved.
computational thinking education: issues and challenges
article info
keywords
computational thinking
digital competences
coding
technological fluency
algorithmic thinking
robotics
abstract
computational thinking is a term applied to describe the increasing attention on students’ knowledge development about designing computational solutions to problems, algorithmic thinking, and coding. it focuses on skills
children develop from practicing programming and algorithms, and enables the development of qualities such as
abstract thinking, problem solving, pattern recognition, and logical reasoning. contemporary educational and
infrastructural developments, like “cs for all” (https://www.csforall.org/), iste’s standards for students in
computational thinking (https://www.iste.org/explore/solutions/computational-thinking-for-all?article
id¼152), computer science teachers association’s concepts of computational thinking (http://advocate.cst
eachers.org/2014/09/15/computational-thinking-and-beyond/), and the appearance of tools such as robotics,
3d printing, microprocessors, and intuitive programming languages posit computational thinking as a very
promising area to support these learning competences. in this special issue of computers in human behavior, the
editors report four studies conducted by interdisciplinary teams. the introduction to the special issue also draws
attention to the great potential and need for further research in the area of computational thinking education to
engage students in meaningful learning so as to develop useful thinking skills and digital competences. finally,
the editorspropose directions for future research and practice in computational thinking education.
1. introduction
computational thinking (ct), a term used since the 1950s, describes
the notion of using structured thinking or algorithmic thinking to produce appropriate output to a given input (denning, 2009). recent efforts
to revitalize the importance of ct aim at democratizing computing
knowledge as an important body of knowledge that learners need to
have in order to cope well with the challenges of the 21st century. in
2006, wing relaunched the term and interest in the area by defining ct
as a process that involves solving problems, designing systems, and
understanding human behavior, by drawing on the concepts fundamental to computer science (wing, 2006). this definition has been
adopted widely due to its generic nature, but also created a need for a
more specific definition that can be used in ct education (csta & iste,
2011; selby & woollard, 2014).
during the last years, there has been an increasing interest about ct
education in k-12 schools, and its role in children’s acquisition of
thinking skills and digital competences. in accordance with this need,
computational thinking and coding have, in recent years, become an
integral part of school curricula in many countries. estonia, israel,
finland, and the united kingdom are only a few examples of the growing
efforts of governments to integrate coding as a new literacy and to
support students in creative problem-solving tasks (hubwieser, giannakos, berges, brinda, diethelm, magenheim & jasute, 2015). in addition, computer science teachers association (csta, 2011),
international society for technology in education (csta & iste, 2011),
cyber innovation center (https://cyberinnovationcenter.org/), and
national math and science initiative (https://www.nms.org/) have
developed conceptual guidelines for ct education. similarly, organizations such as “codeacademy.com” offer learning environments to
promote coding activities and ct education.
while it is well accepted in the literature that ct involves a number
of skills, like problem decomposition (breaking down complex problems
to simpler ones), developing algorithms (step-by-step solutions to
problems), and abstraction, there is still limited evidence around the
several issues and challenges someone needs to be aware of in order to
design appropriate learning experiences for ct competences. in the issue
herein, the editors present four research studies covering different aspects of ct research, and, discuss challenges for both research and
practice in ct education as well as raising important new research
questions for the researchers in the field.
2. the contributions in the special issue
while ct is an area of growing significance, scholarly work on ct is
emerging, both conceptually and empirically. in response to the need for
accelerating research foundations and developments in ct education,
computers in human behavior presents a special issue that disseminates
the latest research findings. the special issue consists of four contributions addressing the topic of ct from different perspectives and disciplinary backgrounds as well as covering different research areas and
needs. the articles provide insights about: a) the importance of metaphors in ct education, b) putting into practice ct activities to empower
both girls and boys, c) the importance of employing empirical
contents lists available at sciencedirect
computers in human behavior
journal homepage: http://www.elsevier.com/locate/comphumbeh
https://doi.org/10.1016/j.chb.2019.106185 
computers in human behavior xxx (xxxx) xxx
2
experimentation in furthering ct education research and d) the development of young children’s ct skills using scaffolds and educational
robotics.
2.1. embodied metaphors for computing education
in the first article, manches, mckenna, rajendran, and robertson
(2019, this issue) investigated elementary computing concepts using
metaphors through the lens of embodied cognition. a metaphor is a
figure of speech that describes an object or action that is not literally
true, but helps to explain an idea or make a comparison. conceptual
metaphors are extremely important in learning sciences (e.g., energy
transfer, thermodynamics, and mathematics), as they offer an explanation of our ability to think and reason about abstract concepts. manches
et al.’s analysis showed that participants drew upon two overarching
embodied metaphors in their explanations, namely: a) computing constructs as physical objects, in which participants simulated manipulating
physical objects (e.g., pinching) when referring to a range of computing
concepts, and b) computing processes as motions along a path, whereby
participants moved their hands along one of three body-based axes when
referring to temporal sequences. the authors concluded that embodiment might shape students and teachers’ ct understanding and
learning. in addition, there may well be other examples of integrated
metaphors that can be used to communicate the meaning of the
construct of ct, and such representations will allow us to better support
ct teaching and learning techniques as well as the development of
technologies and interfaces (e.g., embodied interfaces and interactions)
for the teaching of ct.
2.2. the use of metaphors to introduce children to programming
the second article by p�erez-marín, hijon-neira, � bacelo, and pizarro
(2019, this issue) further expanded on this notion of using metaphors to
teach ct, within the context of computer programming. the authors put
into practice a methodology called mecoprog using metaphors, such
as, recipe/program, pantry/memory, and boxes/variables, to teach
programming following an empirical experiment with 132 primary education students between 9 and 12 years of age. their findings validated
that coupling the use of metaphors with a block-based programming
environment (e.g., scratch) has the potential to improve ct knowledge
acquisition in primary education.
2.3. learning strategies as a pathway for fostering ct
in the third study, papavlasopoulou, sharma, and giannakos (2019,
this issue) designed and evaluated a workshop for k-12 students to learn
how to code. the design and development of activities that successfully
scaffolded ct concepts and motivated both boys and girls proved to be
critical for the teaching and learning of ct skills. in this study, the goal
was to examine differences between boys and girls (if any) using
eye-tracking as an objective measure and triangulating the findings with
qualitative data coming from children’s interviews. the results of their
study showed no statistically significant difference between girls’ and
boys’ gaze and learning gain during the ct activity. interestingly, the
qualitative data showed differences in the strategies and implemented
practices during coding, and in perceptions about those ct activities.
the results provided objective evidence that female students did not lack
in competences or behavior (based on their gaze data) compared to
boys, but simply that they had a different approach/strategy during ct
activities and different perspectives about coding. thus, it’s important if
this approach is taken into consideration during the design of ct activities and assist girls in mastering ct concepts.
2.4. children’s computational thinking with educational robotics: an
interaction effect between gender and scaffolding strategy
the fourth study by angeli and valanides (2019, this issue) examined the effects of learning with bee-bot, a floor programmable robot, on
young boys’ and girls’ computational thinking. it was hypothesized that
scaffolding would play a significant role in the development of children’s computational thinking skills during learning with bee-bot,
because bee-bot does not provide a visual representation of the commands children use to program it. the two scaffolding techniques were
designed taking into consideration gender differences, anticipating that
both genders would benefit from at least one of the two techniques. the
results showed statistically significant learning gains between the initial
and final assessment of children’s computational thinking skills. also,
according to the findings, while both boys and girls benefited from the
scaffolding techniques, a statistically significant interaction effect was
detected between gender and scaffolding strategy showing that boys
benefited more from the individualistic, kinesthetic, spatially-oriented,
and manipulative-based activity with the cards, while girls benefited
more from the collaborative writing activity. the research contributes to
the body of knowledge that can be used to inform the teaching of
computational thinking skills. in addition, the study has practical significance for curriculum developers, instructional leaders, and classroom teachers, as they can use the results of this study to design
curricula and classroom activities with a focus on the broader set of
computational thinking skills, and not only coding.
3. challenges in computational thinking education: future
research directions
the findings from the studies suggest that in order to adopt ct as a
powerful educational concept, researchers need to invest further systematic research efforts in addressing several issues related to:
3.1. defining ct competencies for each school grade level or students’
developmental level
as the contributors in this special issue discussed, efforts have been
made to define competencies, guidelines, and curricula for ct (e.g.,
csta, iste). what is currently missing from the literature is how ct
skills, such as abstraction, problem decomposition, and data structures,
fig. 1. a five-step research plan for ct education.
c. angeli and m. giannakos 
computers in human behavior xxx (xxxx) xxx
3
might map to different abilities, grade level, disciplines, gender, and
educational level. thus, further work is needed in order to solve inconsistencies (denning, 2017) and to develop and validate a robust
theoretical conceptualization about the construct of ct.
3.2. the use of metaphors in teaching ct concepts efficiently and
effectively
according to manches et al. (2019, this issue) and p�erez-marín et al.
(2019, this issue) the use of learner-centered metaphors enhance students’ understanding and learning of ct concepts. while this special
issue provides preliminary evidence about the importance of metaphors
in teaching and understanding ct, more research is needed in order to
create more metaphors that can be used effectively in teaching students
and teachers about ct concepts.
3.3. the use of pedagogical strategies and technologies in teaching ct
the articles by papavlasopoulou et al. (2019, this issue) and angeli
and valanides (2019, this issue) point to the need to scaffold students’
learning during their engagement with ct activities, and, the importance of alignment between teaching activity and gender. considering
the fact that more and more student-friendly programming environments (e.g., alice, scratch, bluejay, greenfoot, kodu), hardware materials (3d printers, educational robotics) and other initiatives (e.g., code.
org, codeacademy.com) appear as means to promote ct education,
future research needs to be undertaken to investigate the interrelationship between ct skills and competencies, ct representations, ct activities, ct tools, and ct teaching practices.
3.4. teacher ct professional development
for ct education to further develop, teachers need to be systematically prepared in terms of how to design ct learning activities, how to
teach ct, how to assess ct, and how to use technologies to teach ct
concepts. thus, teacher professional development programs need to be
implemented for in-service teachers, while at the same time teacher
educators need to find ways to integrate the teaching of ct in their preservice courses for the better preparation of pre-service teachers.
3.5. assessment of ct competencies and skills
lastly, as the articles in this special issue mentioned, the assessment
of ct skills and competencies is well under-developed. thus, there is a
need for future research to identify ways about how ct can be assessed
either as a holistic measure or as an array of sub-skills within the context
of authentic problem-solving across all subjects and disciplines.
accordingly, fig. 1 presents a five-step plan about how these five
research areas can be addressed in future research studies. the five-step
plan is presented as a cycle, because it is expected that through intense
research and practice progress in each area will inform one another and
evolve over time. the first step tackles the definition of ct competencies
in order to provide a baseline and common language across different
contexts (e.g., different countries, educational levels, school subjects,
disciplines, etc.) about the concept of ct. the next step is that of creating
powerful metaphors as a mechanism for transforming abstract ct concepts to more concrete and easier notions to understand. the third step is
to research the effectiveness of pedagogies and technologies in
enhancing and enabling the development of ct competencies. the
fourth step focuses on the crucial issue of preparing teachers and instructors to teach ct as well as integrate appropriate technological tools
to enable the teaching of ct in their respective teaching contexts. lastly,
the fifth step deals with the measurement and assessment of ct competencies, an area of research that is currently in its infancy.
acknowledgements
we would like to thank the reviewers of this special issue for their
timely reviews, and the commissioning editor of computers in human
behavior paul a. kirschner for his ongoing support and guidance during
the preparation of the special issue. this work was partly supported by
the comnplay-science project, under the european commission’s
horizon 2020 swafs-11-2017 program (project number: 787476).
references
angeli, c., & valanides, n. (2019). developing young children’s computational thinking
with educational robotics: an interaction effect between gender and scaffolding
strategy. computers in human behavior.
csta & iste. (2011). operational definition of computational thinking for k-12 education. available at: https://id.iste.org/docs/ct-documents/computational-thinkingoperational-definition-flyer.pdf.
csta. (2011). operational definition of computational thinking. available at:
http://www.csta.acm.org/curriculum/sub/currfiles/compthinkingflyer.pdf.
denning, p. j. (2009). beyond computational thinking. communications of the acm, 52
(6), 28–30.
denning, p. j. (2017). remaining trouble spots with computational thinking. communications of the acm, 60(6), 33–39.
hubwieser, p., giannakos, m. n., berges, m., brinda, t., diethelm, i., magenheim, j., …
jasute, e. (2015). july). a global snapshot of computer science education in k-12
schools. in proceedings of the 2015 iticse on working group reports (pp. 65–83). acm.
manches, a., mckenna, p. e., rajendran, g., & robertson, j. (2019). identifying
embodied metaphors for computing education. computers in human behavior.
papavlasopoulou, s., sharma, k., & giannakos, m. (2019). coding activities for children:
coupling eye-tracking with qualitative data to investigate gender differences. computers in human behavior.
p�erez-marín, d., hijon-neira, � r., bacelo, a., & pizarro, c. (2019). can computational
thinking be improved by using a methodology based on metaphors and scratch to
teach computer programming to children? computers in human behavior.
selby, c., & woollard, j. (2014). computational thinking: the developing definitions. in
proceedings of the 45th acm technical symposium on computer science education,
sigcse 2014. acm.
wing, j. m. (2006). computational thinking. communications of the acm, 49(3), 33–35.
charoula angeli*
university of cyprus, cyprus
michail giannakos
norwegian university of science and technology, norway
* corresponding author.
e-mail address: cangeli@ucy.ac.cy (c. angeli).
c. angeli and m. giannakos "
"20 learning & leading with technology | march/april 2011
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
by david barr, john harrison, and leslie conery
agroup of high school students
cluster around a computer
looking at a series of graphs
and charts on the screen and talking
quietly but intently. they are collaborating with a group of students in
south america using skype. together
they have gathered data and created
a model depicting the rate of deforestation of the rain forests around the
world. today they are discussing the
changes they need to make to their
data representation and algorithm
before running their simulation.
these students are engaged in what
is called computational thinking.
what is computational thinking?
in a seminal article published in 2006,
jeanette wing described computational thinking (ct) as a way of “solving problems, designing systems, and
understanding human behavior by
drawing on the concepts fundamental
to computer science.” she noted that
computational thinking involves some
familiar concepts, such as problem
decomposition, data representation,
and modeling, as well as less familiar
ideas, such as binary search, recursion, and parallelization. she also
argued that “computational thinking
is a fundamental skill for everyone,
not just for computer scientists. to
reading, writing, and arithmetic, we
should add computational thinking to
every child’s analytical ability.”
wing’s article gave rise to an often
controversial discussion and debate
among computer scientists, cognitive
researchers, and educators regarding
the nature, definition, and application of ct. while many people have
proposed revisions and refinements
to wing’s original description, so
far no single, widely accepted definition of computational thinking has
emerged. as a result, pk–12 educators who recognize the importance
of ct and want to help students acquire these skills have lacked a clear
and practical definition to guide
their work.
how can we make ct accessible?
in 2009, the national science foundation (nsf) funded a project titled
leveraging thought leadership for
computational thinking in pk–12.
led jointly by iste and the computer science teachers association
(csta), the project is intended to
make the concepts of computational
thinking accessible to educators by
providing an operational definition,
a shared vocabulary, and relevant,
age-appropriate examples of computational thinking tied to current
educational objectives and classroom
practices.
a year ago, the project convened a diverse group of educators with an interest
in ct from higher education, pk–12,
and industry to help define a common
language surrounding computational
thinking, articulate the challenges and
opportunities of integrating it throughout pk–12 education, and identify the
most promising practices and strategies
for moving computational thinking
from concept to deep integration.
from that meeting a consensus
emerged regarding the essential elements
of ct, its importance as a learning objective for all students, and how it might be
introduced into the pk–12 educational
environment. the outcomes of the meeting were summarized and synthesized
into a tentative “operational definition” of
ct—that is, a description of its components that educators can use to build ct
skills across the curriculum through all
©i
grade levels and content areas.
stockphoto.com/drafter123
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
learn more
to learn more about how to teach the concepts and vocabulary of computational
thinking in pk–12 classrooms, please visit iste.org/computational-thinking or the
csta website at http://csta.acm.org. check back in a few months to find curriculm
resources, vocabulary tools, and a toolkit for leaders.
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
march/april 2011 | learning & leading with technology 21
computational thinking is a problemsolving process that includes:
• formulating problems in a way that
enables us to use a computer and
other tools to help solve them
• logically organizing and analyzing
data
• representing data through abstractions, such as models and simulations
• automating solutions through algorithmic thinking (a series of ordered
steps)
• identifying, analyzing, and implementing possible solutions with the
goal of achieving the most efficient
and effective combination of steps
and resources
• generalizing and transferring this
problem-solving process to a wide
variety of problems
these skills are supported and enhanced by a number of dispositions or
attitudes that are essential dimensions
of ct, including:
• confidence in dealing with complexity
• persistence in working with
difficult problems
• tolerance for ambiguity
• the ability to deal with openended problems
• the ability to communicate and
work with others to achieve a
common goal or solution
more than 82% of the 697 respondents agreed or strongly agreed that
this definition captured the essential
elements of ct. an additional 9%
confirmed that the definition would
do as a means to build consensus in
the pk–12 community. on the basis
of this survey and feedback from
educators gathered through conference presentations and other informal data collection, project leaders
have begun implementing the next
phase of the project, which involves
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
22 learning & leading with technology | march/april 2011
ms. lee’s seventh grade
class is looking at a series of
diagrams her students have
created to portray floor plans
of their school and homes.
in the diagrams, each room is
labeled as a node and each
pathway out of the building is
labeled as a route. students are
discussing the options for escape
routes in the event of a fire. as
the students and ms. lee look
over the diagrams, you hear a
conversation among the students
describing how the diagrams are
an abstraction of the actual rooms
in a home or school building that
enables them to represent all the
possible escape routes.
the students are
preparing to create an
algorithm to calculate
the safest and fastest
routes from the
buildings.
developing examples of what ct
skills look like in the classroom as
well as assembling resources to support and guide the implementation
of computational thinking concepts
in pk–12 education.
how is ct different?
many of the concepts, skills, and dispositions listed in this operational definition are not new. so how is computational thinking different from critical
thinking or mathematical thinking?
this question has given rise to much
debate but, as yet, no widely accepted
consensus. the participants in the
workshops sponsored by the iste/
csta project proposed that ct differs
from critical thinking and mathematical thinking because:
ms. martinez’s sixth grade social
studies class is studying the
roman empire. students will
compare events in an ancient
roman child’s life to their own life
experience by writing responses
on the ancient roman life blog.
they will also identify the lifestyle
of ancient roman children and
compare it to their own. the
teacher calls attention to the
vocabulary of “modeling” and
“simulation” and asks students to
reflect on other activities in which
they have used these concepts
and skills. she also asks them
to reflect on where they might
use them in the future, including
their careers. these students
are learning the computational
thinking concepts of representing
data through abstractions, such
as models and simulation, and
logically organizing and analyzing
data. they are also exploring
ways of transferring these skills to
other contexts.
mr. butler’s fifth
grade music class
has been studying
the diatonic scale
and the concept
of pitch. now
the students are
using scratch
to create a virtual
xylophone that will
correctly reproduce the scale.
through observation, the
students recognize that each
bar of the xylophone behaves
in the same manner, but the
pitch varies for each bar. these
students are learning the ct
concepts of representing
data through abstractions as
well as identifying, analyzing,
and implementing possible
solutions. additionally, they are
experiencing the ct disposition
of persistence in working with
difficult problems.
mr. davis’ ninth grade language
arts class is studying various
literary elements, such as plot,
point of view, irony, and voice.
they have read a number of
short stories and are wrapping
up the unit. they are preparing
to write essays that explore
how a particular literary device
plays a part in the essence and
workings of the chosen stories.
these students must state their
theses clearly and include at
least three pieces of evidence to
support the theses. the skills of
logically organizing and analyzing
data necessary for proving a
thesis with citations of strong
and thorough textual evidence
are also essential elements of
computational thinking. the ct
concept of representing data
through abstractions of literary
elements, such as plot structure,
setting, figurative language,
tone, and point of view, is also
necessary to writing a coherent
essay of literary analysis with a
clear thesis statement. the ct
ability to communicate and work
with others to achieve a common
goal or solution facilitates active
participation in class discussions,
especially those guided by a
seminar question. as the students
reflect on their unit and the skills
that enable them to be effective
writers, they begin making
connections between the skills
they are using in language arts
and their application to other
subject areas.
computational thinking in the classroom
here are some scenarios, developed by participants in the iste/csta practitioners workshop, that
illustrate how computational thinking concepts and skills play out in various grade levels and disciplines.
in these examples, students are learning computational thinking skills in nontraditional settings so that
they become internalized and can be easily transferred from one setting to another. these students are
developing skills that can be applied in a variety of situations—in other classes, in the workplace, in their
hobbies—from a variety of perspectives and in an authentic setting. as more and more teachers emphasize
these skills, students will begin to apply them naturally in new and exciting ways.
istockphoto.com/ildogesto istockphoto.com/mstay
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
march/april 2011 | learning & leading with technology 23
how, when, and where computers and
other digital tools can help us solve
problems, and we all need to know
how to communicate with others who
can assist us with computer-supported
solutions.
students already learn many elements of the set of computational
thinking skills in a variety of disciplines, but we need to ensure that all
students have the opportunity to learn
the complete set of skills so their combined power is available to them. the
nsf/iste/csta project has explored
how students learn computational
thinking at all grade levels and in all
disciplines. the long-term goal is to
recommend ways that all students
have the opportunity to learn these
skills and to ensure that they can be
transferred to different problems and
used in different contexts.
in addition to nets•t certification, we now offer courses on integration of iste
standards and 21st century skills—in an innovative virtual classroom environment
and a convenient asynchronous format, 24 hours a day, 7 days a week!
new courses
• teaching and learning in an online environment (8 or 10 weeks)
• supporting digital and global citizenship (4 weeks)
• technology literacy 103: utilizing social networking tools in a leadership
capacity (4 weeks)
• focus on stem: instructional technology strategies for science and math
(4 weeks)
upcoming spring courses
• survey of emerging technologies (4 weeks) next session starts may 2, 2011
• research and information fluency (4 weeks) next session starts may 2, 2011
where do you stand? jamesmadisoneducation.com
take our free phone: 1-877-343-2302 (toll free)
online surveys! email: info@jamesmadisoneducation.com
integrating
21st century skills
through
nets•t certification™
new online learning options!
 
james madison university®, jmu® and
the james madison logo are registered trademarks of james madison university used
under license.
all courses are accredited by james
madison university.
• it is a unique combination of thinking skills that, when used together,
provide the basis of a new and powerful form of problem solving.
• it is more tool oriented.
• it makes use of familiar problemsolving skills such as trial and
error, iteration, and even guessing
in contexts where they were previously impractical but which are now
possible because they can be automated and implemented at much
higher speeds.
why is ct important?
the application of computer technology to virtually every field of study has
changed the way work is done today.
while the human mind is by far the
most powerful problem-solving tool
we have, the ability to extend the power of human thought with computers
and other digital tools has become an
essential part of our everyday lives
and work. we all need to understand
david barr is a retired k–12
teacher and administrator who
works as an educational technology consultant. he serves
on the iste nets leadership
team and the steering committee of the nsf/iste/csta
computational thinking project.
john harrison has taught mathematics and computer science at
princess anne high school in
virginia beach, virginia, since
1999. he sits on the computer
science teachers association
board and chairs its communications committee.
leslie conery is deputy ceo of
iste. she holds an assortment
of degrees and certifications in
computer science, education, and
association management. she
has also been a classroom teacher
at the elementary and high school
levels and a professional development specialist.
this material is based on work supported by the national science foundation
grant cns-1030054.
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved."
"20 learning & leading with technology | march/april 2011
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
by david barr, john harrison, and leslie conery
agroup of high school students
cluster around a computer
looking at a series of graphs
and charts on the screen and talking
quietly but intently. they are collaborating with a group of students in
south america using skype. together
they have gathered data and created
a model depicting the rate of deforestation of the rain forests around the
world. today they are discussing the
changes they need to make to their
data representation and algorithm
before running their simulation.
these students are engaged in what
is called computational thinking.
what is computational thinking?
in a seminal article published in 2006,
jeanette wing described computational thinking (ct) as a way of “solving problems, designing systems, and
understanding human behavior by
drawing on the concepts fundamental
to computer science.” she noted that
computational thinking involves some
familiar concepts, such as problem
decomposition, data representation,
and modeling, as well as less familiar
ideas, such as binary search, recursion, and parallelization. she also
argued that “computational thinking
is a fundamental skill for everyone,
not just for computer scientists. to
reading, writing, and arithmetic, we
should add computational thinking to
every child’s analytical ability.”
wing’s article gave rise to an often
controversial discussion and debate
among computer scientists, cognitive
researchers, and educators regarding
the nature, definition, and application of ct. while many people have
proposed revisions and refinements
to wing’s original description, so
far no single, widely accepted definition of computational thinking has
emerged. as a result, pk–12 educators who recognize the importance
of ct and want to help students acquire these skills have lacked a clear
and practical definition to guide
their work.
how can we make ct accessible?
in 2009, the national science foundation (nsf) funded a project titled
leveraging thought leadership for
computational thinking in pk–12.
led jointly by iste and the computer science teachers association
(csta), the project is intended to
make the concepts of computational
thinking accessible to educators by
providing an operational definition,
a shared vocabulary, and relevant,
age-appropriate examples of computational thinking tied to current
educational objectives and classroom
practices.
a year ago, the project convened a diverse group of educators with an interest
in ct from higher education, pk–12,
and industry to help define a common
language surrounding computational
thinking, articulate the challenges and
opportunities of integrating it throughout pk–12 education, and identify the
most promising practices and strategies
for moving computational thinking
from concept to deep integration.
from that meeting a consensus
emerged regarding the essential elements
of ct, its importance as a learning objective for all students, and how it might be
introduced into the pk–12 educational
environment. the outcomes of the meeting were summarized and synthesized
into a tentative “operational definition” of
ct—that is, a description of its components that educators can use to build ct
skills across the curriculum through all
©i
grade levels and content areas.
stockphoto.com/drafter123
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
learn more
to learn more about how to teach the concepts and vocabulary of computational
thinking in pk–12 classrooms, please visit iste.org/computational-thinking or the
csta website at http://csta.acm.org. check back in a few months to find curriculm
resources, vocabulary tools, and a toolkit for leaders.
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
march/april 2011 | learning & leading with technology 21
computational thinking is a problemsolving process that includes:
• formulating problems in a way that
enables us to use a computer and
other tools to help solve them
• logically organizing and analyzing
data
• representing data through abstractions, such as models and simulations
• automating solutions through algorithmic thinking (a series of ordered
steps)
• identifying, analyzing, and implementing possible solutions with the
goal of achieving the most efficient
and effective combination of steps
and resources
• generalizing and transferring this
problem-solving process to a wide
variety of problems
these skills are supported and enhanced by a number of dispositions or
attitudes that are essential dimensions
of ct, including:
• confidence in dealing with complexity
• persistence in working with
difficult problems
• tolerance for ambiguity
• the ability to deal with openended problems
• the ability to communicate and
work with others to achieve a
common goal or solution
more than 82% of the 697 respondents agreed or strongly agreed that
this definition captured the essential
elements of ct. an additional 9%
confirmed that the definition would
do as a means to build consensus in
the pk–12 community. on the basis
of this survey and feedback from
educators gathered through conference presentations and other informal data collection, project leaders
have begun implementing the next
phase of the project, which involves
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
22 learning & leading with technology | march/april 2011
ms. lee’s seventh grade
class is looking at a series of
diagrams her students have
created to portray floor plans
of their school and homes.
in the diagrams, each room is
labeled as a node and each
pathway out of the building is
labeled as a route. students are
discussing the options for escape
routes in the event of a fire. as
the students and ms. lee look
over the diagrams, you hear a
conversation among the students
describing how the diagrams are
an abstraction of the actual rooms
in a home or school building that
enables them to represent all the
possible escape routes.
the students are
preparing to create an
algorithm to calculate
the safest and fastest
routes from the
buildings.
developing examples of what ct
skills look like in the classroom as
well as assembling resources to support and guide the implementation
of computational thinking concepts
in pk–12 education.
how is ct different?
many of the concepts, skills, and dispositions listed in this operational definition are not new. so how is computational thinking different from critical
thinking or mathematical thinking?
this question has given rise to much
debate but, as yet, no widely accepted
consensus. the participants in the
workshops sponsored by the iste/
csta project proposed that ct differs
from critical thinking and mathematical thinking because:
ms. martinez’s sixth grade social
studies class is studying the
roman empire. students will
compare events in an ancient
roman child’s life to their own life
experience by writing responses
on the ancient roman life blog.
they will also identify the lifestyle
of ancient roman children and
compare it to their own. the
teacher calls attention to the
vocabulary of “modeling” and
“simulation” and asks students to
reflect on other activities in which
they have used these concepts
and skills. she also asks them
to reflect on where they might
use them in the future, including
their careers. these students
are learning the computational
thinking concepts of representing
data through abstractions, such
as models and simulation, and
logically organizing and analyzing
data. they are also exploring
ways of transferring these skills to
other contexts.
mr. butler’s fifth
grade music class
has been studying
the diatonic scale
and the concept
of pitch. now
the students are
using scratch
to create a virtual
xylophone that will
correctly reproduce the scale.
through observation, the
students recognize that each
bar of the xylophone behaves
in the same manner, but the
pitch varies for each bar. these
students are learning the ct
concepts of representing
data through abstractions as
well as identifying, analyzing,
and implementing possible
solutions. additionally, they are
experiencing the ct disposition
of persistence in working with
difficult problems.
mr. davis’ ninth grade language
arts class is studying various
literary elements, such as plot,
point of view, irony, and voice.
they have read a number of
short stories and are wrapping
up the unit. they are preparing
to write essays that explore
how a particular literary device
plays a part in the essence and
workings of the chosen stories.
these students must state their
theses clearly and include at
least three pieces of evidence to
support the theses. the skills of
logically organizing and analyzing
data necessary for proving a
thesis with citations of strong
and thorough textual evidence
are also essential elements of
computational thinking. the ct
concept of representing data
through abstractions of literary
elements, such as plot structure,
setting, figurative language,
tone, and point of view, is also
necessary to writing a coherent
essay of literary analysis with a
clear thesis statement. the ct
ability to communicate and work
with others to achieve a common
goal or solution facilitates active
participation in class discussions,
especially those guided by a
seminar question. as the students
reflect on their unit and the skills
that enable them to be effective
writers, they begin making
connections between the skills
they are using in language arts
and their application to other
subject areas.
computational thinking in the classroom
here are some scenarios, developed by participants in the iste/csta practitioners workshop, that
illustrate how computational thinking concepts and skills play out in various grade levels and disciplines.
in these examples, students are learning computational thinking skills in nontraditional settings so that
they become internalized and can be easily transferred from one setting to another. these students are
developing skills that can be applied in a variety of situations—in other classes, in the workplace, in their
hobbies—from a variety of perspectives and in an authentic setting. as more and more teachers emphasize
these skills, students will begin to apply them naturally in new and exciting ways.
istockphoto.com/ildogesto istockphoto.com/mstay
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
march/april 2011 | learning & leading with technology 23
how, when, and where computers and
other digital tools can help us solve
problems, and we all need to know
how to communicate with others who
can assist us with computer-supported
solutions.
students already learn many elements of the set of computational
thinking skills in a variety of disciplines, but we need to ensure that all
students have the opportunity to learn
the complete set of skills so their combined power is available to them. the
nsf/iste/csta project has explored
how students learn computational
thinking at all grade levels and in all
disciplines. the long-term goal is to
recommend ways that all students
have the opportunity to learn these
skills and to ensure that they can be
transferred to different problems and
used in different contexts.
in addition to nets•t certification, we now offer courses on integration of iste
standards and 21st century skills—in an innovative virtual classroom environment
and a convenient asynchronous format, 24 hours a day, 7 days a week!
new courses
• teaching and learning in an online environment (8 or 10 weeks)
• supporting digital and global citizenship (4 weeks)
• technology literacy 103: utilizing social networking tools in a leadership
capacity (4 weeks)
• focus on stem: instructional technology strategies for science and math
(4 weeks)
upcoming spring courses
• survey of emerging technologies (4 weeks) next session starts may 2, 2011
• research and information fluency (4 weeks) next session starts may 2, 2011
where do you stand? jamesmadisoneducation.com
take our free phone: 1-877-343-2302 (toll free)
online surveys! email: info@jamesmadisoneducation.com
integrating
21st century skills
through
nets•t certification™
new online learning options!
 
james madison university®, jmu® and
the james madison logo are registered trademarks of james madison university used
under license.
all courses are accredited by james
madison university.
• it is a unique combination of thinking skills that, when used together,
provide the basis of a new and powerful form of problem solving.
• it is more tool oriented.
• it makes use of familiar problemsolving skills such as trial and
error, iteration, and even guessing
in contexts where they were previously impractical but which are now
possible because they can be automated and implemented at much
higher speeds.
why is ct important?
the application of computer technology to virtually every field of study has
changed the way work is done today.
while the human mind is by far the
most powerful problem-solving tool
we have, the ability to extend the power of human thought with computers
and other digital tools has become an
essential part of our everyday lives
and work. we all need to understand
david barr is a retired k–12
teacher and administrator who
works as an educational technology consultant. he serves
on the iste nets leadership
team and the steering committee of the nsf/iste/csta
computational thinking project.
john harrison has taught mathematics and computer science at
princess anne high school in
virginia beach, virginia, since
1999. he sits on the computer
science teachers association
board and chairs its communications committee.
leslie conery is deputy ceo of
iste. she holds an assortment
of degrees and certifications in
computer science, education, and
association management. she
has also been a classroom teacher
at the elementary and high school
levels and a professional development specialist.
this material is based on work supported by the national science foundation
grant cns-1030054.
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved."
"20 learning & leading with technology | march/april 2011
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
by david barr, john harrison, and leslie conery
agroup of high school students
cluster around a computer
looking at a series of graphs
and charts on the screen and talking
quietly but intently. they are collaborating with a group of students in
south america using skype. together
they have gathered data and created
a model depicting the rate of deforestation of the rain forests around the
world. today they are discussing the
changes they need to make to their
data representation and algorithm
before running their simulation.
these students are engaged in what
is called computational thinking.
what is computational thinking?
in a seminal article published in 2006,
jeanette wing described computational thinking (ct) as a way of “solving problems, designing systems, and
understanding human behavior by
drawing on the concepts fundamental
to computer science.” she noted that
computational thinking involves some
familiar concepts, such as problem
decomposition, data representation,
and modeling, as well as less familiar
ideas, such as binary search, recursion, and parallelization. she also
argued that “computational thinking
is a fundamental skill for everyone,
not just for computer scientists. to
reading, writing, and arithmetic, we
should add computational thinking to
every child’s analytical ability.”
wing’s article gave rise to an often
controversial discussion and debate
among computer scientists, cognitive
researchers, and educators regarding
the nature, definition, and application of ct. while many people have
proposed revisions and refinements
to wing’s original description, so
far no single, widely accepted definition of computational thinking has
emerged. as a result, pk–12 educators who recognize the importance
of ct and want to help students acquire these skills have lacked a clear
and practical definition to guide
their work.
how can we make ct accessible?
in 2009, the national science foundation (nsf) funded a project titled
leveraging thought leadership for
computational thinking in pk–12.
led jointly by iste and the computer science teachers association
(csta), the project is intended to
make the concepts of computational
thinking accessible to educators by
providing an operational definition,
a shared vocabulary, and relevant,
age-appropriate examples of computational thinking tied to current
educational objectives and classroom
practices.
a year ago, the project convened a diverse group of educators with an interest
in ct from higher education, pk–12,
and industry to help define a common
language surrounding computational
thinking, articulate the challenges and
opportunities of integrating it throughout pk–12 education, and identify the
most promising practices and strategies
for moving computational thinking
from concept to deep integration.
from that meeting a consensus
emerged regarding the essential elements
of ct, its importance as a learning objective for all students, and how it might be
introduced into the pk–12 educational
environment. the outcomes of the meeting were summarized and synthesized
into a tentative “operational definition” of
ct—that is, a description of its components that educators can use to build ct
skills across the curriculum through all
©i
grade levels and content areas.
stockphoto.com/drafter123
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
learn more
to learn more about how to teach the concepts and vocabulary of computational
thinking in pk–12 classrooms, please visit iste.org/computational-thinking or the
csta website at http://csta.acm.org. check back in a few months to find curriculm
resources, vocabulary tools, and a toolkit for leaders.
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
march/april 2011 | learning & leading with technology 21
computational thinking is a problemsolving process that includes:
• formulating problems in a way that
enables us to use a computer and
other tools to help solve them
• logically organizing and analyzing
data
• representing data through abstractions, such as models and simulations
• automating solutions through algorithmic thinking (a series of ordered
steps)
• identifying, analyzing, and implementing possible solutions with the
goal of achieving the most efficient
and effective combination of steps
and resources
• generalizing and transferring this
problem-solving process to a wide
variety of problems
these skills are supported and enhanced by a number of dispositions or
attitudes that are essential dimensions
of ct, including:
• confidence in dealing with complexity
• persistence in working with
difficult problems
• tolerance for ambiguity
• the ability to deal with openended problems
• the ability to communicate and
work with others to achieve a
common goal or solution
more than 82% of the 697 respondents agreed or strongly agreed that
this definition captured the essential
elements of ct. an additional 9%
confirmed that the definition would
do as a means to build consensus in
the pk–12 community. on the basis
of this survey and feedback from
educators gathered through conference presentations and other informal data collection, project leaders
have begun implementing the next
phase of the project, which involves
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
22 learning & leading with technology | march/april 2011
ms. lee’s seventh grade
class is looking at a series of
diagrams her students have
created to portray floor plans
of their school and homes.
in the diagrams, each room is
labeled as a node and each
pathway out of the building is
labeled as a route. students are
discussing the options for escape
routes in the event of a fire. as
the students and ms. lee look
over the diagrams, you hear a
conversation among the students
describing how the diagrams are
an abstraction of the actual rooms
in a home or school building that
enables them to represent all the
possible escape routes.
the students are
preparing to create an
algorithm to calculate
the safest and fastest
routes from the
buildings.
developing examples of what ct
skills look like in the classroom as
well as assembling resources to support and guide the implementation
of computational thinking concepts
in pk–12 education.
how is ct different?
many of the concepts, skills, and dispositions listed in this operational definition are not new. so how is computational thinking different from critical
thinking or mathematical thinking?
this question has given rise to much
debate but, as yet, no widely accepted
consensus. the participants in the
workshops sponsored by the iste/
csta project proposed that ct differs
from critical thinking and mathematical thinking because:
ms. martinez’s sixth grade social
studies class is studying the
roman empire. students will
compare events in an ancient
roman child’s life to their own life
experience by writing responses
on the ancient roman life blog.
they will also identify the lifestyle
of ancient roman children and
compare it to their own. the
teacher calls attention to the
vocabulary of “modeling” and
“simulation” and asks students to
reflect on other activities in which
they have used these concepts
and skills. she also asks them
to reflect on where they might
use them in the future, including
their careers. these students
are learning the computational
thinking concepts of representing
data through abstractions, such
as models and simulation, and
logically organizing and analyzing
data. they are also exploring
ways of transferring these skills to
other contexts.
mr. butler’s fifth
grade music class
has been studying
the diatonic scale
and the concept
of pitch. now
the students are
using scratch
to create a virtual
xylophone that will
correctly reproduce the scale.
through observation, the
students recognize that each
bar of the xylophone behaves
in the same manner, but the
pitch varies for each bar. these
students are learning the ct
concepts of representing
data through abstractions as
well as identifying, analyzing,
and implementing possible
solutions. additionally, they are
experiencing the ct disposition
of persistence in working with
difficult problems.
mr. davis’ ninth grade language
arts class is studying various
literary elements, such as plot,
point of view, irony, and voice.
they have read a number of
short stories and are wrapping
up the unit. they are preparing
to write essays that explore
how a particular literary device
plays a part in the essence and
workings of the chosen stories.
these students must state their
theses clearly and include at
least three pieces of evidence to
support the theses. the skills of
logically organizing and analyzing
data necessary for proving a
thesis with citations of strong
and thorough textual evidence
are also essential elements of
computational thinking. the ct
concept of representing data
through abstractions of literary
elements, such as plot structure,
setting, figurative language,
tone, and point of view, is also
necessary to writing a coherent
essay of literary analysis with a
clear thesis statement. the ct
ability to communicate and work
with others to achieve a common
goal or solution facilitates active
participation in class discussions,
especially those guided by a
seminar question. as the students
reflect on their unit and the skills
that enable them to be effective
writers, they begin making
connections between the skills
they are using in language arts
and their application to other
subject areas.
computational thinking in the classroom
here are some scenarios, developed by participants in the iste/csta practitioners workshop, that
illustrate how computational thinking concepts and skills play out in various grade levels and disciplines.
in these examples, students are learning computational thinking skills in nontraditional settings so that
they become internalized and can be easily transferred from one setting to another. these students are
developing skills that can be applied in a variety of situations—in other classes, in the workplace, in their
hobbies—from a variety of perspectives and in an authentic setting. as more and more teachers emphasize
these skills, students will begin to apply them naturally in new and exciting ways.
istockphoto.com/ildogesto istockphoto.com/mstay
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
march/april 2011 | learning & leading with technology 23
how, when, and where computers and
other digital tools can help us solve
problems, and we all need to know
how to communicate with others who
can assist us with computer-supported
solutions.
students already learn many elements of the set of computational
thinking skills in a variety of disciplines, but we need to ensure that all
students have the opportunity to learn
the complete set of skills so their combined power is available to them. the
nsf/iste/csta project has explored
how students learn computational
thinking at all grade levels and in all
disciplines. the long-term goal is to
recommend ways that all students
have the opportunity to learn these
skills and to ensure that they can be
transferred to different problems and
used in different contexts.
in addition to nets•t certification, we now offer courses on integration of iste
standards and 21st century skills—in an innovative virtual classroom environment
and a convenient asynchronous format, 24 hours a day, 7 days a week!
new courses
• teaching and learning in an online environment (8 or 10 weeks)
• supporting digital and global citizenship (4 weeks)
• technology literacy 103: utilizing social networking tools in a leadership
capacity (4 weeks)
• focus on stem: instructional technology strategies for science and math
(4 weeks)
upcoming spring courses
• survey of emerging technologies (4 weeks) next session starts may 2, 2011
• research and information fluency (4 weeks) next session starts may 2, 2011
where do you stand? jamesmadisoneducation.com
take our free phone: 1-877-343-2302 (toll free)
online surveys! email: info@jamesmadisoneducation.com
integrating
21st century skills
through
nets•t certification™
new online learning options!
 
james madison university®, jmu® and
the james madison logo are registered trademarks of james madison university used
under license.
all courses are accredited by james
madison university.
• it is a unique combination of thinking skills that, when used together,
provide the basis of a new and powerful form of problem solving.
• it is more tool oriented.
• it makes use of familiar problemsolving skills such as trial and
error, iteration, and even guessing
in contexts where they were previously impractical but which are now
possible because they can be automated and implemented at much
higher speeds.
why is ct important?
the application of computer technology to virtually every field of study has
changed the way work is done today.
while the human mind is by far the
most powerful problem-solving tool
we have, the ability to extend the power of human thought with computers
and other digital tools has become an
essential part of our everyday lives
and work. we all need to understand
david barr is a retired k–12
teacher and administrator who
works as an educational technology consultant. he serves
on the iste nets leadership
team and the steering committee of the nsf/iste/csta
computational thinking project.
john harrison has taught mathematics and computer science at
princess anne high school in
virginia beach, virginia, since
1999. he sits on the computer
science teachers association
board and chairs its communications committee.
leslie conery is deputy ceo of
iste. she holds an assortment
of degrees and certifications in
computer science, education, and
association management. she
has also been a classroom teacher
at the elementary and high school
levels and a professional development specialist.
this material is based on work supported by the national science foundation
grant cns-1030054.
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved."
"20 learning & leading with technology | march/april 2011
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
by david barr, john harrison, and leslie conery
agroup of high school students
cluster around a computer
looking at a series of graphs
and charts on the screen and talking
quietly but intently. they are collaborating with a group of students in
south america using skype. together
they have gathered data and created
a model depicting the rate of deforestation of the rain forests around the
world. today they are discussing the
changes they need to make to their
data representation and algorithm
before running their simulation.
these students are engaged in what
is called computational thinking.
what is computational thinking?
in a seminal article published in 2006,
jeanette wing described computational thinking (ct) as a way of “solving problems, designing systems, and
understanding human behavior by
drawing on the concepts fundamental
to computer science.” she noted that
computational thinking involves some
familiar concepts, such as problem
decomposition, data representation,
and modeling, as well as less familiar
ideas, such as binary search, recursion, and parallelization. she also
argued that “computational thinking
is a fundamental skill for everyone,
not just for computer scientists. to
reading, writing, and arithmetic, we
should add computational thinking to
every child’s analytical ability.”
wing’s article gave rise to an often
controversial discussion and debate
among computer scientists, cognitive
researchers, and educators regarding
the nature, definition, and application of ct. while many people have
proposed revisions and refinements
to wing’s original description, so
far no single, widely accepted definition of computational thinking has
emerged. as a result, pk–12 educators who recognize the importance
of ct and want to help students acquire these skills have lacked a clear
and practical definition to guide
their work.
how can we make ct accessible?
in 2009, the national science foundation (nsf) funded a project titled
leveraging thought leadership for
computational thinking in pk–12.
led jointly by iste and the computer science teachers association
(csta), the project is intended to
make the concepts of computational
thinking accessible to educators by
providing an operational definition,
a shared vocabulary, and relevant,
age-appropriate examples of computational thinking tied to current
educational objectives and classroom
practices.
a year ago, the project convened a diverse group of educators with an interest
in ct from higher education, pk–12,
and industry to help define a common
language surrounding computational
thinking, articulate the challenges and
opportunities of integrating it throughout pk–12 education, and identify the
most promising practices and strategies
for moving computational thinking
from concept to deep integration.
from that meeting a consensus
emerged regarding the essential elements
of ct, its importance as a learning objective for all students, and how it might be
introduced into the pk–12 educational
environment. the outcomes of the meeting were summarized and synthesized
into a tentative “operational definition” of
ct—that is, a description of its components that educators can use to build ct
skills across the curriculum through all
©i
grade levels and content areas.
stockphoto.com/drafter123
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
learn more
to learn more about how to teach the concepts and vocabulary of computational
thinking in pk–12 classrooms, please visit iste.org/computational-thinking or the
csta website at http://csta.acm.org. check back in a few months to find curriculm
resources, vocabulary tools, and a toolkit for leaders.
computational thinking: a digital age skill for everyone
the national science foundation has assembled a group of thought leaders
to bring the concepts of computational thinking to the k–12 classroom.
march/april 2011 | learning & leading with technology 21
computational thinking is a problemsolving process that includes:
• formulating problems in a way that
enables us to use a computer and
other tools to help solve them
• logically organizing and analyzing
data
• representing data through abstractions, such as models and simulations
• automating solutions through algorithmic thinking (a series of ordered
steps)
• identifying, analyzing, and implementing possible solutions with the
goal of achieving the most efficient
and effective combination of steps
and resources
• generalizing and transferring this
problem-solving process to a wide
variety of problems
these skills are supported and enhanced by a number of dispositions or
attitudes that are essential dimensions
of ct, including:
• confidence in dealing with complexity
• persistence in working with
difficult problems
• tolerance for ambiguity
• the ability to deal with openended problems
• the ability to communicate and
work with others to achieve a
common goal or solution
more than 82% of the 697 respondents agreed or strongly agreed that
this definition captured the essential
elements of ct. an additional 9%
confirmed that the definition would
do as a means to build consensus in
the pk–12 community. on the basis
of this survey and feedback from
educators gathered through conference presentations and other informal data collection, project leaders
have begun implementing the next
phase of the project, which involves
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
22 learning & leading with technology | march/april 2011
ms. lee’s seventh grade
class is looking at a series of
diagrams her students have
created to portray floor plans
of their school and homes.
in the diagrams, each room is
labeled as a node and each
pathway out of the building is
labeled as a route. students are
discussing the options for escape
routes in the event of a fire. as
the students and ms. lee look
over the diagrams, you hear a
conversation among the students
describing how the diagrams are
an abstraction of the actual rooms
in a home or school building that
enables them to represent all the
possible escape routes.
the students are
preparing to create an
algorithm to calculate
the safest and fastest
routes from the
buildings.
developing examples of what ct
skills look like in the classroom as
well as assembling resources to support and guide the implementation
of computational thinking concepts
in pk–12 education.
how is ct different?
many of the concepts, skills, and dispositions listed in this operational definition are not new. so how is computational thinking different from critical
thinking or mathematical thinking?
this question has given rise to much
debate but, as yet, no widely accepted
consensus. the participants in the
workshops sponsored by the iste/
csta project proposed that ct differs
from critical thinking and mathematical thinking because:
ms. martinez’s sixth grade social
studies class is studying the
roman empire. students will
compare events in an ancient
roman child’s life to their own life
experience by writing responses
on the ancient roman life blog.
they will also identify the lifestyle
of ancient roman children and
compare it to their own. the
teacher calls attention to the
vocabulary of “modeling” and
“simulation” and asks students to
reflect on other activities in which
they have used these concepts
and skills. she also asks them
to reflect on where they might
use them in the future, including
their careers. these students
are learning the computational
thinking concepts of representing
data through abstractions, such
as models and simulation, and
logically organizing and analyzing
data. they are also exploring
ways of transferring these skills to
other contexts.
mr. butler’s fifth
grade music class
has been studying
the diatonic scale
and the concept
of pitch. now
the students are
using scratch
to create a virtual
xylophone that will
correctly reproduce the scale.
through observation, the
students recognize that each
bar of the xylophone behaves
in the same manner, but the
pitch varies for each bar. these
students are learning the ct
concepts of representing
data through abstractions as
well as identifying, analyzing,
and implementing possible
solutions. additionally, they are
experiencing the ct disposition
of persistence in working with
difficult problems.
mr. davis’ ninth grade language
arts class is studying various
literary elements, such as plot,
point of view, irony, and voice.
they have read a number of
short stories and are wrapping
up the unit. they are preparing
to write essays that explore
how a particular literary device
plays a part in the essence and
workings of the chosen stories.
these students must state their
theses clearly and include at
least three pieces of evidence to
support the theses. the skills of
logically organizing and analyzing
data necessary for proving a
thesis with citations of strong
and thorough textual evidence
are also essential elements of
computational thinking. the ct
concept of representing data
through abstractions of literary
elements, such as plot structure,
setting, figurative language,
tone, and point of view, is also
necessary to writing a coherent
essay of literary analysis with a
clear thesis statement. the ct
ability to communicate and work
with others to achieve a common
goal or solution facilitates active
participation in class discussions,
especially those guided by a
seminar question. as the students
reflect on their unit and the skills
that enable them to be effective
writers, they begin making
connections between the skills
they are using in language arts
and their application to other
subject areas.
computational thinking in the classroom
here are some scenarios, developed by participants in the iste/csta practitioners workshop, that
illustrate how computational thinking concepts and skills play out in various grade levels and disciplines.
in these examples, students are learning computational thinking skills in nontraditional settings so that
they become internalized and can be easily transferred from one setting to another. these students are
developing skills that can be applied in a variety of situations—in other classes, in the workplace, in their
hobbies—from a variety of perspectives and in an authentic setting. as more and more teachers emphasize
these skills, students will begin to apply them naturally in new and exciting ways.
istockphoto.com/ildogesto istockphoto.com/mstay
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved.
march/april 2011 | learning & leading with technology 23
how, when, and where computers and
other digital tools can help us solve
problems, and we all need to know
how to communicate with others who
can assist us with computer-supported
solutions.
students already learn many elements of the set of computational
thinking skills in a variety of disciplines, but we need to ensure that all
students have the opportunity to learn
the complete set of skills so their combined power is available to them. the
nsf/iste/csta project has explored
how students learn computational
thinking at all grade levels and in all
disciplines. the long-term goal is to
recommend ways that all students
have the opportunity to learn these
skills and to ensure that they can be
transferred to different problems and
used in different contexts.
in addition to nets•t certification, we now offer courses on integration of iste
standards and 21st century skills—in an innovative virtual classroom environment
and a convenient asynchronous format, 24 hours a day, 7 days a week!
new courses
• teaching and learning in an online environment (8 or 10 weeks)
• supporting digital and global citizenship (4 weeks)
• technology literacy 103: utilizing social networking tools in a leadership
capacity (4 weeks)
• focus on stem: instructional technology strategies for science and math
(4 weeks)
upcoming spring courses
• survey of emerging technologies (4 weeks) next session starts may 2, 2011
• research and information fluency (4 weeks) next session starts may 2, 2011
where do you stand? jamesmadisoneducation.com
take our free phone: 1-877-343-2302 (toll free)
online surveys! email: info@jamesmadisoneducation.com
integrating
21st century skills
through
nets•t certification™
new online learning options!
 
james madison university®, jmu® and
the james madison logo are registered trademarks of james madison university used
under license.
all courses are accredited by james
madison university.
• it is a unique combination of thinking skills that, when used together,
provide the basis of a new and powerful form of problem solving.
• it is more tool oriented.
• it makes use of familiar problemsolving skills such as trial and
error, iteration, and even guessing
in contexts where they were previously impractical but which are now
possible because they can be automated and implemented at much
higher speeds.
why is ct important?
the application of computer technology to virtually every field of study has
changed the way work is done today.
while the human mind is by far the
most powerful problem-solving tool
we have, the ability to extend the power of human thought with computers
and other digital tools has become an
essential part of our everyday lives
and work. we all need to understand
david barr is a retired k–12
teacher and administrator who
works as an educational technology consultant. he serves
on the iste nets leadership
team and the steering committee of the nsf/iste/csta
computational thinking project.
john harrison has taught mathematics and computer science at
princess anne high school in
virginia beach, virginia, since
1999. he sits on the computer
science teachers association
board and chairs its communications committee.
leslie conery is deputy ceo of
iste. she holds an assortment
of degrees and certifications in
computer science, education, and
association management. she
has also been a classroom teacher
at the elementary and high school
levels and a professional development specialist.
this material is based on work supported by the national science foundation
grant cns-1030054.
copyright © 2011, iste (international society for technology in education), 1.800.336.5191 (u.s. & canada) or 1.541.302.3777 (int’l), iste@iste.org, www.iste.org. all rights reserved."
"developing computational thinking in the classroom: a
framework
june 2014
working group of authors:
prof. paul curzon
queen mary university of london, school of electronic engineering and computer science
teaching london computing project (http://www.teachinglondoncomputing.org/), funded by the mayor of london and department of education through the london school's excellence fund
mark dorling
bcs, the chartered institute for it and computing at school network of excellence project (http://www.computingatschool.org.uk), funded by the department for education, industry partners and awarding bodies
digital schoolhouse london project (http://www.digitalschoolhouse.org.uk), funded by the mayor of london
and department of education through the london school's excellence fund
thomas ng
west berkshire council school improvement adviser (ict & assessment)
dr. cynthia selby
bay house school and sixth form, gosport, hampshire
southampton education school, university of southampton
dr. john woollard
southampton education school, university of southampton
bcs, chartered institute for it barefoot computing project (http://www.barefootcas.org.uk), funded by the department for education
© copyright 2014 computing at school
this work is licensed under the creative commons attribution-non commercial license; see http://creativecommons.org/licenses/by-nc/3.0/ for details.
introduction
computational thinking sits at the heart of the new statutory programme of study for computing:
“a high quality computing education equips pupils to use computational thinking and creativity to understand and change the world” (department for education, 2013, p. 188).
this document aims to support teachers to teach computational thinking. it describes a framework that helps
explain what computational thinking is, describes pedagogic approaches for teaching it and gives ways to assess it.
pupil progression with the previous ict curriculum was often demonstrated through ‘how’ (for example, a software usage skill) or ‘what’ the pupil produced (for example, a poster). this was partly due to the needs of the
business world for office skills. such use of precious curriculum time however has several weaknesses. firstly,
the country’s economy depends on technological innovation not just on effective use of technology. secondly,
the pace of technology and organisational change is fast in that the ict skills learnt are out of date before a
pupil leaves school. thirdly, technology invades all aspects of our life and the typically taught office practice is
only a small part of technology use today.
in contrast, the new computing curriculum has an enriched computer science element. computer science is
an academic discipline with its own body of knowledge that can equip pupils to become independent learners,
evaluators and potentially designers of new technologies. in studying computer science, pupils gain not only
knowledge but also a unique way of thinking about and solving problems: computational thinking. it allows the
pupils to understand the digital world in a deeper way: just as physics equips pupils to better understand the
physical world and biology the biological world. simon peyton-jones gives an account of why learning computer science and computational thinking is a core life and transferable skill in a talk filmed at tedxexeter
(peyton-jones, 2014).
to prepare our pupils to understand the consequences of technological change, adapt when using technologies, develop new technologies or even to work in jobs that haven't yet been invented, not only does the
‘what?’ and ‘how?’ of the subject need to be taught, pupils also need to develop techniques to ask and be able
to answer the question ‘why?’. computational thinking supports doing so. computational thinking skills are the
set of mental skills that convert “complex, messy, partially defined, real world problems into a form that a mindless computer can tackle without further assistance from a human.” (bcs, 2014)
today, however, there is an interpretation, led by the popular media, implying that the new computing curriculum focuses on ‘coding’ (crow, 2014; nettleford, 2013). this gives a misleading message, especially to those
new to the discipline. in contrast, our framework presented below aims to support teachers’ understanding of
computational thinking across the full breadth and depth of the subject of computing and offers a way to easily
and effectively integrate it into classroom practice.
the framework
there are four interconnected stages of development to our computational thinking framework:
stage 1: definition
stage 2: concepts
stage 3: classroom techniques
stage 4: assessment
we overview each in the subsequent sections.
stage 1: definition
to support the sharing of curriculum materials and classroom practices, an agreed definition that is suitable for
the classroom is needed. we use the interpretation forwarded by professor jeannette wing, who originally
popularised the idea of computational thinking. she defines it as:
“… the thought processes involved in formulating problems and their solutions so that the solutions are
represented in a form that can be effectively carried out by an information-processing agent” (cuny,
snyder, wing, 2010, cited in wing, 2011, p.20) ... “these solutions can be carried out by any processing
agent, whether human, computer, or a combination of both” (wing, 2006).
we chose this definition because it is based on wing’s original definition and has gained consensus amongst
academics. its emphasis is on pupils performing a thought process, not on the production of artefacts or evidence. it therefore fits the direction of change in the current curriculum development.
stage 2: concepts
the next stage is to define the core concepts involved in computational thinking. based on a review of academic references, selby and woollard (2013) suggest the following are key:
■ algorithmic thinking
■ evaluation
■ decomposition
■ abstraction
■ generalisation
we outline these concepts with examples below, giving linked classroom techniques in the next section.
algorithmic thinking is a way of getting to a solution through clear definition of the steps - nothing happens
by magic. rather than coming up with a single answer, like 42, the pupils develop a set of instructions or rules
that if followed precisely (whether by a person or a computer) leads to answers to that and similar problems.
for example, we all learn algorithms for doing multiplication at school. if we (or a computer) follow the rules we
were taught precisely we can get the answer to any multiplication problem. once we have the algorithm we
don’t have to work out how to do multiplication from scratch every time we are faced with a new problem.
evaluation is the process of ensuring an algorithmic solution is a good one: that it is fit for purpose. various
properties of algorithms need to be evaluated including whether they are correct, are fast enough, are economic in the use of resources, are easy for people to use and promote an appropriate experience. trade-offs need
to be made as there is rarely a single ideal solution for all situations. there is a specific and often extreme focus on attention to detail in computational thinking based evaluation.
for example, if we are developing a medical device to deliver drugs to patients in hospital we need to be sure
that it always delivers the amount of drug set and that it does so quickly enough once start is pressed. however, we also need to be sure that nurses will be able to set the dose quickly and easily without making mistakes
and that it won’t be frustrating or irritating for patients and nurses to use. there is likely to be a trade-off to be
made between speed of entering numbers and helping avoid mistakes being made when doing so. the
judgement about it being quick and easy has to be made systematically and rigorously.
decomposition is a way of thinking about problems, algorithms, artefacts, processes and systems in terms of
their parts. the separate parts can then be understood, solved, developed and evaluated separately. this
makes complex problems easier to solve and large systems easier to design.
for example, if we are developing a game, different people can design and create the different levels independently provided key aspects are agreed in advance. through decomposition of the original task each part can
be developed and integrated later in the process. a simple arcade level might also be decomposed into several parts, such as the life-like motion of a character, scrolling the background and setting the rules about how
characters interact.
abstraction is another way to make problems or systems easier to think about. it simply involves hiding detail
- removing unnecessary complexity. the skill is in choosing the right detail to hide so that the problem becomes easier without losing anything that is important. it is used as a way to make it easier to create complex
algorithms, as well as whole systems. a key part of it is in choosing a good representation of a system. different representations make different things easy to do.
for example, when we play cards, we use the word ‘shuffle’. every player understands that ‘shuffle’ means
putting the cards in a random order. the word is an abstraction. the same type of abstraction works when
programming. implementing ‘shuffle’ in a computer game means giving a way to randomise the cards. we
can refer to shuffling throughout the program and understand what is meant without having to think about how
it is actually done by the program. all that is needed is that the program does include a description somewhere
of how shuffling is to be done.
as an example illustrating the difference the representation can make, consider an art project. pupils studying
monet could take a digital picture of a haystack painting in a gallery. in doing so they have created a representation of it on the computer as pixels. they can then easily manipulate this digital representation in ways that
would be very hard with a different representation or in the real world. for example, the colours could be
changed by an algorithm. in this way a series of different but related versions of the painting could be created.
generalisation is a way of quickly solving new problems based on previous problems we have solved. we
can take an algorithm that solves some specific problem and adapt it so that it solves a whole class of similar
problems. then whenever we have to solve a new problem of that kind we just apply this general solution.
for example, a pupil uses a floor turtle to draw a series of shapes, such as a square and a triangle. the pupil
writes a computer program to draw the two shapes. they then want to draw an octagon and a 10-sided shape.
from the work with the square and triangle, they spot that there is a relationship between the number of sides
in the shape and the angles involved. they can then write an algorithm that expresses this relationship and
uses it to draw any regular polygon. 
in summary, each of the above techniques fits into the well-established system design life cycle of computing
projects in the business, academic and scientific communities. in practice they are used together in a rich and
interdependent way to solve problems. the emphasis in these concepts is on practical techniques or thought
processes, not on the production of artefacts or evidence.
stage 3: classroom techniques
the descriptions of the concepts above are high-level. although important, on their own they don't explain how
computational thinking can be embedded into the classroom and integrated into pedagogy. therefore, our next
step (table 1) is to identify learner behaviours associated with each.
concept examples of techniques
algorithmic thinking writing instructions that if followed in a given order (sequences) achieve a
desired effect;
writing instructions that use arithmetic and logical operations to achieve a
desired effect;
writing instructions that store, move and manipulate data to achieve a desired
effect; (variables and assignment)
writing instructions that choose between different constituent instructions
(selection) to achieve a desired effect;
writing instructions that repeat groups of constituent instructions (loops/
iteration) to achieve a desired effect;
grouping and naming a collection of instructions that do a well-defined task to
make a new instruction (subroutines, procedures, functions, methods);
writing instructions that involve subroutines use copies of themselves to
achieve a desired effect (recursion);
writing sets of instructions that can be followed at the same time by different
agents (computers or people) to achieve a desired effect (parallel thinking and
processing, concurrency);
writing a set of rules to achieve a desired effect (declarative languages);
using a standard notation to represent each of the above;
creating algorithms to test a hypothesis;
creating algorithms that give good, though not always the best, solutions
(heuristics);
creating algorithmic descriptions of real world processes so as to better
understand them (computational modelling);
designing algorithmic solutions that take into account the abilities, limitations
and desires of the people who will use them;
evaluation assessing that an algorithm is fit for purpose;
assessing whether an algorithm does the right thing (functional correctness);
designing and running test plans and interpreting the results (testing);
assessment whether the performance of an algorithm is good enough;
comparing the performance of algorithms that do the same thing;
making trade-offs between conflicting demands;
assessment of whether a system is easy for people to use (usability);
assessment of whether a system gives an appropriately positive experience
when used (user experience);
assessment of any of the above against set criteria;
stepping through algorithms/code step by step to work out what they do (dry
run / tracing);
using rigorous argument to justify that an algorithm works (proof);
using rigorous argument to check the usability or performance of an algorithm
(analytical evaluation);
using methods involving observing a system in use to assess its usability or
performance (empirical evaluation);
judging when an algorithmic solution is good enough even if it is not perfect;
assessing whether a solution meets the specification (criteria);
assessing whether a product meets general performance criteria (heuristics)
decomposition breaking down artefacts (whether objects, problems, processes, solutions,
systems or abstractions) into constituent parts to make them easier to work
with;
breaking down a problem into simpler but otherwise identical versions of the
same problem that can be solved in the same way (recursive and divide and
conquer strategies)
table 1: computational thinking concepts and associated techniques.
examples of algorithmic thinking, evaluation, decomposition, generalisation and abstraction, are found at all
stages; it is the context that determines the relevance and challenge of the activity. we have therefore tried not
to attribute computational concepts and learner behaviours to particular key stages (phases of education) because doing so would imply that they are age-dependent in a way that they are not: they are capability dependent.
it is also important to emphasise that computational thinking concepts are not the content for the subject of
‘computing’. the subject content is set out in the national curriculum programme of study. computational
thinking skills enable learners to access parts of that subject content.
stage 4: assessment
the final stage needed is a way to assess the increasing competence of pupils in computational thinking. this
can be done using an adapted version of the existing subject framework for the computing subject itself.
to support classroom teachers, computing at school published an assessment framework called ‘computing
progression pathways’ (dorling and walker, 2014a). it sets out the major knowledge areas of computing and
gives specific indicators of increasing levels of mastery of the subject in those areas. this assessment framework was produced by a small team of authors and reviewers (all teachers and academics) based on their
classroom experiences. it is an interpretation of the breadth and depth of the content in the 2014 national curriculum for the computing programme of study. this breadth affords an opportunity to view the subject of computing as a whole, rather than the separate subject strands of computer science, digital literacy and information
technology proposed by the royal society (2012). the assessment framework identifies the dependencies and
interdependencies between concepts and principles as well as between the three subject strands.
abstraction reducing complexity by removing unnecessary detail;
choosing a way to represent artefacts (whether objects, problems, processes or
systems) to allow it to be manipulated in useful ways;
hiding the full complexity of an artefact, whether objects, problems, processes,
solutions, systems (hiding functional complexity);
hiding complexity in data, for example by using data structures;
identifying relationships between abstractions;
filtering information when developing solutions;
generalisation identifying patterns and commonalities in problems, processes, solutions, or
data.
adapting solutions or parts of solutions so they apply to a whole class of similar
problems;
transferring ideas and solutions from one problem area to another
separate pathways are given for the areas of algorithms, programming & development, data and data representation, hardware & processing, communication & networks and information technology.
for example, the pathway around the subject area of algorithms at its lowest level involves understanding of
what an algorithm is and an ability to express simple linear algorithms with care and precision. it then moves
through levels of being able to express more complicated algorithms using selection and loops, to at the highest level being able to design algorithms that make use of recursion as well as having an understanding that
not all problems can be solved computationally.
the assessment framework is also presented where the learning outcomes are organised by the separate subject strands of computer science, digital literacy and information technology (dorling and walker, 2014b). a further version has been developed to incorporate provision for the concepts of computational thinking (selby,
dorling and woollard, 2014). it now includes a description of how it can be used to acknowledge progression
and reward performance in mastering both the content of the computing programme of study and the ideas of
computational thinking (dorling, walker, 2014c). for example, algorithmic thinking is demonstrated not just in
the algorithms and programming & development pathways, but also in constructing appropriate search filters
(data & data representation) and in demonstrating understanding of the fetch-execute cycle (hardware &
processing). see figure 1 as an example of what you can expect to see in computing progression pathways
with computational thinking.
figure 1: mapping the learning outcomes from computing progression pathways to the concepts (from stage
2) of computational thinking. 
using the framework to plan lessons
when planning and teaching a scheme of work in any subject, teachers refer to the planning-teaching-evaluating cycle. computational thinking can be included in the planning stage in four steps within the planning phase
of each lesson in the planning-teaching-evaluating cycle, see figure 2.
step 1: determine the ‘why’ at the start of the unit of study (stage 1) as well as the possible topics (the column header names from the progression pathways assessment framework) that the scheme of work will be
covering.
repeat steps 2 - 4 when planning each lesson in a unit of study
step 2: decide ‘what’ the learning outcomes are for the lesson from the computing progression pathways assessment framework (stage 4), which enable the pupils to move closer to completing or achieving the ‘why’.
step 3: use the predefined mapping in the computing progression pathways assessment framework to identify the possible associated computational thinking concepts (stage 2).
step 4: use the computational thinking concepts to identify possible techniques ‘how’ to incorporate into and
highlight as part of the chosen classroom activities (stage 3). 
 figure 2: mapping the 4 stages of the framework to ‘why’, ‘how’ and ‘what’.
it is important to note that the most important step in this process is the last step (step 4). just because pupils
can evidence learning in the computing progression pathways assessment framework and that the learning
outcome is mapped to computational thinking, it does not necessarily mean that the pupils will have performed
computational thinking. completion of an activity, in itself, is not evidence that computational thinking has occurred.
a case study
below, we illustrate the application of the above framework with a case study, based around a lesson one of
the authors (dorling) has used in his classroom. in the sub-section of each activity, we highlight how different
parts of the activity draw on the computational thinking concepts (ct). in the classroom, these concepts could
be drawn out explicitly in, for example, a discussion at the end where the pupils reflect on the computational
thinking skills they have used through the activity.
topic
networking & communications - using a binary protocol to transfer information
why
i first lead a group discussion aiming to draw out why networks are important. we discuss the applications
pupils use on a regular basis, such as a search engine or network file shares and how these applications have
completely changed the way we do things. i lead pupils to ask “what actually happens in the wire to make information go back and forth?”
how
activity 1) recap - i remind the pupils that they have previously studied and understood the different layers
involved in computer architecture: applications, the operating system and the hardware.
■ (ct) abstraction of functionality
■ as we move from hardware to operating system to applications we
move through increasing layers of system abstraction as each hides the
messy details of the level below.
activity 2) i introduce the pupils to the layers of network architecture: application, transport and network and
point out the similarity to the computer architecture layers.
■ (ct) abstraction of functionality
■ in a similar way we move up through similar layers of abstraction from the
network to transport layer to applications as each hides the messy details of the level below.
■ (ct) generalisation of solution (applying the same technique to a similar problem)
■ we have transferred the technique of analysis by layers from computer
architecture to network architecture.
activity 3) i remind pupils of their understanding of denary (decimal) numbers stored as binary numbers, that
is denary numbers are an abstraction of the binary code. they hide the detail of how the numbers are actually
stored. i suggest that they could use this knowledge to invent their own transportation layer protocol.
■ (ct) abstraction of data
■ denary numbers conceal the complexity of the binary representation
activity 4) i give the pupils a simple circuit, i.e. a battery, wires and a lamp, and ask them to transfer a decimal
number across the room to a friend using the lamp.
it is up to the learners to perform the conversion into binary and transfer it across the room. i encourage them
to think of the different tasks involved. the sender and receiver do different though related things. the recipient
will receive the number, assemble the string of binary and convert the binary back into a denary number.
■ (ct) decomposition of a problem
■ identification of the high-level steps necessary to accomplish the
whole task
■ (ct) algorithmic thinking
■ development of the ordering of the high-level steps necessary to accomplish whole task and working out the detailed steps for each.
obviously without an agreed protocol there is complete mayhem. pupils have to work together to agree a protocol for 1 (light on) and 0 (light off). the confusion continues until the pupils realise the time or clock element
that is needed so the start point is known and the light is either on or off for two seconds with a one second
pause between each on or off.
■ (ct) evaluation of functional correctness
■ pupils reflect on the problems (even mayhem) of initial solutions and
realise the need to improve them
■ (ct) algorithmic thinking
■ the trial and feedback development loop used between pupils is the
heuristic development of an algorithm
an alternative activity for pupils who have not yet fully grasped binary is to have them look at historical communication methods they have heard of such as morse code or smoke signals with a view to identifying similarities between them and the current challenge.
■ (ct) generalising a solution from one problem to another
■ identifying that in each case one representation (a letter) is transformed
into another (morse code), recognising a pattern in the solutions.
activity 5) a standard protocol is agreed amongst the whole class, this was achieved through a discussion of
the problems of interoperability if every pair has chosen a different way of communicating. they are then given 
a series of numbers the first two identifying the person (e.g. table-individual) and the next two being the message to that person (rather than an actual ip address at this stage of learning)
■ (ct) abstraction of data
■ understanding that an ip address is a name for a machine
pupils again struggle with this as it can be difficult with a long string of binary, so they are likely to come up with
an idea to chunk or group the binary. this is analogous to a packet.
■ (ct) abstraction of data
■ inventing the concept of a chunk or packet, with chunks being sent,
received and reassembled.
■ (ct) algorithmic thinking
■ working out the detailed instructions to make the chunking work.
activity 6) having mastered these concepts, we discuss ip addressing as analogous to the uk post code system.
■ (ct) generalising a solution from one problem area to another
■ recognising a pattern in the solutions to network packet sending and
sending a letter by post
future learning opportunities can be built on these foundations. for example, visual packet tracing tools can be
used to consider the location of web servers around the world. digital literacy questions can be posed about
breaking the law when using the internet and considering in which country a crime may have been committed.
what
from the activities discussed here, the pupils have had opportunities to use techniques associated with computational thinking concepts as indicated in order to demonstrate their understanding of the programme of
study content. depending upon the level of understanding expressed or observed in the pupil behaviours, it is
possible to award progress in the subject content from the computing pathways at the following levels:
pink level
■ algorithms: understands what an algorithm is and is able to express simple linear (non-branching) algorithms symbolically; demonstrates care and precision to avoid errors.
■ information technology: talks about their work and makes changes to improve it.
yellow level
■ algorithms: designs simple algorithms using loops and selection i.e. if statements; uses logical reasoning to predict outcomes; detects and corrects errors i.e. debugging, in algorithms.
■ information technology: talks about their work and makes improvements to solutions based on feedback received
orange level
■ algorithms: recognises that some problems share the same characteristics and use the same algorithm to solve both.
■ data & data representation: understands the difference between data and information.
■ communications & networks: understands the difference between the internet and internet service, for
example, world wide web.
■ information technology: makes appropriate improvements to solutions based on feedback received
and can comment on the success of the solution.
blue level
■ algorithms: designs solutions by decomposing a problem and creates a sub-solution for each of these
parts.
purple level
■ data & data representation: understands how bit patterns represent numbers and images; knows that
computers transfer data in binary.
■ communications & networks: understands data transmission between digital computers over networks, including the internet i.e. ip addresses and packet switching
■ algorithms: can identify similarities and differences in situations and can use these to solve problems.
■ information technology: uses criteria to evaluate the quality of solutions, can identify improvements
making some refinements to the solution and future solutions.
summary
to engage pupils in lessons and so get the best out of them, it is important that they understand why they are
learning topics. some materials supporting the previous ict curriculum focused on what was being taught,
(perhaps a skill) and what the pupils produced (perhaps a spreadsheet model). thinking about ‘what’ and
‘how’ the pupils were producing an artefact but ‘why’ they were learning a given skill were secondary considerations. the ‘why’ was often an assessment objective or a qualification examination instead of a real-world reason. criticism of this approach identified a lack of focus on understanding the deeper ‘how’ and ‘why’ (problems are solved, systems are made, …) (royal society, 2012).
the four-step framework we have set out gives a practical way to both understand computational thinking and
introduce the ideas into the classroom context. it can be used both to support the planning of activities to increase the opportunities for pupils to develop computational thinking skills and to assess their progress in doing so.
this can be achieved by considering the ‘why’ of the challenge they are setting for the learners at the outset.
pupils should then employ a variety of their computational thinking abilities as described in table 1 (the ‘how’)
to develop understanding or solve the problem in hand. the ‘what’ is expressed in the evidence of the actual
subject learning. this could be what the pupils produce (artefact), what the pupils understand or express
(write, test, verbalise), or what behaviour is observed (generalising). the ‘what’ matches the learning outcome
statements from the computing progression pathways assessment framework. figure 3 maps the four
stages of development described above to the notion of focusing on the ‘why’, ‘how’ and ‘what’.
figure 3: mapping the 4 stages of the framework to ‘why’, ‘how’ and ‘what’.
references
bcs, the chartered institute for it. 2014. call for evidence - uk digital skills taskforce. available: http://policy.bcs.org/sites/policy.bcs.org/files/bcs%20response%20to%20ukdst%20call%20for%20evidence%20final.pdf [accessed 26-06-2014].
department for education. 2013. the national curriculum in england, framework document. available: http://
www.education.gov.uk/nationalcurriculum [accessed 23-06-2014].
dorling, m. & walker, m. 2014a. computing progression pathways. available: http://community.computingatschool.org.uk/resources/1692 [accessed 23-06-2014].
dorling, m. & walker, m. 2014b. computing progression pathways grouped by cs, it and dl. available: http://
community.computingatschool.org.uk/resources/1946 [accessed 23-06-2014].
dorling, m. & walker, m. 2014c. computing progression pathways with computational thinking. available:
http://community.computingatschool.org.uk/resources/2324. [accessed 27-06-2014]
nettleford, w. 2013. primary school children learn to write computer code. available: http://www.bbc.co.uk/
news/uk-england-london-23261504 [accessed 23-06-2014].
peyton-jones, s. 2014. teaching creative computer science. available: http://tedxexeter.com/2014/05/06/simon-peyton-jones-teaching-creative-computer-science [accessed 23-06-2014].
royal society. 2012. shut down or restart? the way forwards for computing in uk schools. available: https://
royalsociety.org/~/media/education/computing-in-schools/2012-01-12-computing-in-schools.pdf [accessed 23-
06-2014].
selby, c., dorling, m. & woollard, j. 2014. evidence of assessing computational thinking. https://eprints.soton.ac.uk/366152 [accessed 23-06-2014].
selby, c. & woollard, j. 2013. computational thinking: the developing definition. available: http://eprints.soton.ac.uk/356481 [accessed 23-06-2014].
wing, j. 2006. computational thinking. commun. acm, 49, 3, 33-35. available: http://dl.acm.org/citation.cfm?
id=1118215 [accessed 23-06-2014].
wing, j. 2011. research notebook: computational thinking - what and why? the link. pittsburgh, pa:
carneige mellon. available: http://www.cs.cmu.edu/link/research-notebook-computational-thinking-what-andwhy [accessed 23-06-2014]. "
"developing computational thinking in the classroom: a
framework
june 2014
working group of authors:
prof. paul curzon
queen mary university of london, school of electronic engineering and computer science
teaching london computing project (http://www.teachinglondoncomputing.org/), funded by the mayor of london and department of education through the london school's excellence fund
mark dorling
bcs, the chartered institute for it and computing at school network of excellence project (http://www.computingatschool.org.uk), funded by the department for education, industry partners and awarding bodies
digital schoolhouse london project (http://www.digitalschoolhouse.org.uk), funded by the mayor of london
and department of education through the london school's excellence fund
thomas ng
west berkshire council school improvement adviser (ict & assessment)
dr. cynthia selby
bay house school and sixth form, gosport, hampshire
southampton education school, university of southampton
dr. john woollard
southampton education school, university of southampton
bcs, chartered institute for it barefoot computing project (http://www.barefootcas.org.uk), funded by the department for education
© copyright 2014 computing at school
this work is licensed under the creative commons attribution-non commercial license; see http://creativecommons.org/licenses/by-nc/3.0/ for details.
introduction
computational thinking sits at the heart of the new statutory programme of study for computing:
“a high quality computing education equips pupils to use computational thinking and creativity to understand and change the world” (department for education, 2013, p. 188).
this document aims to support teachers to teach computational thinking. it describes a framework that helps
explain what computational thinking is, describes pedagogic approaches for teaching it and gives ways to assess it.
pupil progression with the previous ict curriculum was often demonstrated through ‘how’ (for example, a software usage skill) or ‘what’ the pupil produced (for example, a poster). this was partly due to the needs of the
business world for office skills. such use of precious curriculum time however has several weaknesses. firstly,
the country’s economy depends on technological innovation not just on effective use of technology. secondly,
the pace of technology and organisational change is fast in that the ict skills learnt are out of date before a
pupil leaves school. thirdly, technology invades all aspects of our life and the typically taught office practice is
only a small part of technology use today.
in contrast, the new computing curriculum has an enriched computer science element. computer science is
an academic discipline with its own body of knowledge that can equip pupils to become independent learners,
evaluators and potentially designers of new technologies. in studying computer science, pupils gain not only
knowledge but also a unique way of thinking about and solving problems: computational thinking. it allows the
pupils to understand the digital world in a deeper way: just as physics equips pupils to better understand the
physical world and biology the biological world. simon peyton-jones gives an account of why learning computer science and computational thinking is a core life and transferable skill in a talk filmed at tedxexeter
(peyton-jones, 2014).
to prepare our pupils to understand the consequences of technological change, adapt when using technologies, develop new technologies or even to work in jobs that haven't yet been invented, not only does the
‘what?’ and ‘how?’ of the subject need to be taught, pupils also need to develop techniques to ask and be able
to answer the question ‘why?’. computational thinking supports doing so. computational thinking skills are the
set of mental skills that convert “complex, messy, partially defined, real world problems into a form that a mindless computer can tackle without further assistance from a human.” (bcs, 2014)
today, however, there is an interpretation, led by the popular media, implying that the new computing curriculum focuses on ‘coding’ (crow, 2014; nettleford, 2013). this gives a misleading message, especially to those
new to the discipline. in contrast, our framework presented below aims to support teachers’ understanding of
computational thinking across the full breadth and depth of the subject of computing and offers a way to easily
and effectively integrate it into classroom practice.
the framework
there are four interconnected stages of development to our computational thinking framework:
stage 1: definition
stage 2: concepts
stage 3: classroom techniques
stage 4: assessment
we overview each in the subsequent sections.
stage 1: definition
to support the sharing of curriculum materials and classroom practices, an agreed definition that is suitable for
the classroom is needed. we use the interpretation forwarded by professor jeannette wing, who originally
popularised the idea of computational thinking. she defines it as:
“… the thought processes involved in formulating problems and their solutions so that the solutions are
represented in a form that can be effectively carried out by an information-processing agent” (cuny,
snyder, wing, 2010, cited in wing, 2011, p.20) ... “these solutions can be carried out by any processing
agent, whether human, computer, or a combination of both” (wing, 2006).
we chose this definition because it is based on wing’s original definition and has gained consensus amongst
academics. its emphasis is on pupils performing a thought process, not on the production of artefacts or evidence. it therefore fits the direction of change in the current curriculum development.
stage 2: concepts
the next stage is to define the core concepts involved in computational thinking. based on a review of academic references, selby and woollard (2013) suggest the following are key:
■ algorithmic thinking
■ evaluation
■ decomposition
■ abstraction
■ generalisation
we outline these concepts with examples below, giving linked classroom techniques in the next section.
algorithmic thinking is a way of getting to a solution through clear definition of the steps - nothing happens
by magic. rather than coming up with a single answer, like 42, the pupils develop a set of instructions or rules
that if followed precisely (whether by a person or a computer) leads to answers to that and similar problems.
for example, we all learn algorithms for doing multiplication at school. if we (or a computer) follow the rules we
were taught precisely we can get the answer to any multiplication problem. once we have the algorithm we
don’t have to work out how to do multiplication from scratch every time we are faced with a new problem.
evaluation is the process of ensuring an algorithmic solution is a good one: that it is fit for purpose. various
properties of algorithms need to be evaluated including whether they are correct, are fast enough, are economic in the use of resources, are easy for people to use and promote an appropriate experience. trade-offs need
to be made as there is rarely a single ideal solution for all situations. there is a specific and often extreme focus on attention to detail in computational thinking based evaluation.
for example, if we are developing a medical device to deliver drugs to patients in hospital we need to be sure
that it always delivers the amount of drug set and that it does so quickly enough once start is pressed. however, we also need to be sure that nurses will be able to set the dose quickly and easily without making mistakes
and that it won’t be frustrating or irritating for patients and nurses to use. there is likely to be a trade-off to be
made between speed of entering numbers and helping avoid mistakes being made when doing so. the
judgement about it being quick and easy has to be made systematically and rigorously.
decomposition is a way of thinking about problems, algorithms, artefacts, processes and systems in terms of
their parts. the separate parts can then be understood, solved, developed and evaluated separately. this
makes complex problems easier to solve and large systems easier to design.
for example, if we are developing a game, different people can design and create the different levels independently provided key aspects are agreed in advance. through decomposition of the original task each part can
be developed and integrated later in the process. a simple arcade level might also be decomposed into several parts, such as the life-like motion of a character, scrolling the background and setting the rules about how
characters interact.
abstraction is another way to make problems or systems easier to think about. it simply involves hiding detail
- removing unnecessary complexity. the skill is in choosing the right detail to hide so that the problem becomes easier without losing anything that is important. it is used as a way to make it easier to create complex
algorithms, as well as whole systems. a key part of it is in choosing a good representation of a system. different representations make different things easy to do.
for example, when we play cards, we use the word ‘shuffle’. every player understands that ‘shuffle’ means
putting the cards in a random order. the word is an abstraction. the same type of abstraction works when
programming. implementing ‘shuffle’ in a computer game means giving a way to randomise the cards. we
can refer to shuffling throughout the program and understand what is meant without having to think about how
it is actually done by the program. all that is needed is that the program does include a description somewhere
of how shuffling is to be done.
as an example illustrating the difference the representation can make, consider an art project. pupils studying
monet could take a digital picture of a haystack painting in a gallery. in doing so they have created a representation of it on the computer as pixels. they can then easily manipulate this digital representation in ways that
would be very hard with a different representation or in the real world. for example, the colours could be
changed by an algorithm. in this way a series of different but related versions of the painting could be created.
generalisation is a way of quickly solving new problems based on previous problems we have solved. we
can take an algorithm that solves some specific problem and adapt it so that it solves a whole class of similar
problems. then whenever we have to solve a new problem of that kind we just apply this general solution.
for example, a pupil uses a floor turtle to draw a series of shapes, such as a square and a triangle. the pupil
writes a computer program to draw the two shapes. they then want to draw an octagon and a 10-sided shape.
from the work with the square and triangle, they spot that there is a relationship between the number of sides
in the shape and the angles involved. they can then write an algorithm that expresses this relationship and
uses it to draw any regular polygon. 
in summary, each of the above techniques fits into the well-established system design life cycle of computing
projects in the business, academic and scientific communities. in practice they are used together in a rich and
interdependent way to solve problems. the emphasis in these concepts is on practical techniques or thought
processes, not on the production of artefacts or evidence.
stage 3: classroom techniques
the descriptions of the concepts above are high-level. although important, on their own they don't explain how
computational thinking can be embedded into the classroom and integrated into pedagogy. therefore, our next
step (table 1) is to identify learner behaviours associated with each.
concept examples of techniques
algorithmic thinking writing instructions that if followed in a given order (sequences) achieve a
desired effect;
writing instructions that use arithmetic and logical operations to achieve a
desired effect;
writing instructions that store, move and manipulate data to achieve a desired
effect; (variables and assignment)
writing instructions that choose between different constituent instructions
(selection) to achieve a desired effect;
writing instructions that repeat groups of constituent instructions (loops/
iteration) to achieve a desired effect;
grouping and naming a collection of instructions that do a well-defined task to
make a new instruction (subroutines, procedures, functions, methods);
writing instructions that involve subroutines use copies of themselves to
achieve a desired effect (recursion);
writing sets of instructions that can be followed at the same time by different
agents (computers or people) to achieve a desired effect (parallel thinking and
processing, concurrency);
writing a set of rules to achieve a desired effect (declarative languages);
using a standard notation to represent each of the above;
creating algorithms to test a hypothesis;
creating algorithms that give good, though not always the best, solutions
(heuristics);
creating algorithmic descriptions of real world processes so as to better
understand them (computational modelling);
designing algorithmic solutions that take into account the abilities, limitations
and desires of the people who will use them;
evaluation assessing that an algorithm is fit for purpose;
assessing whether an algorithm does the right thing (functional correctness);
designing and running test plans and interpreting the results (testing);
assessment whether the performance of an algorithm is good enough;
comparing the performance of algorithms that do the same thing;
making trade-offs between conflicting demands;
assessment of whether a system is easy for people to use (usability);
assessment of whether a system gives an appropriately positive experience
when used (user experience);
assessment of any of the above against set criteria;
stepping through algorithms/code step by step to work out what they do (dry
run / tracing);
using rigorous argument to justify that an algorithm works (proof);
using rigorous argument to check the usability or performance of an algorithm
(analytical evaluation);
using methods involving observing a system in use to assess its usability or
performance (empirical evaluation);
judging when an algorithmic solution is good enough even if it is not perfect;
assessing whether a solution meets the specification (criteria);
assessing whether a product meets general performance criteria (heuristics)
decomposition breaking down artefacts (whether objects, problems, processes, solutions,
systems or abstractions) into constituent parts to make them easier to work
with;
breaking down a problem into simpler but otherwise identical versions of the
same problem that can be solved in the same way (recursive and divide and
conquer strategies)
table 1: computational thinking concepts and associated techniques.
examples of algorithmic thinking, evaluation, decomposition, generalisation and abstraction, are found at all
stages; it is the context that determines the relevance and challenge of the activity. we have therefore tried not
to attribute computational concepts and learner behaviours to particular key stages (phases of education) because doing so would imply that they are age-dependent in a way that they are not: they are capability dependent.
it is also important to emphasise that computational thinking concepts are not the content for the subject of
‘computing’. the subject content is set out in the national curriculum programme of study. computational
thinking skills enable learners to access parts of that subject content.
stage 4: assessment
the final stage needed is a way to assess the increasing competence of pupils in computational thinking. this
can be done using an adapted version of the existing subject framework for the computing subject itself.
to support classroom teachers, computing at school published an assessment framework called ‘computing
progression pathways’ (dorling and walker, 2014a). it sets out the major knowledge areas of computing and
gives specific indicators of increasing levels of mastery of the subject in those areas. this assessment framework was produced by a small team of authors and reviewers (all teachers and academics) based on their
classroom experiences. it is an interpretation of the breadth and depth of the content in the 2014 national curriculum for the computing programme of study. this breadth affords an opportunity to view the subject of computing as a whole, rather than the separate subject strands of computer science, digital literacy and information
technology proposed by the royal society (2012). the assessment framework identifies the dependencies and
interdependencies between concepts and principles as well as between the three subject strands.
abstraction reducing complexity by removing unnecessary detail;
choosing a way to represent artefacts (whether objects, problems, processes or
systems) to allow it to be manipulated in useful ways;
hiding the full complexity of an artefact, whether objects, problems, processes,
solutions, systems (hiding functional complexity);
hiding complexity in data, for example by using data structures;
identifying relationships between abstractions;
filtering information when developing solutions;
generalisation identifying patterns and commonalities in problems, processes, solutions, or
data.
adapting solutions or parts of solutions so they apply to a whole class of similar
problems;
transferring ideas and solutions from one problem area to another
separate pathways are given for the areas of algorithms, programming & development, data and data representation, hardware & processing, communication & networks and information technology.
for example, the pathway around the subject area of algorithms at its lowest level involves understanding of
what an algorithm is and an ability to express simple linear algorithms with care and precision. it then moves
through levels of being able to express more complicated algorithms using selection and loops, to at the highest level being able to design algorithms that make use of recursion as well as having an understanding that
not all problems can be solved computationally.
the assessment framework is also presented where the learning outcomes are organised by the separate subject strands of computer science, digital literacy and information technology (dorling and walker, 2014b). a further version has been developed to incorporate provision for the concepts of computational thinking (selby,
dorling and woollard, 2014). it now includes a description of how it can be used to acknowledge progression
and reward performance in mastering both the content of the computing programme of study and the ideas of
computational thinking (dorling, walker, 2014c). for example, algorithmic thinking is demonstrated not just in
the algorithms and programming & development pathways, but also in constructing appropriate search filters
(data & data representation) and in demonstrating understanding of the fetch-execute cycle (hardware &
processing). see figure 1 as an example of what you can expect to see in computing progression pathways
with computational thinking.
figure 1: mapping the learning outcomes from computing progression pathways to the concepts (from stage
2) of computational thinking. 
using the framework to plan lessons
when planning and teaching a scheme of work in any subject, teachers refer to the planning-teaching-evaluating cycle. computational thinking can be included in the planning stage in four steps within the planning phase
of each lesson in the planning-teaching-evaluating cycle, see figure 2.
step 1: determine the ‘why’ at the start of the unit of study (stage 1) as well as the possible topics (the column header names from the progression pathways assessment framework) that the scheme of work will be
covering.
repeat steps 2 - 4 when planning each lesson in a unit of study
step 2: decide ‘what’ the learning outcomes are for the lesson from the computing progression pathways assessment framework (stage 4), which enable the pupils to move closer to completing or achieving the ‘why’.
step 3: use the predefined mapping in the computing progression pathways assessment framework to identify the possible associated computational thinking concepts (stage 2).
step 4: use the computational thinking concepts to identify possible techniques ‘how’ to incorporate into and
highlight as part of the chosen classroom activities (stage 3). 
 figure 2: mapping the 4 stages of the framework to ‘why’, ‘how’ and ‘what’.
it is important to note that the most important step in this process is the last step (step 4). just because pupils
can evidence learning in the computing progression pathways assessment framework and that the learning
outcome is mapped to computational thinking, it does not necessarily mean that the pupils will have performed
computational thinking. completion of an activity, in itself, is not evidence that computational thinking has occurred.
a case study
below, we illustrate the application of the above framework with a case study, based around a lesson one of
the authors (dorling) has used in his classroom. in the sub-section of each activity, we highlight how different
parts of the activity draw on the computational thinking concepts (ct). in the classroom, these concepts could
be drawn out explicitly in, for example, a discussion at the end where the pupils reflect on the computational
thinking skills they have used through the activity.
topic
networking & communications - using a binary protocol to transfer information
why
i first lead a group discussion aiming to draw out why networks are important. we discuss the applications
pupils use on a regular basis, such as a search engine or network file shares and how these applications have
completely changed the way we do things. i lead pupils to ask “what actually happens in the wire to make information go back and forth?”
how
activity 1) recap - i remind the pupils that they have previously studied and understood the different layers
involved in computer architecture: applications, the operating system and the hardware.
■ (ct) abstraction of functionality
■ as we move from hardware to operating system to applications we
move through increasing layers of system abstraction as each hides the
messy details of the level below.
activity 2) i introduce the pupils to the layers of network architecture: application, transport and network and
point out the similarity to the computer architecture layers.
■ (ct) abstraction of functionality
■ in a similar way we move up through similar layers of abstraction from the
network to transport layer to applications as each hides the messy details of the level below.
■ (ct) generalisation of solution (applying the same technique to a similar problem)
■ we have transferred the technique of analysis by layers from computer
architecture to network architecture.
activity 3) i remind pupils of their understanding of denary (decimal) numbers stored as binary numbers, that
is denary numbers are an abstraction of the binary code. they hide the detail of how the numbers are actually
stored. i suggest that they could use this knowledge to invent their own transportation layer protocol.
■ (ct) abstraction of data
■ denary numbers conceal the complexity of the binary representation
activity 4) i give the pupils a simple circuit, i.e. a battery, wires and a lamp, and ask them to transfer a decimal
number across the room to a friend using the lamp.
it is up to the learners to perform the conversion into binary and transfer it across the room. i encourage them
to think of the different tasks involved. the sender and receiver do different though related things. the recipient
will receive the number, assemble the string of binary and convert the binary back into a denary number.
■ (ct) decomposition of a problem
■ identification of the high-level steps necessary to accomplish the
whole task
■ (ct) algorithmic thinking
■ development of the ordering of the high-level steps necessary to accomplish whole task and working out the detailed steps for each.
obviously without an agreed protocol there is complete mayhem. pupils have to work together to agree a protocol for 1 (light on) and 0 (light off). the confusion continues until the pupils realise the time or clock element
that is needed so the start point is known and the light is either on or off for two seconds with a one second
pause between each on or off.
■ (ct) evaluation of functional correctness
■ pupils reflect on the problems (even mayhem) of initial solutions and
realise the need to improve them
■ (ct) algorithmic thinking
■ the trial and feedback development loop used between pupils is the
heuristic development of an algorithm
an alternative activity for pupils who have not yet fully grasped binary is to have them look at historical communication methods they have heard of such as morse code or smoke signals with a view to identifying similarities between them and the current challenge.
■ (ct) generalising a solution from one problem to another
■ identifying that in each case one representation (a letter) is transformed
into another (morse code), recognising a pattern in the solutions.
activity 5) a standard protocol is agreed amongst the whole class, this was achieved through a discussion of
the problems of interoperability if every pair has chosen a different way of communicating. they are then given 
a series of numbers the first two identifying the person (e.g. table-individual) and the next two being the message to that person (rather than an actual ip address at this stage of learning)
■ (ct) abstraction of data
■ understanding that an ip address is a name for a machine
pupils again struggle with this as it can be difficult with a long string of binary, so they are likely to come up with
an idea to chunk or group the binary. this is analogous to a packet.
■ (ct) abstraction of data
■ inventing the concept of a chunk or packet, with chunks being sent,
received and reassembled.
■ (ct) algorithmic thinking
■ working out the detailed instructions to make the chunking work.
activity 6) having mastered these concepts, we discuss ip addressing as analogous to the uk post code system.
■ (ct) generalising a solution from one problem area to another
■ recognising a pattern in the solutions to network packet sending and
sending a letter by post
future learning opportunities can be built on these foundations. for example, visual packet tracing tools can be
used to consider the location of web servers around the world. digital literacy questions can be posed about
breaking the law when using the internet and considering in which country a crime may have been committed.
what
from the activities discussed here, the pupils have had opportunities to use techniques associated with computational thinking concepts as indicated in order to demonstrate their understanding of the programme of
study content. depending upon the level of understanding expressed or observed in the pupil behaviours, it is
possible to award progress in the subject content from the computing pathways at the following levels:
pink level
■ algorithms: understands what an algorithm is and is able to express simple linear (non-branching) algorithms symbolically; demonstrates care and precision to avoid errors.
■ information technology: talks about their work and makes changes to improve it.
yellow level
■ algorithms: designs simple algorithms using loops and selection i.e. if statements; uses logical reasoning to predict outcomes; detects and corrects errors i.e. debugging, in algorithms.
■ information technology: talks about their work and makes improvements to solutions based on feedback received
orange level
■ algorithms: recognises that some problems share the same characteristics and use the same algorithm to solve both.
■ data & data representation: understands the difference between data and information.
■ communications & networks: understands the difference between the internet and internet service, for
example, world wide web.
■ information technology: makes appropriate improvements to solutions based on feedback received
and can comment on the success of the solution.
blue level
■ algorithms: designs solutions by decomposing a problem and creates a sub-solution for each of these
parts.
purple level
■ data & data representation: understands how bit patterns represent numbers and images; knows that
computers transfer data in binary.
■ communications & networks: understands data transmission between digital computers over networks, including the internet i.e. ip addresses and packet switching
■ algorithms: can identify similarities and differences in situations and can use these to solve problems.
■ information technology: uses criteria to evaluate the quality of solutions, can identify improvements
making some refinements to the solution and future solutions.
summary
to engage pupils in lessons and so get the best out of them, it is important that they understand why they are
learning topics. some materials supporting the previous ict curriculum focused on what was being taught,
(perhaps a skill) and what the pupils produced (perhaps a spreadsheet model). thinking about ‘what’ and
‘how’ the pupils were producing an artefact but ‘why’ they were learning a given skill were secondary considerations. the ‘why’ was often an assessment objective or a qualification examination instead of a real-world reason. criticism of this approach identified a lack of focus on understanding the deeper ‘how’ and ‘why’ (problems are solved, systems are made, …) (royal society, 2012).
the four-step framework we have set out gives a practical way to both understand computational thinking and
introduce the ideas into the classroom context. it can be used both to support the planning of activities to increase the opportunities for pupils to develop computational thinking skills and to assess their progress in doing so.
this can be achieved by considering the ‘why’ of the challenge they are setting for the learners at the outset.
pupils should then employ a variety of their computational thinking abilities as described in table 1 (the ‘how’)
to develop understanding or solve the problem in hand. the ‘what’ is expressed in the evidence of the actual
subject learning. this could be what the pupils produce (artefact), what the pupils understand or express
(write, test, verbalise), or what behaviour is observed (generalising). the ‘what’ matches the learning outcome
statements from the computing progression pathways assessment framework. figure 3 maps the four
stages of development described above to the notion of focusing on the ‘why’, ‘how’ and ‘what’.
figure 3: mapping the 4 stages of the framework to ‘why’, ‘how’ and ‘what’.
references
bcs, the chartered institute for it. 2014. call for evidence - uk digital skills taskforce. available: http://policy.bcs.org/sites/policy.bcs.org/files/bcs%20response%20to%20ukdst%20call%20for%20evidence%20final.pdf [accessed 26-06-2014].
department for education. 2013. the national curriculum in england, framework document. available: http://
www.education.gov.uk/nationalcurriculum [accessed 23-06-2014].
dorling, m. & walker, m. 2014a. computing progression pathways. available: http://community.computingatschool.org.uk/resources/1692 [accessed 23-06-2014].
dorling, m. & walker, m. 2014b. computing progression pathways grouped by cs, it and dl. available: http://
community.computingatschool.org.uk/resources/1946 [accessed 23-06-2014].
dorling, m. & walker, m. 2014c. computing progression pathways with computational thinking. available:
http://community.computingatschool.org.uk/resources/2324. [accessed 27-06-2014]
nettleford, w. 2013. primary school children learn to write computer code. available: http://www.bbc.co.uk/
news/uk-england-london-23261504 [accessed 23-06-2014].
peyton-jones, s. 2014. teaching creative computer science. available: http://tedxexeter.com/2014/05/06/simon-peyton-jones-teaching-creative-computer-science [accessed 23-06-2014].
royal society. 2012. shut down or restart? the way forwards for computing in uk schools. available: https://
royalsociety.org/~/media/education/computing-in-schools/2012-01-12-computing-in-schools.pdf [accessed 23-
06-2014].
selby, c., dorling, m. & woollard, j. 2014. evidence of assessing computational thinking. https://eprints.soton.ac.uk/366152 [accessed 23-06-2014].
selby, c. & woollard, j. 2013. computational thinking: the developing definition. available: http://eprints.soton.ac.uk/356481 [accessed 23-06-2014].
wing, j. 2006. computational thinking. commun. acm, 49, 3, 33-35. available: http://dl.acm.org/citation.cfm?
id=1118215 [accessed 23-06-2014].
wing, j. 2011. research notebook: computational thinking - what and why? the link. pittsburgh, pa:
carneige mellon. available: http://www.cs.cmu.edu/link/research-notebook-computational-thinking-what-andwhy [accessed 23-06-2014]. "
"introducing computational thinking in education courses
aman yadav
dept of educational studies
purdue university
west lafayette, indiana, usa
amanyadav@purdue.edu
ninger zhou
dept of educational studies
purdue university
west lafayette, indiana, usa
zhoun@purdue.edu
chris mayfield
dept of computer science
purdue university
west lafayette, indiana, usa
cmayfiel@cs.purdue.edu
susanne hambrusch
dept of computer science
purdue university
west lafayette, indiana, usa
seh@purdue.edu
john t. korb
dept of computer science
purdue university
west lafayette, indiana, usa
jtk@purdue.edu
abstract
as computational thinking becomes a fundamental skill for
the 21st century, k-12 teachers should be exposed to computing principles. this paper describes the implementation and evaluation of a computational thinking module in
a required course for elementary and secondary education
majors. we summarize the results from open-ended and
multiple-choice questionnaires given both before and after
the module to assess the students’ attitudes toward and understanding of computational thinking. the results suggest
that given relevant information about computational thinking, education students’ attitudes toward computer science
becomes more favorable and they will be more likely to integrate computing principles in their future teaching.
categories and subject descriptors
k.3.2 [computer and information science education]:
curriculum
general terms
experimentation, measurement
keywords
computational thinking, k-12 education, non-majors
1. computational thinking in k-12
wing suggested that “computational thinking” (ct) is a
fundamental skill of analytical thinking for everyone, not
just for computer scientists [10]. she described computational thinking as “solving problems, designing systems, and
understanding human behavior, by drawing on the concepts
fundamental to computer science.” wing also pointed out
permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. to copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
sigcse’11, march 9–12, 2011, dallas, texas, usa.
copyright 2011 acm 978-1-4503-0500-6/11/03 ...$10.00.
the untapped potential of computational thinking for k-12
education by stating, “to reading, writing, and arithmetic,
we should add computational thinking to every child’s analytical ability.”
a report on computational thinking by the national research council (nrc) advanced a similar idea, that ct is
a cognitive skill which the “average person is expected to
possess” [5]. similarly, bundy suggested that computational
thinking concepts have been used in other disciplines via
problem solving processes, and that the ability to think computationally is essential to every discipline [4]. the pervasiveness of computational thinking concepts dictates the importance of exposing students to such notions early in their
school years and helping them to become conscious about
when and how to apply this essential skill.
the nrc report also highlighted “(1) that students can
learn thinking strategies such as computational thinking as
they study a discipline, (2) that teachers and curricula can
model these strategies for students, and (3) that appropriate
guidance can enable students to learn to use these strategies
independently.” teacher education is one discipline where
computational thinking will have significant impact. as we
prepare future educators to present their subject areas using
ideas from computational thinking, k-12 students will have
greater exposure to computing in general.
in this paper, we describe the implementation of a ct
module in two sections of a core education course required
for all elementary and secondary education majors. we
present a pre- and post-assessment of the education students’ understanding and attitude of computational thinking, which measured the influence the ct module had on
them. in particular, only 20% of the students on the presurvey described computing as, “the process of solving problems” as compared to 70% on the post-survey. on the presurvey, 30% of the students agreed that computing relates to
any or all fields, and the percentage increased to 62% on the
post-survey. overall, the ct module helped the students
understand that (1) they can teach computing concepts in
k-12 classrooms without the use of computers, and (2) ct
concepts can be incorporated across all disciplines.
computational thinking in education has the potential to
significantly advance the problem-solving skills of k-12 students. however, literature on implementing computational
thinking in a k-12 setting is still relatively sparse. there
465
have been a number of workshops on integrating computational thinking at the high school level [1, 6, 7]. but there is
little research that has systematically and comprehensively
examined the influence of computational thinking on preservice teachers (i.e., education students).
exploratory investigations have demonstrated how exposure to computational thinking enhances the way students
approach problems. for example, lewandowski et al. illustrated the idea of “commonsense programming” for students
without programming experience [8]. students were asked
to propose solutions to avoid selling theater tickets for the
same seat twice at multiple box offices. the results showed
that 69% of the solutions correctly identified a race condition, which indicated that the students were indeed equipped
with a natural but undeveloped understanding for solving
problems computationally.
several researchers have made the effort to introduce ct
to in-service computer science high school teachers during
workshop sessions that promote the awareness of integrating cs across all subject areas [3]. the high school teacher
participants were reported to have extended their understanding of the scope of cs and considered cs as more than
just programming. more importantly, a comparison of the
pre- and post-survey indicated that the realization of the
importance of “developing computational thinking skills for
all aspects of life” emerged as a result of the workshop.
an important step for successfully integrating computational thinking into the k-12 curriculum is to prepare future
teachers to teach it. section 2 briefly describes our efforts
to showcase a variety of ct concepts to pre-service teachers. in section 3, we present a summary of our pre- and
post-survey, which demonstrates a positive change of attitude among the students. we conclude the paper with an
overall discussion in section 4.
2. overview of the ct module
we developed a one-week computational thinking module
for the course “learning and motivation,” which is required
for all elementary and secondary majors. the course introduces future k-12 teachers to basic concepts of classroom
management, learning styles, student motivation, and assessment. the main content of the course includes theories
of learning and motivation, the role of formal and informal
assessment in fostering learning and motivation, and ways to
adapt instruction both to individual students and differences
in social, cultural, and contextual factors.
since computational thinking naturally includes problem
solving and understanding human behavior, it fits well with
the topics already covered in class, such as probabilistic reasoning, algorithms and heuristics, and hypothesis testing.
we replaced the originally presented unit on problem solving and critical thinking with new lectures on computational
thinking. the purpose of the ct module was not only to expose students to ideas in computing, but to show how these
ideas can be used in their future teaching careers as well.
faculty and students from educational studies and computer science jointly developed the lecture material. special emphasis was placed on highlighting the core concepts
of computational thinking, while presenting material the
students could relate to and easily apply in a k-12 classroom. the module was presented around the middle of the
semester, and students had not been exposed to ct material
in earlier lectures. before the ct module was introduced,
students had primarily studied educational theories on how
people learn.
the ct lectures provided students with an overview of
computational thinking and engaged them in activities that
showcased ct principles. students worked in pairs and each
pair was given a “clicker” to provide responses. see the appendix for an outline of the lectures and clicker questions.
the original slides are available on our website1.
the first lecture introduced students to the definition of
computational thinking and five basic ct concepts: problem
identification and decomposition, abstraction, logical thinking, algorithms, and debugging. the concepts were introduced through examples, activities, and clicker questions.
for example, debugging was discussed by asking students to
troubleshoot the scenario of a lamp not working when they
get home from school, but was working in the morning. students used clickers to respond to a sequence of questions to
locate the problem in order to make the lamp work again.
the second lecture focused on the role of computational
thinking in day-to-day life, and emphasized the importance
and application of ct in k-12 education. we discussed how
problem-solving, abstraction, and critical thinking can be
introduced in a classroom setting. the lecture highlighted
how computational thinking is a useful tool for dealing with
ill-defined problems, where there might not be a clear-cut
solution and information needed to solve the problem may be
missing. the lecture also presented information on how to
teach algorithms through kinesthetic activities and gave an
example of recursion. several members of our project acted
out the towers of hanoi (for n = 5). finally, we provided
examples of computational thinking in core content areas,
such as science and humanities.
3. attitude survey results
we assessed the students’ attitudes toward computing and
their understanding of computational thinking through a
pre- and post-survey surrounding the ct module. all 155
students from the two sections of the course were emailed a
link to the survey. 100 students — 78 female and 22 male
— completed both the pre-survey the week before the ct
module and the post-survey during the week after the ct
module. as a motivation to participate, extra credit was
given to students who completed both surveys (the pre- and
post-surveys were anonymous, but linked together via answers to security questions).
the surveys consisted of sixteen multiple-choice questions
(on a likert scale from strongly agree to strongly disagree)
and four open-ended questions — see the appendix for the
complete post-survey. an external evaluator was responsible
for collecting and validating the data. we analyzed the responses for patterns and significant differences between preand post-surveys. the most interesting results came from
the participants’ open-ended responses, which we present in
this section.
just over half of the students who responded (55) were
preparing to teach at the elementary level; the remainder
(45) at the secondary level. approximately 80% of the elementary education participants were female (44 vs. 11),
while at the secondary level, over 75% were female (34 vs. 11).
about 65% of the students enrolled responded to the survey.
1http://cs4edu.cs.purdue.edu/comp_think
466
a1 a2 a3 a4
0 20 40 60 80 100
69%
24% 20%
70%
7%
1% 4% 3%
pre−survey
post−survey
a1: to use computers and/or technology to solve
 a problem and make tasks easier
a2: the process of solving problems (use of
 computer or technology not mentioned)
a3: the study of computers
a4: other
figure 1: participants’ view of computing
3.1 participants’ view of computing
survey participants were asked to describe their view of
computing and its purpose. the basic trends of the participants’ responses differed greatly from the pre- to postsurvey, as shown in figure 1. (not all percentages add up
to 100% due to blank responses.)
on the pre-survey, a majority (69%) of the participants’
responses contained themes that viewed computing as solving problems or making tasks easier through the use of computers and/or technology. for example, one student stated,
“computing is the use of computers or some other form of
technology to solve a problem. its purpose is to help solve
problems that might be more difficult to solve without some
form of technology.” only 20% of participants’ responded
viewing computing and its purpose as the process of solving problems (use of computer or technology not mentioned).
the following comment highlights computing as a process of
solving problems without the use of computers or technology: “computing is the science of solving a problem using
some pre-set method that has been established. its purpose
is to assist us in solving everyday problems we might be
faced with.” finally, 7% of the students reported computing as the study of computers. for example, “being able to
use and apply computer skills to daily life. these skills can
run from typing to using different applications and software
in many different areas.”
in the post-survey, a majority of the participants’ responses (70%) reflected the basic trend that viewed computing as the ability/knowledge/process used to solve problems
and make tasks easier (use of computer or technology not
mentioned). for example, a student highlighted this view of
computing stating, “computing is where you logically think
something through. its purpose is so that students can explore to find an answer to a problem.” another student
reported, “i believe that computing does not necessarily involve working with computers but working to solve any type
of problem. its purpose is to calculate equations and problems to formulate a correct result.” on the other hand, 24%
viewed computing as solving problems or making tasks easa1 a2 a3 a4 a5 0 20 40 60 80 100
33%
86%
32%
0%
8% 7% 7% 7%
20%
0%
pre−survey
post−survey
a1: the process of solving problems
a2: to use computers and/or technology to solve
 a problem or make tasks easier
a3: the study of computers; solving problems
 like a computer
a4: other
a5: not sure
figure 2: participants’ view of ct
ier through the use of computers and/or technology. this
view is highlighted by the following comments: “computing
is using technology or computer software to aid in solving
problems. its purpose is to make difficult tasks easier and
simpler.” only one participant reported computing as the
study of computers.
by de-emphasizing technology and encouraging algorithmic thinking, the lectures helped the education students understand that computational thinking doesn’t always require
the use of computers to solve problems.
3.2 participants’ view of ct
in both the pre- and post-survey, participants were asked
to define computational thinking from their point of view.
figure 2 summarizes the basic trends in the participants’
responses between the pre- and post-surveys. although answers varied, we found basic trends among them. one third
(33%) of participants’ responses in the pre-survey reflected
trends that viewed computational thinking as “the process
of problem-solving,” which increased to 86% on the postsurvey. in addition, responses used more specific terminology and examples (e.g., pre-survey response: process of solving problems, post-survey response: process of solving problems using algorithms, etc.).
on the pre-survey, 20% of participants responded that
they “didn’t know” what their view on computational thinking was, and on the post-survey, none of the participants
responded that they “didn’t know.” additionally, on the
pre-survey, where almost one third (33%) of participants’
responses reflected trends regarding computational thinking
as “the use of computers or technology to solve a problem
or make tasks easier,” none of the participants’ responses
on the post survey reflected the idea that computers and
technology absolutely must be involved in the definition of
computational thinking.
in short, many more students identified the relationship
between problem solving and computational thinking after
receiving the ct module.
467
a1 a2 a3 a4
0 20 40 60 80 100
31%
86%
49%
7% 8% 6%
12%
1%
pre−survey
post−survey
a1: promote problem solving skills / critical
 thinking in the classroom
a2: utilizing computers and technology in the
 classroom
a3: other
a4: don't know
figure 3: integrating ct into the classroom
3.3 integrating ct into the classroom
survey participants were also asked how computational
thinking can be integrated into the k-12 classroom. figure 3 summarizes their responses. on the pre-survey, almost half of the participants’ responses reflected the view
that in order to integrate computational thinking into the
classroom, computers and technology were needed. in contrast, only 7% of participants’ responses reflected that trend
on the post-survey.
during the one week module, many students realized the
benefits of understanding ct principles and being able to
apply them more systematically as a problem solving technique. this change in attitude is also reflected in the question on whether ct promotes problem solving and critical
thinking skills. the responses switched from 31% agreeing
to 86% of the participants agreeing. also, it seems every student had some concept about computational thinking after
the module, as reflected by the “don’t know” category.
in summary, we saw almost a three-fold increase in the
number of education majors who now hold the opinion that
computational thinking could be used to enhance problem
solving activities in a k-12 classroom.
3.4 relationship to other fields
we also asked the students about the relationship of computational thinking to other disciplines. while 30% indicated that “computational thinking relates to any or all
fields” in the pre-survey, that number rose to 62% in the
post-survey. in addition, over 95% of the survey participants either agreed or strongly agreed with the following
statements: “computational thinking can be integrated into
classroom education in other fields,”“computational thinking should be integrated into classroom education for other
disciplines,” and “having background knowledge and understanding of computer science is valuable in and of itself.”
as future work, we plan to embed computational thinking modules in content area courses and teaching methods
courses, including hands-on training in how to implement
kinesthetic activities like computer science unplugged [2].
4. discussion
results from the two surveys suggest that the ct module
was effective overall in increasing the students’ awareness
of computational thinking. specifically, the post-survey responses were more sophisticated and showcased students’
understanding that computational thinking was more than
using computers and technology. students also had a better grasp of how computational thinking can be integrated
into their future teaching by promoting problem solving and
critical thinking skills (i.e., not by merely using computers).
these findings have important implications for incorporating computational thinking in education as well as other
subject areas. given that computational thinking is becoming a fundamental skill for the 21st century, it is important
to introduce it in disciplines outside of computer science
and at the k-12 level. specifically, computational thinking
concepts must appear as early as the primary grades, and
then continue through the secondary grades and beyond [9].
one way to do this is to incorporate computational thinking
modules into core education courses to expose future teachers to this idea. results from the current work suggest that
such an approach has the potential to change future teachers’ understanding of computational thinking and how it can
be integrated in their classrooms.
in summary, we have shown that given relevant information in computing, education students’ attitude toward computing becomes more favorable. they also see applications
of computing principles in their careers more readily. we
plan to repeat the ct module in “learning and motivation”
and are also developing an online version of the module for
“introduction to educational technology,” another course
required of all education majors. we hope that our approach
to ct modules will attract education students into computing courses that emphasize computer science principles, as
well as traditional programming courses.
5. acknowledgements
this work was supported by the nsf cpath program
under grant cns-0938999 and through a gift from state
farm. we especially thank courtney brown for her help
with the administration of the two surveys. we also appreciate the cs4edu team and the anonymous reviewers for
their thoughtful feedback on the paper.
6. references
[1] v. allan, v. barr, d. brylow, and s. hambrusch.
computational thinking in high school courses. in
sigcse, 2010.
[2] t. bell, i. h. witten, and m. fellows. computer science
unplugged. http://csunplugged.org/, december 2006.
[3] l. blum and t. j. cortina. cs4hs: an outreach
program for high school cs teachers. in sigcse, 2007.
[4] a. bundy. computational thinking is pervasive. journal
of scientific and practical computing, 1:67–69, 2007.
[5] committee for the workshops on computational
thinking. report of a workshop on the scope and
nature of computational thinking. the national
academies press, 2010.
[6] d. d. garcia, c. m. lewis, j. p. dougherty, and
m. c. jadud. if , you might be a
computational thinker! in sigcse, 2010.
468
[7] p. b. henderson, t. j. cortina, and j. m. wing.
computational thinking. in sigcse, 2007.
[8] g. lewandowski, d. bouvier, r. mccartney,
k. sanders, and b. simon. commonsense computing
(episode 3): concurrency and concert tickets. in icer
’07: proceedings of the third international workshop
on computing education research, 2007.
[9] j. a. qualls and l. b. sherrell. why computational
thinking should be integrated into the curriculum.
journal of comp. sci. in colleges, 25:66–71, 2010.
[10] j. wing. computational thinking. communications of
the acm, 49:33–35, 2006.
appendix
a. outline of the ct module
lecture 1: computational thinking and 21st
century problem solving
1. object lesson: driving directions
• “how do you get from school to the mall?”
clicker questions 1–2
• “how did you think about the problem?”
ct concepts: algorithm, efficiency
• “what if the main road was closed?”
ct concepts: debugging
• ”how do computers solve this problem?”
ct concepts: abstraction, automation
2. what is computational thinking?
• an approach to problem solving which uses abstraction to create algorithmic solutions which can be
automated with computation.
• a fundamental skill used by everyone by the middle
of the 21st century (i.e., just like reading, writing,
and arithmetic).
3. daily examples of ct
• looking up names in a phone book
• buying movie tickets (multiple lines)
• clicker question 3
• ct is . . . , ct is not ...
4. concept #1: abstraction
• “ct is reformulating a seemingly difficult problem
into one we know how to solve.”
• people standing in line → queue
• cafeteria plates → stack
5. concept #2: logical thinking
• inductive reasoning:
observation → pattern → hypothesis → theory
• deductive reasoning:
theory → hypothesis → observation → confirm
6. concept #3: algorithms
• activity: “peanut butter and jelly sandwich”
• explain “write it/ do it” (science olympiad)
• homework: “swap puzzle” on cs4fn.org
7. concept #4: debugging
• clicker questions 4–5
• discuss reasoning behind each answer
lecture 2: computational thinking in k-12
1. review of previous lecture
• clicker questions 1–3
• ct concepts: decomposition, abstraction, logical
thinking, algorithms, debugging, automation
• more definitions for ct
2. why is ct important for k-12?
• enhances problem solving techniques
• moves students beyond technology literacy
• ct is a higher-level cognitive process
3. ct and problem solving strategies
• heuristic: an experience-based strategy that facilitates problem solving
• algorithm: a specific sequence of steps that guarantees a solution
4. how do you teach algorithms?
• demonstrate specific procedures; apply examples
• help students explain their thinking and debug
• role play: towers of hanoi
5. using technology to motivate ct
• facebook friend network visualization
• google’s public data explorer
• amazon/netflix/etc recommendations
• “what other tools have you seen?”
6. applying ct to any content area
• science, social studies, economics, . . .
• social sciences, medicine, humanities, . . .
7. the big picture
• ct is a fundamental skill for everybody
• state of computing in secondary education
• highlight “cs principles” proposed ap course
b. clicker questions
lecture 1 (intro to ct)
1. how extensive were your directions?
[a] one step (e.g., type “mall” into gps or google maps)
[b] two steps (e.g., from downtown take bus #4)
[c] several steps (e.g., head east on sr-15 to 3rd street)
[d] a detailed, turn-by-turn route (e.g., from the union)
[e] none of the above (e.g., “man, i was way off!”)
2. how did you figure out the driving directions?
[a] knew them already; simply “recalled” the route
[b] sketched out a high-level map on paper
[c] thought about several ways, picked one
[d] texted a friend when no one was looking
[e] modeled the entire city as an undirected graph, solved
the “single-pair shortest path problem,” and applied it
to the source and destination
469
3. what is the quickest way to serve 20 pizzas to 60
hungry students?
[a] one table with pizzas (the usual case)
[b] five tables with four pizzas each
[c] people stay put and pizzas are passed around
[d] four servers bringing the pizza around
scenario: you come home and the desk lamp in your apartment stopped working (it worked in the morning).
4. what is your first step to solve the problem?
[a] check if the lamp is turned on
[b] check if the light bulb is working
[c] check if the lamp is plugged in
[d] check if the outlet is working
[e] check if there is power in the room
scenario: you checked a-e and it is still not working.
5: what do you do next?
[a] buy a new lamp
[b] call your mother/friend/landlord/etc
[c] use your roommate’s lamp
[d] repeat steps a-e from before
[e] forget about the problem for the day
lecture 2 (review of ct)
1. what are the two main ideas of computational
thinking?
[a] abstraction and automation
[b] algorithm and analysis
[c] debugging and logical thinking
[d] all of the above
2. computational thinking relies on the use of computer programs.
[a] true
[b] false
3. computational thinking mainly involves computer science and has little impact on other subject
areas.
[a] true
[b] false
c. post-survey
indicate whether you (1) strongly agree, (2) agree,
(3) disagree, or (4) strongly disagree.
1. knowledge of computing will allow me to secure a better job.
2. my career goals do not require that i learn computing
skills.
3. i doubt that i can solve problems by using computer
applications.
4. i expect to use software in my future educational and
career work.
5. i can achieve good grades (c or better) in computing
courses.
6. the challenge of solving problems using computer science appeals to me.
7. i expect to use computer applications for future projects
involving teamwork.
8. i can learn to understand computing concepts.
9. i am not comfortable with learning computing concepts.
10. i expect to use computing skills in my daily life.
11. i hope that my future career will require the use of
computing concepts.
12. i think that computer science is interesting.
13. i will voluntarily take computing courses if i were given
the opportunity.
14. computational thinking can be integrated into classroom education in other fields.
15. computational thinking should be integrated into classroom education for other disciplines.
16. having background knowledge and understanding of
computer science is valuable in and of itself.
open-ended questions
1. in your view, what is computing? what is its purpose?
2. in your view, what is computational thinking?
3. how can we integrate computational thinking in the
classroom?
4. how does computational thinking relate to other disciplines and fields? please provide specific examples.
470"
"vviewpoints
august 2008 | vol. 51 | no. 8 | communications of the acm 25
doi:10.1145/1378704.1378713 mark guzdial
education
paving the way for
computational thinking
drawing on methods from diverse disciplines—including computer science,
education, sociology, and psychology—to improve computing education.
t
eaching everyone on campus to program is a noble
goal, put forth by alan perlis in 1962. perlis, who was
awarded the first acm a.m.
turing award, said that everyone
should learn to program as part of a
liberal education. he argued that programming was an exploration of process, a topic that concerned everyone,
and that the automated execution of
process by machine was going to
change everything. he saw programming as a step toward understanding a “theory of computation,” which
would lead to students recasting their
understanding of a wide variety of topics (such as calculus and economics)
in terms of computation.4
today, we know that perlis was prescient—the automated execution of
process is changing how professionals of all disciplines think about their
work. as jeanette wing has pointed
out, the metaphors and structures of
computing are influencing all areas of
science and engineering.6
 computing
professionals and educators have the
responsibility to make computation
available to thinkers of all disciplines.
part of that responsibility will be
met through formal education. while
a professional in another field may be
able to use an application with little
training, the metaphors and ways of
thinking about computing must be
explicitly taught. to teach computational thinking to everyone on campus
may require different approaches than
those we use when we can assume our
students want to become computing
professionals. developing approaches
that will work for all students will require us to answer difficult questions
like what do non-computing students
understand about computing, what
will they find challenging, what kinds
of tools can make computational thinking most easily accessible to them, and
how should we organize and structure
our classes to make computing accessible to the broad range of students.
through a few brief examples, i
will show in this column how these
illustration by christopher silas neal
1_cacm_v51.8.indb 25 7/21/08 10:12:49 am
26 communications of the acm | august 2008 | vol. 51 | no. 8
viewpoints
questions are being addressed by researchers in the field of computing
education research. researchers in
computing education draw on both
computer science and education—
neither field alone is sufficient. while
we computer scientists understand
computing from a practical, rational,
and theoretical perspective, questions about education are inherently
human questions. humans are often
impractical, irrational, and difficult
to make predictions or proofs about.
computing education researchers are
using experimentation and design to
demonstrate we can address important questions about how humans
come to understand computing, and
how we can make it better. research
in computing education will pave the
way to make “computational thinking” a 21st century literacy that we can
share across the campus.
understanding computing
before programming
a research theme in the early 1980s
was how to design programming languages so they would be more like natural languages. an obvious question,
then, is how people specify processes
in natural language. lance a. miller
asked his study participants to specify
file manipulation tasks for another
person. a task might be “make a list of
employees who have a job title of photographer and who are rated superior,
given these paper files.” miller studied
the language used in his participants’
descriptions.2
one of miller’s surprises was how
rarely his participants explicitly specified any kind of control flow. there
was almost no explicit looping in any
of their task descriptions. while some
tested conditions (“if”), none ever
specified an “else.” he found this so
surprising that he gave a second set of
participants an example task description, without looping and no else
specification. the second set of participants easily executed the task description. when asked what they were
doing if the condition was not met, or
if data was exhausted, they replied (almost unanimously, miller reports), “of
course, you just check the next person,
or if there are no more, you just go on.”
miller’s results predict some of the
challenges in learning to program—
challenges that are well-known to
teachers of introductory classes today.
while process descriptions by novices
tend not to specify what to do under
every condition, computers require
that specificity. miller’s results suggest
what kinds of programming languages
might be easier for novices. programming languages like apl and matlab,
and programming tools for children
like squeak’s etoys use implicit looping, as did the participants in miller’s
studies.
twenty years later, john pane and
his colleagues at carnegie mellon university revisited miller’s questions,
in new contexts.3
 in one experiment,
pane showed his subjects situations
and processes that occur in a pacman
game, then asked how they would specify them. the subjects responded with
explanations like, “when pacman gets
all the dots, he goes to the next level.”
like miller, pane found that participants rarely used explicit looping and
always used one-sided conditionals.
pane went further, to characterize the
style of programming that the participants used. he found that over half
of the participants’ task statements
were in the form of production rules,
as in the example. he also saw the use
of constraints and imperative statements, but little evidence of object-oriented thinking. participants did talk
about accessing behaviors built into
an entity, but rarely from the perspective of that entity; instead, it was from
the perspective of the player or the
programmer. he found no evidence of
participants describing categories of
entities (defining classes), inheritance,
or polymorphism.
pane’s results suggest that objectoriented thinking is not “natural,” in
the sense of being characteristic of
novices’ task descriptions. since obfigure 1: traditional conditional structure.
if (value < 10)
then value = value + 10;
else sum = sum + value;
end if
figure 2: new conditional structure.
if (value < 10): value = value + 10;
not (value < 10): sum = sum + value;
end (value < 10)
www.acm.org/dl
acm digital library
theultimateonline
informationtechnology
resource!
• new! author profile pages
• improved search capabilities
• over 40 acm publications, plus
conference proceedings
• 50+ years of archives
• advanced searching capabilities
• over 2 million pages of
downloadable text
plus over one million
bibliographic citations are
available in the acm guide
to computing literature
to join acm and/or subscribe to
the digital library, contact acm:
phone: 1.800.342.6626 (u.s. & canada)
+1.212.626.0500 (global)
fax: +1.212.944.1318
hours: 8:30 a.m.-4:30 p.m., est
email: acmhelp@acm.org
join url:www.acm.org/joinacm
mail: acm member services
general post office
po box 30777
new york, ny 10087-0777 usa
dl_one-third_page_4c:layout 1 6/26/08 4:05 pm page 1
1_cacm_v51.8.indb 26 7/21/08 10:12:49 am
viewpoints
august 2008 | vol. 51 | no. 8 | communications of the acm 27
jects are the foundation of most modern software today, his results point out
where we can expect to find challenges
in explaining objects to students. both
miller’s and pane’s results encourage
us to think how we might design languages for novices that play to their
natural ways of thinking about specifying computation, like the use of eventbased programming in mit’s scratch.
in the last four years, a multinational group of researchers has explored
“commonsense computing”: what
do our students know before we teach
them? given a complex task, how do
people without programming knowledge specify an algorithm for that task?
in one paper, lewandowski et al.1
 explore concurrency—in a complex task
of multiple box offices selling tickets
for a theater, how well do non-programming students avoid selling the same
seat twice? the results showed that 97
solutions (69% of the total, drawn from
five institutions) were correct; only 31%
of the solutions (45% of the correct solutions) were distributed, so teachers
of algorithms classes need not worry
about being put out of business. noncomputing students do not naturally
come up with the elegant solutions
that computer scientists have devised.
however, these results suggest that
students can “naturally” think about
concurrency correctly. problems with
implementing concurrent programs
might stem more from the challenges
in specifying those algorithms in current programming languages, rather
than from the complexity of the algorithms themselves.
redesigning
programming languages
both pane’s and miller’s results make
suggestions about the design of programming languages if the goal is to
make computational ideas more accessible to novices. testing new forms of
programming languages was an area
of active exploration by thomas r.g.
green, elliot soloway, and others.
in one paper, green and his colleagues explored alternatives to the
traditional conditional structure.5
 a
typical structure might look like the
structure shown in figure 1. they tested a new structure where this would be
written as shown in figure 2. this new
structure makes explicit the condition
for the execution of each clause of the
condition. green and his colleagues
found that novices were able to correct mistakes using the second form 10
times faster than programs using the
first form.
miller and pane found that their
participants simply never used an else
clause. instead, it seemed obvious (“of
course”) what to do when the tested
condition wasn’t true. miller’s and
pane’s subjects were doing something
different than green’s. writing a task
description is different than reading
and fixing a task description. green’s
results complement miller’s and
pane’s. novices do not naturally write
the else clause—they think it’s obvious what to do if the test fails. however, conditionals in programs are not
always obvious, and it’s easier for the
novices trying to read those programs
if the conditions for each clause’s execution are explicit.
paving the way for
“computational thinking” for all
to make “computational thinking” accessible to students across the entire
campus, we need to understand how
to teach computing better. computing
education researchers explore how humans come to understand computing,
and how to improve that understanding. computing education research is a
close cousin to human-computer interaction, since hci researchers explore
how humans interact with computing
and how to improve that interaction.
computing education researchers
have found a home in the international
computing education research (icer)
workshop (whose fourth annual meeting will be held this september in sydney, australia; see www.newcastle.edu.
au/conference/icer2008/) and in journals like computer science education
and journal on educational resources
in computing.
computing education research
draws on a variety of disciplines to
make computing education better. social scientists like jane margolis, lecia
barker, and carsten schulte help us to
understand how students experience
our classes (which often differs from
what we might expect as teachers)
and how we can change our classes to
make them more successful for all students. computing education researchers draw on methods from education,
sociology, and psychology in order to
measure learning about computing
and understand the factors that influence that learning. by making computing education better, we can broaden
access to computing ideas and capabilities. when we can teach every
student programming and the theory
of computation in a way that makes
sense to them for their discipline, we
will see how ubiquitous understanding
of computing will advance the entire
academy, just as perlis predicted over
45 years ago.
references
1. lewandowski, g. et al. commonsense computing
(episode 3): concurrency and concert tickets. in
proceedings of thethird international workshop on
computing education research (2007), 133–144.
2. miller, l.a. natural language programming: styles,
strategies, and contrasts. ibm systems journal 29, 2
(1981), 184–215.
3. pane, j.f., ratanamahatana, c., and myers, b.a.
studying the language and structure in nonprogrammers’ solutions to programming problems.
international journal of human-computer studies 54
(2001), 237–264.
4. perlis, a. the computer in the university. in m.
greenberger, ed., computers and the world of the
future, mit press, cambridge, ma, 1962, 180–219.
5. sime, m.e., arblaster, a.t., and green, t.r.g.
structuring the programmer’s task. journal of
occupational psychology 50 (1977), 205–216.
6. wing, j. computational thinking. commun. acm 49,
3 (mar. 2006), 33–35.
mark guzdial (guzdial@cc.gatech.edu) is a professor
in the college of computing at georgia institute of
technology in atlanta, ga.
the communications “education” column will feature
commentary on education issues, presenting research
results and opinions that inform how the challenges of
computing education can be best addressed.
© 2008 acm 0001-0782/08/0800 $5.00
research in
computing
education will pave
the way to make
“computational
thinking” a 21st
century literacy that
we can share across
the campus.
1_cacm_v51.8.indb 27 7/21/08 10:12:49 am"
"computational thinking and tinkering: exploration of an early
childhood robotics curriculum
marina umaschi bers, louise flannery, elizabeth r. kazakoff*, amanda sullivan
tufts university, medford, ma, usa
article info
article history:
received 30 january 2013
received in revised form
22 october 2013
accepted 29 october 2013
keywords:
elementary education
interactive learning environments
pedagogical issues
teaching/learning strategies
robotics
programming
early childhood
abstract
by engaging in construction-based robotics activities, children as young as four can play to learn a range
of concepts. the tangiblek robotics program paired developmentally appropriate computer programming and robotics tools with a constructionist curriculum designed to engage kindergarten children in
learning computational thinking, robotics, programming, and problem-solving. this paper documents
three kindergarten classrooms’ exposure to computer programming concepts and explores learning
outcomes. results point to strengths of the curriculum and areas where further redesign of the curriculum and technologies would be appropriate. overall, the study demonstrates that kindergartners were
both interested in and able to learn many aspects of robotics, programming, and computational thinking
with the tangiblek curriculum design.
 2013 elsevier ltd. all rights reserved.
1. introduction
for decades, early childhood (preschool to grade two) curricula have focused primarily on literacy and math, especially with the
educational reforms of no child left behind (zigler & bishop-josef, 2006). however, there has been some recent attention to science,
technology, engineering, and math (stem) learning for young children (gelman & brenneman, 2004; sesame workshop, 2009; white
house, 2011). furthermore, new technology learning standards and best practices for integrating technology into early childhood education have been developed (barron et al., 2011; international society for technology in education (iste), 2007; naeyc & fred rogers center
for early learning and children’s media, 2012; u.s. department of education, 2010). of note, the technology policy statement from naeyc &
fred rogers center for early learning and children’s media (2012) provides a guide for early childhood education professionals in using
interactive digital technologies in balanced and developmentally appropriate ways. it addresses important issues related to using digital
technology with children ages three–eight years, including the needs for technology use to serve the needs of the children, and for educators
to be able to understand, evaluate, and integrate developmentally appropriate technologies in their classrooms. however, there is little
research on computer programming specifically for early childhood, the subject this paper explores.
as new devices, from smartphones and tablet computers to electronic learning toys, find new audiences with increasingly young
children, challenging question arise about how to define developmentally appropriate activities and content for children of different ages.
while the majority of research on robotics and programming in education focuses on later schooling, teaching these subjects during
foundational early childhood years can be an engaging and rewarding experience for young learners (bers, 2008). previous research has
shown that children as young as four–six years old can build and program simple robotics projects (bers, ponte, juelich, viera, & schenker,
2002, pp. 123–145; cejka, rogers, & portsmore, 2006; kazakoff, sullivan, & bers, 2012; perlman, 1976, p. 260; wyeth, 2008) as well as learn
powerful ideas from engineering, technology, and computer programming while also building their computational thinking skills (bers,
2008). robotic manipulatives allow children to develop fine-motor skills and hand–eye coordination while also engaging in collaboration and teamwork. additionally, robotics can provide a fun and playful way for teachers to integrate academic content with the creation of
* corresponding author. devtech research group, eliot pearson department of child development, 105 college ave., medford, ma 02155, usa. tel.: þ1 617 347 5746.
e-mail address: elizabeth.kazakoff@tufts.edu (e.r. kazakoff).
contents lists available at sciencedirect
computers & education
journal homepage: www.elsevier.com/locate/compedu
0360-1315/$ – see front matter  2013 elsevier ltd. all rights reserved.
http://dx.doi.org/10.1016/j.compedu.2013.10.020
computers & education 72 (2014) 145–157
meaningful projects. through robotics, young children can experiment with concepts of engineering as well as storytelling by creating
narrative contexts for their projects (bers, 2008). by engaging in these types of robotics projects, young children play to learn while learning
to play in a creative context (resnick, 2003).
computers offer new ways of representing and interacting with information and an entirely new category of “objects to think with”
(papert, 1980). in the form of programmable and interactive robots, computers can become powerful learning tools. robotics offers children
the opportunity to engage with content from the domain of computer science, practice problem-solving skills, and work on fine-motor skills
and eye–hand coordination. the tangiblek robotics program, a design-based research initiative now in its fifth year, has paired developmentally appropriate programming and robotics tools with a curriculum to engage kindergartners in learning computational thinking,
robotics and programming concepts, as well as problem-solving and reasoning. the goal of this paper is to present young children’s learning
outcomes on computer programming concepts as taught through the tangiblek curriculum in order to highlight the potential for learning of
integrating computer programming and robotics into the early childhood classroom.
1.1. theoretical framework: constructionism and positive technological development
the theoretical approach used for designing the educational intervention and curriculum and for integrating the tangiblek robotics
program into early childhood classrooms incorporates elements from papert’s (1980) constructionist framework, which states that children
can learn deeply when they build their own meaningful projects in a community of learners and reflect carefully on the process.
papert’s (1980) constructionism is rooted in piaget’s (1954) constructivism – which conveys the idea that the child actively builds
knowledge through experience – and the related “learn-by-doing” approach to education. while piaget’s (1954) theory was developed to
explain how knowledge is constructed in an individual’s mind, papert (1980) expands on it to focus on the ways that internal constructions
are supported by constructions in the world, including through the use of computers and robotics. a constructionist teaching approach
provides children the freedom to explore their own interests through technologies (bers, 2008) while investigating domain-specific content
learning and also exercising meta-cognitive, problem-solving, and reasoning skills (e.g., clements & gullo, 1984; clements & meredith,
1992). papert (1980) discussed that well-designed constructionist activities have embedded in them ‘powerful ideas’, central concepts
within a domain that are both epistemological and personally useful, interconnected with other disciplines, and have roots in intuitive
knowledge that a child has internalized over a long period of time (bers et al., 2002; papert, 1980). an idea may be considered powerful to
the degree that it is useful in building and extending further knowledge (papert, 2000). the robotics curriculum described in this paper is
composed of powerful ideas from the domains of computer science and engineering (e.g., the engineering design process, debugging,
robotic motion and sensing, using programming instructions, control flow by sequence, control flow by specific instructions).
classroom activities designed to impact learning outcomes and cognitive growth, also have an impact on (and are influenced by)
children’s social, emotional, and moral development. as a framework to guide the design and implementation of a robotics curriculum that
also focuses on these dimensions of the child, bers’ (2010, 2012) positive technological development (ptd) was utilized. ptd takes into
consideration the learning environment and pedagogical practices, as well as cultural values and rituals, which mediate teaching and
learning (bers, 2008; rogoff, goodman turkanis, & bartlett, 2001). the educational experience proposed by the presented robotics curriculum was structured using the ptd framework to encourage six behaviors, which in turn foster the development of beneficial core
cognitive and social traits. specifically, engaging in content generation, creative design and problem-solving, collaboration, communication,
choices of conduct, and community-building may lead to a sense of competence and confidence, the ability to connect with and care about
others, contribution to entities outside the self, and moral character (bers, 2010, 2012). for instance, by iteratively planning and revising a
robotics project in a supportive environment, children may gain confidence in their abilities to learn and solve problems. alternatively,
discussions of how to share limited resources fairly amongst the class are opportunities for positive moral development.
1.2. learning through computer programming
embedded in the exploration of computer programming and robotics, the tangiblek curriculum also fosters computational thinking. this
term has been defined in many ways and encompasses a broad and somewhat debated range of analytic and problem-solving skills, dispositions, habits, and approaches used in computer science (barr & stephenson, 2011; international society for technology education and
the computer science teachers association, 2011; lee et al., 2011). the tangiblek curriculum specifically fosters computational thinking
skills such as: problem representation; systematicity in generating and implementing solutions; exploring multiple possible solutions;
problem-solving on multiple levels – from approaching the overall challenge to “debugging” or trouble-shooting specific difficulties with a
given solution’s implementation; productive attitudes toward “failure” and misconceptions uncovered along the route to a successful
project; and strategies for approaching open-ended and often difficult problems. such skills are of general applicability beyond robotics and
computational thinking.
1.3. the tangiblek robotics program
the tangiblek robotics program, whose design is informed by the theoretical frameworks of constructionism and ptd, has iteratively
implemented and assessed a set of programming and robotics tools, curricula, and pedagogical approaches in close collaboration with
hundreds of children and dozens of teachers over the course of five years. the research goals of the tangiblek robotics program are to:
1) provide an evidence-based description of young children’s learning trajectories in computational thinking and capacity to understanding computer programming and robotics concepts when given developmentally appropriate materials,
2) develop and test an early childhood curriculum to teach developmentally appropriate concepts from computer programming and
robotics to children in kindergarten through second grade,
3) investigate the design features of the programming interface and the mediating role interface design plays in learning to program.
146 m.u. bers et al. / computers & education 72 (2014) 145–157
this paper addresses the first of these goals, to describe young children’s learning trajectories in computational thinking and capacity to
understand computer programming and robotics concepts. this understanding will allow further revision to the tangiblek curriculum.
the tangiblek robotics project makes use of commercially available robotics construction kits and the cherp (creative hybrid environment for robotics programming) language to give behaviors to the robotic constructions (bers, 2008; bers & horn, 2010; horn et al.,
2011; kazakoff & bers, 2012; kazakoff, sullivan, & bers, 2012). cherp is a hybrid tangible and graphical computer language designed to
provide young children with an engaging introduction to computer programming in a developmentally appropriate way. the software
allows children to create programs to control their robots from tangible wooden blocks and/or graphical, on-screen icons. the design of
cherp avoids the technical and syntax-related challenges of text-based programming languages. furthermore, the hybrid interface allows
children to choose the interface that best suits their changing preferences as physical abilities, perceived social appeal, and the level of
challenge of the activity at hand evolve (horn et al., 2011), because both tangible and graphical interfaces can represent the same concepts.
the tangiblek curriculum introduces increasingly complex powerful ideas from computer science in a robotics context in a structured,
developmentally appropriate way. the powerful ideas from computer science addressed in this curriculum include: the engineering design
process and debugging (trouble-shooting), robotic motion and sensing, and three aspects of programming: choosing the correct programming instructions, controlling the flow of actions by sequencing the action instructions accordingly, and controlling the flow of actions
by using special control flow instructions. section 2.3 contains more detailed definitions of each powerful idea. in addition to the concrete
robotics and programming concepts and skills introduced in each activity, skills such as observation, reflection, and decomposition of
complex processes are interwoven throughout the curriculum.
the curriculum, which takes approximately 20 h of classroom work, includes six structured 60- to 90-min activities and a culminating
interdisciplinary project. all the activities focus on building and programming a robotic vehicle to accomplish a particular goal. each lesson
addresses one or more powerful idea(s) within the context of a narrative theme. the six lesson activities and their embedded content are as
follows:
 lesson 1: the engineering design process
children build sturdy, non-robotic vehicles to transport toy people on a floor map. children apply the stages of the engineering design
process to plan, test, and improve their vehicles.
 lesson 2: robotics
children share and learn ideas about what robots are and are not. they explore robotic parts by designing and building their own robots.
they learn to appropriately connect robotic parts (e.g., snap-together wires and motors) to make a robot that moves.
 lesson 3: choosing and sequencing programming instructions
in this activity, children program their robots to dance the “hokey-pokey” by choosing relevant instructions and putting them in the
correct order or sequence.
 lesson 4: looping programs (control flow instructions 1)
children use “repeat” instructions to program their robots to move forward forever. next, they program their robot to move forward only
a particular number of times to reach a fixed location.
 lesson 5: sensors
children use light sensors to program their robots to turn its light on when it is dark out and vice versa. they draw comparisons between
robotic sensors and the five human senses.
 lesson 6: branching programs (control flow instructions 2)
children are introduced to a pair of conditional control flow instructions, “if” and “if not”, which are also used with a sensor to make
programs that incorporate environmental conditions into the robot’s behavior.
in addition to the structured activities described above, the tangiblek curriculum includes songs, games, and free-play with the robotics
and programming materials in order to foster a playful learning environment for children. for example, in lesson 3, children sing and dance
the “robot hokey-pokey” and play simon says with the cherp programming commands to recall and apply the programming instructions.
throughout the 20 h curriculum, children have ample opportunity to freely build and design with the robotics materials and to create their
own cherp programs, beyond those that are set forth in each of the structured lessons.
after completing the six lessons described above, each classroom embarks on a culminating, interdisciplinary project, which invite
children to apply the now familiar powerful ideas to a particular theme or context. the teacher decides on a theme drawn from other
subjects studied during the year, and each child chooses a challenge within this theme. past classrooms have selected topics such as animal
behaviors, vehicles that help the community, or “who am i?” children created projects representing snakes that slither, recycling trucks that
collect refuse, and sewing needles that travel back and forth through fabric, among many others. the projects allow children to demonstrate
the powerful ideas they learned over the six activities as well as to apply them and continue learning about them in a new context.
having introduced an overview of the tangiblek robotics program, including its technological, curricular, and theoretical components,
we now present a study of three kindergarten classrooms in which the tangiblek robotics program was implemented. the following
sections report the distribution of achievement scores children attained on selected computer programming concepts and skills tied to the
m.u. bers et al. / computers & education 72 (2014) 145–157 147
powerful ideas listed above. achievement scores form the basis on which to discuss the curriculum structure and content and consider the
implications for understanding children’s early learning trajectories of computational concepts and for further adaptation of the curriculum.
2. study design
within the design-based research tradition of iterative testing, analysis, and refinement of an intervention, (see, e.g., cobb, confrey,
disessa, lehrer, & schauble, 2003), the tangiblek robotics program has spent five years exploring what children are capable of learning
and accomplishing in the domains of robotics and programming. the study described in this paper examines how successfully children
learned the core concepts (powerful ideas) of robotics and programming in the tangiblek curriculum. the study took place during the fourth
year of the overall project, following piloting and refinement of the software and curriculum in a range of settings, from classrooms and
after-school/summer programs to the research lab. the extensive testing, exploration, and refinement of the preceding study iterations also
laid a foundation for understanding how young children learn and think about core concepts of programming and robotics. for instance,
several of the curricular activities were simplified to enable better focus on the target concepts; movement games and songs were added to
the curriculum to engage children in multiple modes of understanding concepts and to provide reinforcement for basic knowledge. in
addition, some of the programming icons were revised to use more familiar imagery for children.
2.1. participants
each of the three teachers involved in this study volunteered to participate following email notification of the opportunity to principals of
a limited number of schools in the greater boston area. all children in each classroom participated in the curriculum, but each family had the
option to allow or decline data collection. according to school community needs, consent materials were available in english, portuguese,
and spanish.
children in the study attended one of three greater boston area kindergarten classrooms, two of which were at a public urban school, and
one at a private suburban school. from a total of 63 children enrolled in the three classes during the study, 53 are included in data analysis.
children were included in data analysis unless they missed more than one activity or if data was not collectible for more than one activity.
attrition was due to typical classroom absences as well as the difficulty of collecting data with limited researchers in a bustling classroom
environment.
classroom 1, a kindergarten in an independent, k-8, religious-based, private school in a suburb of boston, ma, had 23 children, 18 of
whom are included in data analysis. the student population at this school was 97% white, 1% as asian, 1% as black, 1% hispanic (http://nces.
ed.gov/globallocator/). of the children in the kindergarten class, 50% were male and 50% were female. they ranged from ages 4.9 to 6.2 years
at the start of the study, with a median age of 5.6 years. the only kindergarten classroom at this school, this class was taught by a male
teacher with seven years of teaching experience, who, on a scale from 1 (none) to 5 (expert), rated his computer experience as 5, programming experience as 3, and robotics experience as 1.
classrooms 2 and 3 were located at the same urban k-8 school (nclb level 3), located just outside of boston, ma. the makeup of this
school during the 2010–2011 school year was 38.9% white, 36.3% hispanic, 16.2% african american, 7.0% asian american, and 1.7% multirace. the school was comprised of 41.1% english-language learners and 64.4% of students were classified as low income (massachusetts
department of education, 2006).
a female teacher with six years of teaching experience taught classroom 2. she rated her computer experience as a 4, robotics experience
as a 2, and programming experience as a 2. this classroom had 19 children enrolled, 17 of whom are included in the data analysis. of those 17
children, 59% were male and 41% were female. at the start of the curriculum, the children in this classroom ranged in age from 4.9 to 6.2
years old, with a median age of 5.6 years.
a female teacher with 15 years of teaching experience taught classroom 3. she also rated her computer experience as a 4, robotics
experience as a 2, and programming experience as a 2. the data analysis includes 18 of 21 children enrolled in this classroom. of the 18
participants, 44% were female and 56% were male. the children’s ages at the start of the curriculum in classroom 3 ranged from 5.6 to 6.5
years, with a median age of 6.0 years old.
the overall age range for the 53 children included in data analysis was 4.9–6.5 years, and their average age at the start of the curriculum
was 5.7 years old. over the three classrooms as a whole, 45% of the children were female and 55% male. the participants in this study are
thought to be generally representative of the general kindergartners population, as the sample includes both public and private school
students, both male and female teachers, a fairly even proportion of male and female students, and, as described above, a diverse range of
ethnic and socioeconomic backgrounds, particularly at to the participating public school.
2.2. procedure
each classroom’s head teacher and all research assistants (nearly 20 research collaborators in total) received training to prepare them for
teaching or assisting the robotics curriculum and participating in the research and data collection. the high number of assistants was needed
for two reasons. first, a low student-to-adult ratio in each lesson ensured adequate observation and documentation of students’ work.
secondly, most research assistants had limited availability across the full set of study sessions. therefore, attention was given to all collaborators’ to ensure they received careful and detailed training. the 3-h introductory training covered technical, curricular, and pedagogical
aspects of the program including how to use the cherp programming language and lego robotics kits as well as activity content and
training on the structure and the teaching approach framed by the ptd model presented earlier. the training also included explanation and
examples of how to score children’s work in each activity according to a scale of understanding levels, described below.
the teachers then implemented the tangiblek curriculum in their own classrooms with technical support from trained research assistants. two teachers used the curriculum with the whole class working together. the third teacher worked with half of the class at a time,
finishing the entire curriculum with one group before starting it with the other. each curricular activity took one to two 60–90 min session(s). the teacher introduced key concepts and the day’s activity in a whole-group setting along with a short song or game to reinforce the
148 m.u. bers et al. / computers & education 72 (2014) 145–157
concepts. as mentioned earlier, in lesson 3, each class sang and danced the “hokey-pokey” before programming their robots to do this
dance. additionally, the game “simon says” was often used in lessons 3–6 to reinforce the cherp programming instructions and their
corresponding robotic actions. after the whole-group activities, children built and/or programmed their own robotic vehicles. the children
worked independently on their projects but sat in groups of four and received support as needed from the research assistant or classroom
teacher at their group while also interacting with their peers. with the variety of coders evaluating children’s work, we systematically
accounted for potential intercoder differences by varying which adult worked with which children during each lesson. each session’s work
ended with a group discussion for children to share progress, questions, and successful strategies, and for the teacher to help reinforce the
core robotics and programming concepts and the engineering design process.
to assess learning outcomes after each activity, research assistants evaluated the robot and/or program made by each child. they
assessed the child’s level of understanding of selected core concepts as seen by successful application of the concepts in the robot or
program. if needed, they also talked with children to gain more information about their work and understandings. by examining, for
instance, the child’s program for correct selection and sequencing of action instructions or proper use of the “repeat” instruction, research
assistants scored each child’s achievement of the core goals of the lesson using the following 6-point likert scale designed to document the
thoroughness of the child’s understanding and application of activity-specific concepts and skills as well as their use of general problemsolving skills. a score of 4 or higher was defined as the target level of achievement.
5 complete achievement of the goal, task, or understanding
4 mostly complete achievement of the goal, task, or understanding;
3 partially complete achievement of the goal, task, or understanding;
2 very incomplete achievement of the goal, task, or understanding;
1 did not complete the goal, task, or understanding;
0 did not attempt/other.
in each lesson, children were scored on multiple concepts using this likert scale. for example, in lesson 3, children programmed their
robots to dance the “hokey-pokey” by 1) choosing the correct instructions (a skill referred to here as correspondence) and 2) putting the
instructions in the correct order (sequencing). the concepts of sequencing and correspondence are described in more detail in sections 2.3.2
and 2.3.3. as an illustration of the general scale, children received one point on the correspondence scale for each programming instruction
that correctly matched a line of the song. below are examples of children’s programs that were scored at each level of correspondence in
lesson 3:
5 begin, forward, backward, forward, shake, spin, end (all correct);
4 begin, forward, forward, forward, shake, spin, end (second forward should be backward);
3 begin, forward, backward, shake, end (missing forward and spin);
2 begin, shake, spin, end (missing forward, backward, forward)
1 begin, shake, end (missing forward, backward, forward, and spin).
0 despite assistance and prompting, the child did not attempt hokey-pokey task.
these same programs also received a 0–5 score for sequencing in lesson 3.
2.3. variables examined
to examine children’s growing computational thinking ability throughout implementation of the tangiblek curriculum, four key variables were observed and assessed: debugging, correspondence, sequencing, and control flow.
2.3.1. debugging
when faced with a difficult problem or task, children (and adults) are often unable to determine a suitable solution on the first attempt.
in these situations, “debugging” skills can be helpful. debugging, or trouble-shooting, is a form of problem-solving used in the fields of
engineering and computer science. it encompasses four steps: 1) to debug a problem, the child must first recognize that something is not
working or not meeting the stated goal. for example, a child programming her robot to dance the hokey-pokey in lesson 3 watches her
program running and realizes that the robot does not “shake it all about”. 2) in step 2 of the debugging process, children either decide to
keep their original goal or switch to an appropriate alternative. this child might continue to pursue the original plan of making the robot
dance all the parts of the hokey-pokey, or, as is common at this age, she might come up with an alternative, such as having their robot do a
different dance. 3) the third stage of debugging is generating a hypothesis as to the cause of the problem. the child in our example may
hypothesize that the program is missing an instruction that would make their robot shake. 4) finally, the last aspect of debugging is
attempting to solve the problem. the child might put a “shake” block in different positions in the program until the program fully matches
the song. debugging skills are not limited to the arena of engineering and computer science. previous research has found that children can
acquire and transfer debugging skills to activities outside of the programming context with appropriate support, including explicit instruction (klahr & carver, 1988; salomon & perkins, 1987).
the steps of the debugging process are a critical component of the engineering design process, which refers to the cyclical or
iterative process engineers use to design an artifact in order to meet a need (massachusetts department of education, 2006). as defined
by the ma curriculum frameworks, its steps include: identifying a problem, looking for ideas for solutions and choosing one, developing a prototype, testing, improving, and sharing solutions with others (see fig. 4). the steps of testing and improving, which require
debugging, are particularly important in establishing a learning environment where failure – rather than immediate success – is
expected and seen as necessary for learning. with the engineering design process, children are not expected to “get it right” the first
time.
m.u. bers et al. / computers & education 72 (2014) 145–157 149
in the tangiblek curriculum, debugging and the engineering design process were first introduced in lesson 1, and the concepts and skills
were applied throughout the rest of the curriculum. children were assessed on their ability to apply the four core aspects of debugging
(described above) in each lesson and final project.
2.3.2. correspondences between actions and instructions
a program is a sequence of instructions that a computer (in this case, a robot) acts out in an order specified by the programmer (stair &
reynolds, 2003). each instruction has a specific meaning, and the order of the instructions leads to the robot’s overall actions. making
correspondences between actions and instructions encompasses the understanding that each programming instruction represents a
specific action carried out by the robot.
another way to understand the process of correspondence is to frame it with the notion of symbols, a core concept that children
are learning in kindergarten in both math and literacy. each programming instruction is a symbol for the action the robot will
carry out. in order to program a robot’s behavior, children must understand in general that people use symbolic language to
communicate with computers, and they must select specific instructions to accurately represent their intended outcome for the robot’s
behavior.
correspondence was first introduced in lesson 3 of the curriculum, when students choose and sequence programming instructions to
make a robot dance the hokey-pokey. accomplishing this task requires children to identify the corresponding programming instruction for
each line of the “robot hokey-pokey” verse/dance. for example, a child who understands the correspondence between actions and instructions would find the programming instruction block with the “shake” symbol to recreate the line in which the robot “shakes it all
about”. to measure correspondence, children were assessed on how many of the correct instructions they chose.
2.3.3. sequencing instructions
sequencing is a component of planning, and involves putting objects or actions in the correct order (zelazo, carter, reznick, & frye, 1997).
to create a successful program, children must use procedural thinking and plan their programs in terms of a sequence of what happens next,
before, or until another action (pea & kurland, 1984). in both literacy and mathematics, sequencing is essential: for putting phonemes, letters,
words, or elements of a formula in the appropriate order (neuman & dickinson, 2002). prior research with the tangiblek project showed
that children who participated in the program earned significantly higher scores on a test of story sequencing than children who did not
(kazakoff & bers, 2012; kazakoff, sullivan, & bers, 2012).
in this curriculum, children were first introduced to the idea of sequencing instructions in lesson 3’s “hokey-pokey” challenge (described
above). sequencing was also a core component of lessons 4–6, in which children had to properly arrange action instructions and
increasingly complex control flow instructions in the correct order to achieve particular outcomes in the robot’s behavior.
2.3.4. use of control flow instructions
“control flow” refers to the concept that programmers can control the order in which a robot follows the instructions in its program
through various programmatic methods. this curriculum introduced children to control flow instructions and parameters. control flow
instructions allow the robot to carry out instructions non-sequentially, e.g., in a loop, or only under certain conditions. for example, a
cherp program can include a “repeat” control flow instruction in the following way: “begin, forward, repeat 3 shake, end-repeat,
sing, end”, to make the robot shake three times and then sing once. with the attachment of a light or touch sensor to the robot,
sensor parameters can also be used to qualify the control flow instructions based on environmental stimuli. for instance, a child can
program a robot to carry out an action or set of actions only “if (the environment is) dark” or “if light”, and another set of actions “if not
(light/dark)”. while there are currently no curriculum frameworks explicitly addressing control flow, these activities connect to
mathematics, by reinforcing number sense and estimation, or to natural science, by comparing human and animal sensory functions
with robot sensors. children are also able to compare and contrast repeating or looping programs to patterns, cyclical events in the
natural world, and calendar time. children were assessed on their correct use of control flow structures in lessons 4–6 and the final
project.
3. results
this section presents and compares children’s achievement on programming and debugging concepts and other skills taught using the
tangiblek robotics curriculum. since the focus of this work is on computational thinking in a robotic context, the assessments presented
here evaluate programming concepts instead of robotics knowledge. children’s work in each introductory lesson was assessed for two
relevant programming concepts. these concepts, seven in total, were reassessed in the final project. additionally, four debugging skills were
assessed in all lessons and the final project. each measure uses the likert scale shown above, which ranges from 0 (did not attempt the task)
or 1 (did not complete the goal, task, or understanding) to 5 (completely achieved the goal, task, or understanding). analysis was conducted
by aggregating scores from all classrooms and using paired-sample t-tests to compare scores on each concept from one lesson to the next.
findings are grouped by the powerful idea to which they relate. note that the teacher in classroom 1 chose not to formally teach activity 6,
so data for that activity’s items come only from two classrooms. a discussion about this choice is provided later in the paper.
3.1. debugging
average scores on the various debugging measures fell in the range of partial to mostly complete understanding and application of the
skill (see table 1). there was little variation in debugging scores between consecutive activities (see fig. 1), with the exception that the
average score on keeping the original goal was higher in activity 4 than in activity 5 (marked in table 1). in other words, children’s ability to
keep working on the original goal (or choose an acceptable alternative) was higher in activities that did not require the use of sensors and
sensor parameters. scores on the other three components of debugging remained steady in the mid-to-upper range of the achievement
scale across lessons.
150 m.u. bers et al. / computers & education 72 (2014) 145–157
repeated measures anova analyses (see table 2) were run for the four debugging skill variables across activities. the analyses were run
across all seven activities (or in the case of debugging skill 1, across the four activities where this skill was assessed). in addition, a separate
repeated measures anova was run for each debugging skill variable for just activities 1–5 since once classroom did not participate in lesson
6 and the project lesson was unstructured.
average debugging score did not vary significantly across activities when all lessons were considered. however, when removing the
challenge activity and lesson 6 where one class did not participate, a repeated measures anova for each debugging variable did show a
change across time, meaning there was, perhaps variation in debugging score across the more structure lessons, but, this variation averaged
out when children worked on their own projects.
3.2. powerful ideas of programming
in activities 3 through 6 and in the culminating project, students completed specific programming challenges and were assessed on their
ability to select instructions and put them in the order that would result in the goal behavior for the robot. activities 4–6 also used special
“control flow” instructions, which can tell the robot to loop through a set of actions repeatedly or to follow one “branch” of instructions or
another based on sensor data.
3.2.1. choosing the correct programming instructions
the overall mean score on students’ abilities to choose the correct instructions started off high in activity 3. scores then dropped, on
average, over activities 4 through 6, and returned to starting levels in the project (see table 3 for detailed means). as mean scores fell to
statistically significantly lower levels in activity 4 and again in activity 5, the percent of students reaching the target level of achievement
also dropped. seventy-six percent of students achieved in the target range on choosing programming instructions in activity 3, which used
only action instructions. in activity 4, which introduced the first of the control flow instructions, 70% of children achieved the target level, as
did only 46% in activity 5, which added the use of sensors and sensor parameters, and 62% in activity 6, which used a second, more
challenging type of control flow instruction. however, 77% of children reached the target level of achievement on their projects – a similar
rate to that in lesson 3, the first activity to require choosing programming instructions (see fig. 2).
3.2.2. control flow by sequencing
sequencing ability was also introduced in activity 3, along with making correspondences between intended robotic actions and programming instructions, when children made their robots dance the “hokey-pokey”. three-quarters of all students achieved in the target
range in this first programming activity. sequencing was also a core component of activities 4–6, in which children had to properly arrange
table 1
student scores on debugging.
debugging step 1 debugging step 2 debugging step 3 debugging step 4
n mean sd n mean sd n mean sd n mean sd
activity 1 43 4.19 0.98 45 4.22 0.80 42 4.00 1.08 43 4.16 1.05
activity 2 48 4.35 0.76 49 4.16 0.87 46 3.76 0.97 46 3.91 1.00
activity 3 31 3.97 1.11 39 4.21 0.95 33 3.67 1.27 34 3.77 1.28
activity 4 43 3.93 1.26 44 3.87* 1.23 43 3.46 1.32 43 3.72 1.30
activity 5 30 3.53 1.17 36 3.50* 1.23 27 3.22 1.19 30 3.50* 1.23
activity 6 27 3.44 1.25 28 3.89 1.23 26 2.96 1.28 27 3.41 1.42
project 28 3.97 0.92 29 4.42* 0.64 27 3.93 0.92 26 4.08* 0.69
note. classroom 1 did not do activity 6.
*denotes significant differences in the mean scores of the paired items at the p < 0.05 level. for debugging step 2 between activities 4 and 5, t(28) ¼ 2.04 and p ¼ 0.05. for
debugging step 2 between activity 5 (the last activity completed by all classes) and the project, t(19) ¼ 3.12 and p ¼ 0.01. for debugging step 4 from activity 5 to the project,
t(15) ¼ 2.55 and p ¼ 0.02.
fig. 1. mean achievement on debugging across activities. average debugging scores for each activity and project. all four debugging components appear to follow a similar trend,
but only the scores for keeping the original goal and attempting to solve the problem had statistically significant changes.
m.u. bers et al. / computers & education 72 (2014) 145–157 151
both actions and increasingly complex control flow instructions in the correct order. in these activities, 59%, 53%, and 68% of children,
respectively, achieved at the target level. fewer children were able to reach the target level of achievement for sequencing in these activities
than in activity 3. a comparison of mean scores on sequencing from one activity to the next revealed a statistically significant drop between
activities 3 and 4, differentiating programs with actions only from those requiring two-part control instructions as well (see table 4). as was
seen with correspondence scores, the average sequencing score on children’s projects was statistically significantly higher than the average
score in activity 5 (see fig. 2).
3.2.3. control flow by special instructions
activities 4–6 each introduced a new control flow instruction for creating looping or branching programs. students, on average, achieved
a “partially” complete understanding of the concepts (see table 5 for detailed means). less than 60% of students reached the target (“mostly”
complete) level of understanding on all but one of these measures. (this degree of understanding was reached by 53% for looping, 60% for
numeric parameters, 54% for sensor parameters, 68% for the first half of the conditional statement, and 41% for the second half of the
conditional statement.)
there were no differences in average scores found between looping and conditional instructions or comparing the different types of
parameters (see fig. 3). the only statistically significant difference in scores was between the two parts of the conditional statement (“if”
versus “if not”). that is, children were, on average, more comfortable making the programming equivalent of the statement “if it’s dark out,
turn the light on” and less comfortable appending “if not, turn the light off” to that first statement.
3.3. comparison of concepts between activities and projects
differences in children’s achievement on each of the above concepts from the introductory activities to the culminating projects were
examined in two ways. first, children’s scores from activity 5 (the last activity completed by all classes) were compared to children’s scores
on the final project. this continued the comparison of scores on consecutive activities. secondly, scores from the first activity that introduced
a particular concept were compared to corresponding scores from the final project. for example, sequencing scores from activity 3 (the first
activity using that concept) were compared to sequencing scores on the final project. this comparison was done to address how children’s
scores on the same concepts might change with time and exposure. we should note that due to the self-selected nature of the final projects,
not all children employed every concept to complete them, so n is relatively lower on these comparisons.
there were some statistically significant increases in scores from the final introductory activity completed by all classrooms to the
culminating projects were seen on two overarching programming concepts: choosing the correct instructions (see table 3) and sequencing
the instructions to accomplish the goal (see table 4), as well as on two elements of debugging (see table 1): sticking with the original goal or
choosing an acceptable alternative and taking steps to attempt to solve the problem. in fact, after these scores had dropped over the course
of the activities, they returned to starting levels in the final projects (as described in the relevant sections above).
table 2
repeated measures anovas by debugging steps.
a repeated measures anova was conducted to see if there was a significant difference in means of debugging level over time.
all possible activities without lesson 6 or project
df f p df f p
debugging step 1
sphericity assumed (4, 16) 1.559 0.23 (2, 50) 5.122 0.01**
debugging step 2
greenhouse-geisser correction (2, 4) 5.740 0.07 (3, 68) 5.157 0.00**
debugging step 3
greenhouse-geisser correction (2, 4) 4.586 0.10
sphericity assumed (4, 84) 9.192 0.00**
debugging step 4
greenhouse-geisser correction (1, 3) 2.682 0.23
sphericity assumed (4, 88) 6.404 0.00**
notes. classroom 1 did not do activity 6. the project was open-ended (children could choose to use less difficult blocks).
**denotes significance at the p < 0.01 level.
table 3
student scores on selecting programming instructions.
selecting instructions comparison to subsequent activity
n mean sd activity df t p
activity 3 45 4.24 1.07 – –– –
activity 4 50 3.88 1.04 3 42 2.47 .02*
activity 5 41 3.34 1.20 4 38 2.77 .01**
activity 6 34 3.65 1.30 5 25 0.73 0.47
project 48 4.15 0.92 6 29 1.19 0.25
5a 35 3.12 .00**
note. classroom 1 did not do activity 6.
**denotes significance at the p < 0.01 level; *denotes significance at the p < 0.05 level. a this comparison was made as an alternative to the activity 6-to-project comparison as it was the last activity completed by all three classrooms prior to the project.
152 m.u. bers et al. / computers & education 72 (2014) 145–157
it was anticipated that the children’s scores on the same concepts might increase with exposure, so comparisons were made between
children’s score on a concept in the activity that introduced it and the score on that same concept in the final project. however, there were
no statistically significant differences seen in any such comparisons (see table 6).
in summary, many children in each class reached the target level of achievement on the programming tasks over the course of the
curriculum’s six activities and culminating project. in the first three activities, which introduced the engineering design process, robotics,
and programming, children’s levels of achievement were particularly high (75%, on average, reaching target level of achievement). in activities 4–6, which introduced more sophisticated concepts and programming instructions, fewer children (56%, on average) attained the
same level of understanding.
many children achieved high scores on properly selecting and sequencing instructions when the programming activities involved only
action instructions (w75% for both skills) and in the final projects. achievement was comparatively lower in activities which involved the
conceptually and functionally more complicated control flow instructions and/or sensors (59% for both skills). programs that use special
control flow instructions visually appear linear, but the robot does not carry out one action per programming block, as it does with a
program containing only actions instructions; the logical flow of the program may be a loop or forked path rather than a line. this introduces
a conceptual complexity to programming with control flow instructions that does not exist with action instructions alone. similarly, it
appears based on relative scores that using the “if” instruction was simpler than using the “if not” instruction (68% versus 41% target
achievement). the complexity of each programming concept appears to be reflected in the portion of students who reached target levels of
understanding.
4. discussion
the results provide critical information on the accessibility of selected concepts from the fields of robotics and computer science for
kindergarten children, adding clarity to developmentally appropriate learning expectations in order to revise and improve both the
curricular activities and design features for early childhood robotics and programming technologies. the results also shed light on some of
the challenges of conducting design-based research in a classroom setting.
one interesting feature of the results is the trend of decreasing achievement scores across lessons 3–6. this is possibly related to
the amount of time spent on each topic. each activity in the curriculum introduced a progressively more challenging concept
than the activity before it. in the later lessons, children were asked to build on concepts they had only recently learned. while
each lesson was carefully designed to teach a particular topic and provide a space for exploration of it, these concepts may not
have been fully ingrained or mastered yet while new material was introduced. this could also help explain lower scores in the later
lessons.
another interesting result relates to the several concepts for which children’s average achievement scores increased from the final
introductory lesson to the culminating project. with statistical significance, children averaged higher scores on choosing and sequencing
fig. 2. mean achievement on choosing and sequencing instructions average scores for choosing and sequencing programming instructions according to the goal. the dip on both
choosing instructions (marked with *) and sequencing them (marked with þ) at activity 5 represents significantly lower scores as compared to activity 4 and the project. the drop
in score for choosing instructions at activity 4 is also statistically significant.
table 4
student scores on using sequencing for control flow.
sequencing instructions comparison to subsequent activity
n mean sd activity df t p
activity 3 49 4.23 1.16 – –– –
activity 4 40 3.69 1.14 3 41 2.79 .01**
activity 5 40 3.50 1.20 4 38 1.07 0.30
activity 6 34 3.74 1.19 5 25 0.53 0.60
project 49 4.08 1.04 6 30 0.25 0.80
5a 35 2.14 .04*
note. classroom 1 did not do activity 6.
**denotes significance at the p < 0.01 level; *denotes significance at the p < 0.05 level. a this comparison was made as an alternative to the activity 6-to-project comparison as it was the last activity completed by all three classrooms prior to the project.
m.u. bers et al. / computers & education 72 (2014) 145–157 153
instructions during the final project than in any introductory activity except the first (and simplest) programming activity. while assistant
from adults remained stable throughout all aspects of the curriculum and final projects, some other circumstances were different in the
project compared to the lessons. the improved scores might be attributed to the fact that children had more enthusiasm for these
personally-selected projects that would soon be part of a show-and-tell celebration as well as more time to experiment at their own pace
than in the lessons. alternatively, assuming children chose projects well-matched to their level of expertise, it would be reasonable to expect
higher demonstrated levels of achievement as their projects likely focused on concepts children already felt more comfortable using.
however, there were no statistically significant differences seen in comparisons of control flow instruction and sensor-related measures
between the activity that introduced each concept and the culminating project. it is possible that even more time exploring these concepts
was needed for significant learning gains to occur.
surprisingly, children did not always perform better on simpler concepts than on more complex ones. for example, the lack
of statistically significant differences between children’s understanding of looping versus conditional programs and between numeric
versus sensor parameters is unexpected both theoretically and based on anecdotal observations of these activities by researchers
present during the activities. the concepts associated with looping and numeric parameters should, in principle, be more straightforward than those involved in programming with conditional statements and sensor parameters. thus, at least somewhat higher
levels of achievement on looping and numeric parameters had been expected compared to conditional statements and sensor
parameters.
in some of the comparisons described above, the low n (less than half the overall study sample size) may have impacted the results. the
statistically significant findings may have varied if, for instance, the students for whom researchers could not collect data tended to have
above- or below-average achievement levels. as the activities in the curriculum increased in difficulty, the research assistants tended to
provide increased support for children with questions, leaving less time to equally observe and assess all children. in fact, it was also
observed that some children who perceived an activity to be difficult refrained from attempting it, resulting in no achievement scores for
that activity and a lower n on those measures.
4.1. curriculum discussion
while it is beyond the scope of this paper to fully evaluate the tangiblek robotics curriculum, results indicate that the curriculum was
generally engaging and developmentally appropriate for kindergarten students. results point to kindergarten teachers being able to
effectively implement the curriculum and to kindergartners being both interested in and able to learn and apply many aspects of robotics,
programming, and computational thinking. however, the fact that fewer children achieved the target level of understanding on more
complex topics than on the introductory concepts might indicate that the curriculum should devote more time for children to build up to
and fully explore the complex material in order to fully understand it. in order to test this, a new iteration of the curriculum is currently
table 5
student scores on using special instructions for control flow.
control flow instructions comparison to analogous concept
n mean sd concept df t p
looping instruction 49 3.61 1.17 – –– –
numeric parameters 50 3.76 1.17 – –– –
sensor parameters 41 3.59 1.12 numeric parameters 38 0.87 0.42
conditional (if) 34 3.74 1.24 looping instruction 31 0.00 1.00
conditional (if not) 22 3.32 1.21 conditional (if) 20 2.17 .04*
looping instruction 19 0.65 0.53
note. classroom 1 did not use conditional statements.
*denotes a statistically significant difference at the p < 0.05 level.
fig. 3. mean achievement on control flow concepts. a comparison of average scores for the different types of control flow instructions and parameters. the only significant difference in scores was between the two conditional instructions (marked with *).
154 m.u. bers et al. / computers & education 72 (2014) 145–157
being developed that will divide the prior curriculum based on action and sensing, and expand the number of lessons and amount of time
spent exploring each topic (particularly the more complex ones) in both structured and free-play-based formats to provide further opportunities for students’ investigation of concepts and to reinforce their learning. additional supporting activities will also be added.
kindergarteners vary widely in their levels of cognitive development and learning abilities, and such adaptations to the tangiblek curriculum may address this range even more than the current format already does.
the results also demonstrate the complexity of assessing sophisticated learning processes in a classroom setting. there was a necessary
trade-off built into the study design: gathering an adequately detailed picture of children’s learning had to be balanced with keeping data
collection feasible given that each adult was working with several children in the context of a full classroom. in some cases (particularly the
later activities), a different setting, such as individual-child sessions, may have provided a better context for some students to demonstrate
their abilities. however, the goal of the study was to examine the tangiblek program in a typical kindergarten classroom, and this endeavor
was successful. although ultimately some data could not be collected from every student on every measure, information was gathered about
the reality of implementing the curriculum in classroom settings and the supports necessary to meet the needs of all students.
4.2. limitations of the study and future directions
the tangiblek curriculum was taught during regular school hours in three schools in the greater boston area. there were both benefits
and drawbacks to conducting research in a school setting rather than an experimental setting. by testing the curriculum as taught by
kindergarten teachers, in both public and private schools, we have demonstrated that, given professional development in robotics education, a dedicated teacher can successfully teach this content in her or his own classroom. however, as with any study that takes place in a
school setting, the present study faced several environmental limitations. while each of the participating teachers taught the same curriculum, it is impossible to control for all teacher, classroom, and school variations that may have influenced results. for example, the three
teachers in this study were very different from one another. while some teachers allowed their class to work through difficult concepts on
their own, others gave more step-by-step instructions. teachers were given leeway to teach the curriculum in whatever way they believed
best suited the needs of their classrooms, however, this causes methodological issues for data analysis. further research should be conducted with a focus on how teaching styles and classroom culture serve to enhance or hinder a robotics curriculum.
fig. 4. an illustration of the engineering design process.
table 6
students scores on concepts in culmination project.
project scores comparison to introductory activity
n mean sd % scoring 4þ activity df t p
choosing instructions 48 4.15 0.92 77.0 3 40 0.70 0.49
sequencing 49 4.08 1.04 73.5 3 40 0.78 0.44
repeats 40 3.75 1.26 62.5 4 36 0.77 0.45
numeric parameters 32 3.94 1.22 65.6 4 30 0.77 0.45
sensors 18 4.05 0.73 83.4 5 15 0.94 0.36
sensor parameters 20 3.90 0.85 70.0 5 17 0.36 0.73
ifsa 14 3.57 0.80 78.6 6 (if) 13 0.27 0.79
note. classroom 1 did not do activity 6. a there was no separate measure for using “if not” instructions in the projects.
m.u. bers et al. / computers & education 72 (2014) 145–157 155
another drawback the study encountered was a fluctuating number of daily participants. children were fairly regularly absent,
temporarily out of the classroom, or otherwise unable to participate in the class. other times, the busy classroom and divided adult attention
prevented assessments from being collected for all children, particularly if an assessment required long and sustained periods of observation. teacher differences also impacted the low number of participants in some activities. for example, one teacher chose not to teach
lesson 6 in order to have more time to review previous concepts before the final project, drastically lowering the n for that lesson. further
research should be done expanding the scope of this study by gathering more participants and, if possible, ensuring more consistent
completion of each activity.
the present study inspires additional research agendas. while the focus of this work is on kindergartners, further investigations should
look at the way younger (prek-k) and older (1st–2nd grade) students are able to learn and apply the same powerful ideas. it would be
important to determine whether some of the concepts that were particularly challenging to the kindergartners in this study pose less of a
challenge with longer exposure or if introduced when children are older. further research will also expand the overall sample size as well as
the age and experience range of the sample. other work should attempt to assess the feasibility of implementing this curriculum for a
classroom teacher with typical support staff, that is, with minimal involvement of research assistants except for training teachers and
conducting data collection. in the present research, participating teachers each had about three trained assistants in the classroom to help
troubleshoot technology issues, assess the children’s progress, and provide one-on-one help as needed. for this curriculum to become
widespread, it will be necessary to know more about what supports teachers need (modifications to the curriculum, classroom management
alternatives, additional adult support, etc.) to successfully implement the curriculum. finally, it is beyond the scope of this current study, but
a follow-up study could look at longitudinal or transfer effects of the tangiblek curriculum. what concepts do the students retain? how is
computational thinking having an impact in other areas of their academic and extra-curricular lives? are children able to apply the engineering design process to other subject areas after completing this curriculum? further research should look at the long-term benefits of
incorporating programming and robotics into early childhood education.
it is important to note that many of the challenges that arose as part of the present study were posed by the robotics hardware itself, and
not the curricular activities. this highlights the importance of making developmentally appropriate hardware and software specifically
designed for young children. results show that for the children in this study, correctly connecting robotic parts proved more challenging
than understanding the function of each part or the underlying computational concept. this result is not surprising since the cherp
programming interface and the curricular activities introducing the robot’s parts and their purposes were specifically developed for kindergartners as part of this research project, while the robotics kit hardware was designed for older children as part of a commercially
available lego product. furthermore, children spent a significant amount of time fixing their robots, which came apart frequently. it was
challenging for many children to assemble some of the pieces on their own, and they needed adult help. if children had spent the robot
repair time working on their computer programs instead (and if teachers were able to spend that time providing support for learning the
central concepts rather than helping re-build robots), perhaps children would have attained higher levels of achievement in their understanding of complex powerful ideas involved in computational thinking.
the findings from this study have informed the tangiblek project, in which early childhood teachers (pre-kindergarten through 2nd
grade) will systematically implement a robotics curriculum revised according to several of the points outlined above. the teachers will
document their experiences and their students’ learning outcomes over the course of a school year using kiwi, a developmentally
appropriate robotics hardware that will replace the lego hardware used in this current study.
despite the limitations of the study described in this paper, post-study data collected from the teachers speaks to the success of the
tangiblek robotics program. all the teachers said they would participate in tangiblek again if given the chance. along with the general
success and enthusiasm of the children, this feedback highlights the overall positive and educational nature of the experience.
5. conclusion
the early childhood classroom is not typically a place where we expect to find students programming robots. yet, with the availability of
developmentally appropriate technologies, this is increasingly possible, and the result may be the advancement of technological fluency in
our nation’s youth. this paper explored the tangiblek robotics program as a viable option for classroom teachers to integrate developmentally appropriate technology education into the early childhood classroom.
with cherp, children spend their time building a robot, planning its actions, using physical wooden block or the computer screen to
construct programs, and iteratively improving the robot and programs according to initial goals and subsequent discoveries. because the
tangible programs and robots exist off-screen, children are drawn to investigate the work of other children, work collaboratively, and
negotiate sharing materials, as well as develop their fine-motor skills. these artifacts serve as points of discussion and reminders of the
activity content even after the computer has been turned off. as the analysis presented in this paper has explored, in this rich process of
creation in both the physical and digital worlds, children actively engage in problem-solving and learn powerful ideas from computer
science and robotics, including core concepts of computational thinking.
research is essential to understanding the impact of new technologies on the development of children and how children are using and
could be using these tools. as parents, educators, policymakers, and researchers it is our responsibility to ensure our children receive the
technological education needed for healthy development and a successful future. the tangiblek robotics program introduced in this paper
shows that when given age-appropriate technologies, curriculum and pedagogies, young children can actively engage in learning from
computer programming as applied to the field of robotics. they can then take their first steps into developing computational thinking.
acknowledgments
the tangiblek project was supported by national science foundation (nsf) drl-0735657. any opinions, findings, and conclusions or
recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the national science
foundation.
the authors would like to thank participating schools and teachers for their commitment to and participation in this project.
156 m.u. bers et al. / computers & education 72 (2014) 145–157
references
barron, b., cayton-hodges, g., bofferding, l., copple, c., darling-hammond, l., & levine, m. (2011). take a giant step: a blueprint for teaching children in a digital age. new york:
the joan ganz cooney center at sesame workshop.
barr, v., & stephenson, c. (2011). bringing computational thinking to k-12: what is involved and what is the role of the computer science education community? acm inroads,
2(1), 48–54. http://dx.doi.org/10.1145/1929887.1929905.
bers, m. u. (2008). blocks, robots and computers: learning about technology in early childhood. new york: teacher’s college press.
bers, m. u. (2010). beyond computer literacy: supporting youth’s positive development through technology. new directions for youth development, 128, 13–23.
bers, m. u. (2012). designing digital experiences for positive youth development: from playpen to playground. oxford university press.
bers, m. u., & horn, m. s. (2010). tangible programming in early childhood: revisiting developmental assumptions through new technologies. in i. r. berson, & m. j. berson
(eds.), high-tech tots: childhood in a digital world (pp. 49–70). greenwich, ct: information age publishing.
bers, m. u., ponte, i., juelich, k., viera, a., & schenker, j. (2002). teachers as designers: integrating robotics into early childhood education. information technology in childhood
education.
cejka, e., rogers, c., & portsmore, m. (2006). kindergarten robotics: using robotics to motivate math, science, and engineering literacy in elementary school. international
journal of engineering education, 22(4), 711–722.
clements, d. h., & gullo, d. f. (1984). effects of computer programming on young children’s cognition. journal of educational psychology, 76(6), 1051–1058. http://dx.doi.org/
10.1037/0022-0663.76.6.1051.
clements, d. h., & meredith, j. s. (1992). research on logo: effects and efficacy. retrieved from http://el.media.mit.edu/logo-foundation/pubs/papers/research_logo.html.
cobb, p., confrey, j., disessa, a., lehrer, r., & schauble, l. (2003). design experiments in educational research. educational researcher, 32(1), 9–13.
gelman, r., & brenneman, k. (2004). science learning pathways for young children. early childhood research quarterly (special issue on early learning in math and science),
19(1), 150–158.
horn, m. s., davis, p., hubbard, a., keifert, d., leong, z. a., & olson, i. c. (june 2011). learning sustainability: children, learning, and the next generation eco-feedback
technology. in proc. 10th international conference on interaction design and children (short paper). ann arbor, mi.
international society for technology in education. (2007). nets for students 2007 profiles. washington, dc: iste. retrieved from www.iste.org/standards/nets-for-students/
nets-for-students-2007-profiles.aspx#pk-2.
international society for technology in education and the computer science teachers association. (2011). operational definition of computational thinking for k-12 thinkingoperational-definition-flyer.pdf. international society for technology in education and the computer science teachers association.
kazakoff, e., & bers, m. (2012). programming in a robotics context in the kindergarten classroom: the impact on sequencing skills. journal of educational multimedia and
hypermedia, 21(4), 371–391.
kazakoff, e., sullivan, a., & bers, m. (2012). the effect of a classroom-based intensive robotics and programming workshop on sequencing ability in early childhood. early
childhood education journal, 41(4), 245–255.
klahr, d., & carver, s. (1988). cognitive objectives in a logo debugging curriculum: instruction, learning, and transfer. cognitive psychology, 20, 362–404.
lee, i., martin, f., denner, j., coulter, b., allan, w., erickson, j., et al. (2011). computational thinking for youth in practice. acm inroads, 2(1), 32–37.
massachusetts department of education. (2006). massachusetts science and technology/engineering curriculum framework. retrieved from. massachusetts department of
education http://www.doe.mass.edu/frameworks/scitech/1006.pdf.
naeyc & fred rogers center for early learning and children’s media. (2012). technology and interactive media as tools in early childhood programs serving children from birth
through age 8. joint position statement. washington, dc: naeyc. latrobe, pa: fred rogers center for early learning at saint vincent college. retrieved from www.naeyc.
org/files/naeyc/file/positions/ps_technology_web2.pdf.
neuman, s. b., & dickinson, d. k. (eds.). (2002). handbook of early literacy research. new york: guilford press.
papert, s. (1980). mindstorms. children, computers and powerful ideas. new york: basic books.
papert, s. (2000). what’s the big idea? toward a pedagogy of idea power. ibm systems journal, 39(3 & 4), 720–729. http://dx.doi.org/10.1147/sj.393.0720.
pea, r. d., & kurland, d. m. (1984). on the cognitive effects of learning computer programming. new ideas in psychology, 2(2), 137–168. http://dx.doi.org/10.1016/0732-
118x(84)90018-7.
perlman, r. (1976). using computer technology to provide a creative learning environment for preschool children. logo memo no 24. cambridge, ma: mit artificial intelligence
laboratory publications.
piaget, j. (1954). the construction of reality in the child. new york: basic books.
resnick, m. (2003). playful learning and creative societies. education update, 8(6). retrieved from http://web.media.mit.edu/wmres/papers/education-update.pdf.
rogoff, b., goodman turkanis, c., & bartlett, l. (2001). learning together: children and adults in a school community. new york, ny: oxford university press.
salomon, g., & perkins, d. n. (1987). transfer of cognitive skills from programming: when and how? journal of educational computing research, 3, 149–169.
sesame workshop. (2009). sesame workshop and the pnc foundation join white house effort on stem education. retrieved from http://www.sesameworkshop.org/
newsandevents/pressreleases/stemeducation_11212009.
stair, r. m., & reynolds, g. w. (2003). principles of information systems (6th ed.). boston, ma: course technology – itp.
u.s. department of education, office of educational technology. (2010). transforming american education: learning powered by technology. washington, dc: u.s. department
of education, office of educational technology. retrieved from http://www.ed.gov/technology/netp-2010.
white house. (2011). educate to innovate. retrieved from http://www.whitehouse.gov/issues/education/educate-innovate.
wyeth, p. (2008). how young children learn to program with sensor, action, and logic blocks. international journal of the learning sciences, 17(4), 517–550.
zelazo, p. d., carter, a., reznick, j. s., & frye, d. (1997). early development of executive function: a problem-solving framework. review of general psychology, 1(2), 198–226.
zigler, e. f., & bishop-josef, s. j. (2006). the cognitive child vs. the whole child: lessons form 40 years of head start. in d. g. singer, r. m. golinkoff, & k. hirsh-pasek (eds.),
play ¼ learning: how play motivates and enhances children’s cognitive and social-emotional growth (pp. 15–35). new york, ny: oxford university press.
m.u. bers et al. / computers & education 72 (2014) 145–157 157"
"(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
620 | p a g e
www.ijacsa.thesai.org
thinging for computational thinking
sabah al-fedaghi1
, ali abdullah alkhaldi2
computer engineering department
kuwait university, kuwait
abstract—this paper examines conceptual models and their
application to computational thinking. computational thinking is
a fundamental skill for everybody, not just for computer
scientists. it has been promoted as skills that are as fundamental
for all as numeracy and literacy. according to authorities in the
field, the best way to characterize computational thinking is the
way in which computer scientists think and the manner in which
they reason how computer scientists think for the rest of us. core
concepts in computational thinking include such notions as
algorithmic thinking, abstraction, decomposition, and
generalization. this raises several issues and challenges that still
need to be addressed, including the fundamental characteristics
of computational thinking and its relationship with modeling
patterns (e.g., object-oriented) that lead to programming/coding.
thinking pattern refers to recurring templates used by designers
in thinking. in this paper, we propose a representation of
thinking activity by adopting a thinking pattern called thinging
that utilizes a diagrammatic technique called thinging machine
(tm). we claim that thinging is a valuable process as a
fundamental skill for everybody in computational thinking. the
viability of such a proclamation is illustrated through examples
and a case study.
keywords—computational thinking; conceptual modeling;
abstract machine; thinging; abstraction
i. introduction
the cognitive faculty of thinking [1] involves processes by
which we reason and solve problems. ―computational thinking
is a fundamental skill for everybody, not just for computer
scientists. to reading, writing, and arithmetic, we should add
computational thinking to every child’s analytic ability‖ [2].
computational thinking is distanced from digital
literacy/competence, as it focuses on problem-solving
processes and methods and on creating computable solutions
[3]. it has been promoted as skills that are as ―fundamental for
all as numeracy and literacy‖ [3]. it goes beyond introductory
knowledge of computing to treat computer science as an
essential part of education today and presents a distinct form of
thought, separate from these other academic disciplines, where
diagrammatic techniques are used in analysis and strategic
planning [2]. in this perspective of computational thinking,
computer science modeling techniques are essential in many
aspects of modern-day research and in understanding things for
all people who expect to live and work in a world where
information is stored, accessed, and manipulated via computer
software [2].
wing [4] defined computational thinking as something that
―involves solving problems, designing systems, and
understanding human behavior, by drawing on the concepts
fundamental to computer science‖. it includes [3]:
 a thought process, thus independent of technology.
 a specific type of problem-solving that entails distinct
abilities (e.g., being able to design solutions that can be
executed by a computer, human, or both).
however, bocconi et al. [3] raised several issues and
challenges that must be addressed for the effective integration
of information technology in compulsory education, including
what are the core characteristics of computational thinking
and its relationship with programming/coding in compulsory
education? coding (programming) is regarded as a key 21st
century skill: ―coding is the literacy of today and it helps
practice 21st century skills such as problem-solving, modeling
and analytical thinking‖ [3]. the authors of european e-skills
manifesto [5] declared that ―skills like coding are the new
literacy. whether you want to be an engineer or a designer, a
teacher, nurse or web entrepreneur, you’ll need digital skills.‖
in this paper, we seek to contribute to the current debate on
computational thinking with particular focus on the following.
a. conceptualization
in computer science, conceptualization is the first stage of
the model-building process to arrive at a representation capable
of addressing the relevant problem. a conceptual model is
mainly formed upon concepts such as components of thinking.
it can provide a framework for thinking that structures notions
into patterns according to categories to provide a basis to
represent internal thinking in an external form. here, we use
this modeling in the sense of patterned thinking [6] (e.g.,
object-oriented modeling), where pattern refers to recurring
templates used by persons in the thinking process.
this paper promotes conceptual modeling that is based on
the heideggerian [7] notion of thinging as a framework for
computational thinking. heideggerian thinging is generalized
as an abstract thinging machine (tm) [8-13].
b. core concepts
as will be described in this paper, we propose five basic
concepts to model computational thinking:
 the notion of thing;
 the notion of tm;
 five flow operations of things: create, process, release,
transfer, and receive; and
 triggering.
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
621 | p a g e
www.ijacsa.thesai.org
c. programming/coding
a diagram can be coded, and the code and diagram
approximate the conceptual form of the programmer behind
both. a tm is expressed as a diagram that can be mapped to
programming/coding in the same way as flowcharts. it is
important to mention this property of the tm, even though it
will not be explored in this paper.
to achieve a self-contained paper, section ii reviews the
tm that was adopted in this paper and was used previously in
several published papers, as mentioned previously. section iii
presents examples of applying tm in computational thinking.
section iv applies the tm in an actual case study.
ii. thinging machine (tm)
drawing on deleuze and guattari [14], who declared—
admittedly from a different prospect—―all objects can be
understood as machines,‖ tm-based conceptual modeling
utilizes an abstract thinging machine (hereafter, machine) with
five stages of thinging, as shown diagrammatically in fig. 1.
in philosophy, thinging refers to ―defining a boundary
around some portion of reality, separating it from everything
else, and then labeling that portion of reality with a name‖ [15].
however, according to our understanding, thinging is when a
thing manifests or unfolds itself in our conceptual space. an
architect realizes the thing house, which in turn things (verb)
[7]; that is, it presents its total thingness, which includes living
space, shelter from natural elements, family symbol, etc. this
issue will be explained later in this paper.
our tm modifies heidegger’s [7] notion of thinging by
applying it to the life cycle of a thing and not just to its
ontological phase (producing). a thing things; in other words, a
bridge is not a mere object; rather, it establishes itself in a
conceptual realm as unified whole involving riverbanks,
streams, and the landscapes. when representing it, we can view
thinging as akin to an abstraction, but it differs in being
expansive instead of being reductive in detail.
in the tm, we capture thinging as a dynamic machine of
things that are created, processed, received, released, and
transferred—the operations of fig. 1. heidegger [7] offered an
example of thinging through the thing jug. when the clay is
shaped into a jug, the jug manifests itself—in heidegger’s
words—into ―what stands forth.‖ its thingness conquests and
entraps the void that holds and takes over its task of embracing
and shielding the penetrating wine, thus connecting itself to a
setting of vine, nature, etc. this conceptualization of the thing
jug comes as a reaction to the physical formation of the clay.
according to heidegger, ―we are apprehending it-so it seemsas a thing‖ [7] (italics added). the tm expands this thinging
by conceptualizing the jug not only through its existence but
also through its activities as a machine (an assemblage) that
creates (e.g., certain shape of void), releases, transfers (e.g.,
air), receives, and processes other things. it is not only a thing
that things but also a machine that machines (verb).
heidegger [7] distinguished between objects and things:
―the handmade jug can be a thing, while the industrially made
can of coke remains an object‖ [16]. the industrially made can
of coke has minimal thinging and maximal abstracting (see
later discussion). note that this does not apply to other
industrial devices that are not cut off from their ―roots.‖ the
thermostat, for example, is an industrial product that manifests
itself in its environment, as will be represented later in this
paper. for heidegger [7], things have unique ―thingy
qualities‖ [16] that are related to reality and therefore are not
typically found in industrially generated objects. according to
heidegger [7], a thing is self-sustained, self-supporting, or
independent—something that stands on its own. the condition
of being self-supporting transpires by means of producing the
thing. according to heidegger [7], to understand the thingness
of a thing, one needs to reflect on how thinging expresses the
way a ―thing things‖ (i.e., ―gathering‖ or tying together its
constituents into a whole). according to thomas et al. [17],
heidegger’s view can however be seen as a tentative way of
examining the nature of entities, a way that can make sense. an
artefact that is manufactured instrumentally, without social
objectives or considering material/spatial agency, may have
different qualities than a space or artefact produced under the
opposite circumstances.
the tm handles things and is itself a thing that is handled
by other machines. the stages in the machine can be briefly
described as follows:
arrive: a thing flows to a new machine (e.g., packets
arrive at a buffer in a router).
accept: a thing enters a machine; for simplification
purposes, we assume that all arriving things are accepted;
hence, we can combine arrive and accept into the receive
stage.
release: a thing is marked as ready to be transferred
outside the machine (e.g., in an airport, passengers wait to
board after passport clearance).
process (change): a thing changes its form but not its
identity (e.g., a number changes from binary to hexadecimal).
create: a new thing is born in a machine (e.g., a logic
deduction system deduces a conclusion).
transfer: a thing is inputted or outputted in/out of a
machine.
a tm also utilizes the notion of triggering. triggering is
the activation of a flow, denoted in tm diagrams by a dashed
arrow. it represents a dependency among flows and parts of
flows. a flow is said to be triggered if it is created or activated
by another flow (e.g., a flow of electricity triggers a flow of
heat) or activated by another point in the flow. triggering can
also be used to initiate events such as starting up a machine
(e.g., remote signal to turn on). multiple machines can interact
by triggering events related to other machines in those
machines’ stages.
fig. 1. thinging machine.
create
receive
release transfer
process
output input
accept arrive
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
622 | p a g e
www.ijacsa.thesai.org
iii. example
according to riley and hunt [2] in their book
computational thinking for the modern problem solver, an
abstraction is anything that allows us to concentrate on
important characteristics while deemphasizing less important,
perhaps distracting, details. abstraction is a core concept in
computational thinking in addition to such notions as
algorithmic thinking, decomposition, and generalization [3].
riley and hunt [2] stated that programmers are really a kind of
problem solver and that computer programmers are arguably
the most important of all modern problem solvers. the best
way to characterize computational thinking is through the way
computer scientists think, as well as the manner in which
computer scientists think for the rest of us. as a digital camera
uses a handful of focus points, computer scientists learn to
focus on the most important issues through abstraction [2].
the notion of abstraction goes all the way back to plato,
who proposed to distinguish abstract ideas as ideal entities that
capture the essence of things. they are abstraction, that is,
ideas that do not exist in the world. we can note two basic
aspects of abstraction:
 not being in reality,
 being reductive in details
abstraction is an important way of thinking, nevertheless,
we claim that thinging is also a valuable process as a
fundamental skill for everybody in computational thinking.
thinging takes a holistic view by, in contrast to abstraction,
being expansive in detail, as shown in fig. 2. thinging is an
abstraction-like process that deemphasizes reduction and hence
facilitates seeing the ―bigger picture.‖ note that thinging and
abstraction can be performed at several levels of expansion and
in reduction of details. fig. 3 illustrates the nature of thinging
as an inverse of realization in reality.
note the reductive nature of object-oriented modeling (e.g.,
uml) in the following example. as shown in fig. 4, riley and
hunt [2] abstractly described the thermostat, which involves a
class diagram rectangle consisting of three parts diagrammed
in three compartments. the middle compartment lists attributes
of the thermostat. the operations in a class diagram are listed
in the bottom compartment, where operations are abstract
references to the behavior of the object. the following model
presents an alternative conceptualization of the thermostat.
a. static tm of the thermostat
the thermostat can be represented as in fig. 5. in line with
the previous discussion on the thermostat, its thingness
includes switch (1), fan (2), and temperature (3). the switch
includes three signals, cool (4), off (5), and heat (6),
which flow to change the state (7) of the cooling/heating
machine (8). similarly, signals set the temperature (9) and
change the state of the fan (10).
b. behavior of the thermostat
behavior in a tm is represented by events. an event is a
thing that can be created, processed, released, transferred, and
received. it is also a machine that consists of (at least) three
submachines: region, time, and the event itself. as a side note,
we may conceptualize the tms as fourfold—that is, consisting
of space, time, event, and things.
fig. 2. thinging is an expansive reverse of realization in reality.
fig. 3. the thing jug things through its total thingness.
fig. 4. description of the class temperature (adapted from [2]).
fig. 5. the tm representation of the thermostat.
thing
reality
abstraction
thinging
object
reality
abstraction
thinging
…
thermostat
heatswitchsetting(cool/off/heat)
fansetting (on/auto)
temperaturesetting: integer
setminfunction(f: cool/off/heat)
setfan (b: on/auto)
settemperature (t: integer)
create create create
switch
thermostat
state
create
cooling/heating machine
cool off heat
receive receive
process process
create
process
transfer
release
transfer
release
transfer
create
transfer
release
transfer
temperat
ure
fan
receive
process
receive
transfer transfer transfer
receive
state
create
on auto
fan
release
transfer
release
transfer
1
3
5 6
4
7
8
9
10
create
transfer
release
transfer
process
receive
2
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
623 | p a g e
www.ijacsa.thesai.org
consider the event the switch turns off (see fig. 6). it
includes the event itself (circle 1 in fig. 6), the region of
programmers the things currently being dealt with in the event
(2), and the time machine (3). the region is a subgraph of the
static representation diagram of fig. 5. for simplicity’s sake,
we will represent an event by its region only.
accordingly, we can identify four basic events in the static
description of fig. 5, as shown in fig. 7:
 event 1 (e1): the switch is cool.
 event 2 (e2): the switch is off.
 event 3 (e3): the switch is heat.
 event 4 (e4): the temperature is set.
 event 5 (e5): the fan is on.
 event 6 (e6): the fan is auto.
these events can be written as statements of any
programming language.
c. control of the thermostat
a possible events chronology is shown in fig. 8, which
represents the permitted sequence of events. for example,
switching directly from cool to heat and vice versa
without first turning the cool/heat machine off is not
permitted. these sequences are shown in fig. 9 (a-e) as
follows:
1) the cool/heat machine is off,
a) select {cool or heat}, then fan {on fan, set the
temperature}.
b) select heat {select the state of the fan, set the
temperature}.
2) the cool/heat machine is on {cool or heat}, and
the fan is {on or auto}, switch fan to {on or auto}.
3) the cool/heat machine is on {cool or heat}, set the
cool/heat machine off.
4) the cool/heat machine is on {cool or heat}, set the
temperature.
5) the cool/heat machine is off, switch fan to {on or
auto}.
fig. 6. he event: the switch turns off.
fig. 7. the events of the thermostat.
fig. 8. chronology of events.
fig. 9. permitted sequence of control operations.
d. mapping to class notations
selecting the events is a design decision. tm representation
shows that riley and hunt [2] declared only three events
(fig. 10):
 event 1 (e1): the switch is cool/off/heat.
 event 2 (e2): the fan is off/auto.
 event 3 (e3): the temperature is set.
fig. 10. the events of the thermostat.
create
switch
thermostat
create state
machine
off
receive
process
transfer
release
transfer
region
(subdiagram)
create
process:
takes
course
transfer
receive
process:
consume
release
transfer
time
event
itself
e1
e2
e4 e3
e6 e5
create create create
switch
thermostat
state
create
cooling/heating machine
cool off heat
receive receive
process process
create
process
transfer
release
transfer
release
transfer
create
transfer
release
transfer
temperat
ure
fan
receive
process
receive
transfer transfer transfer
receive
state
create
on auto
fan
release
transfer
release
transfer
create
transfer
release
transfer
process
receive
e1
e2
e3
e4
e5
e6
e1
e2
e3
e5
e6
(a)
e1
e3
e5
e6
(b)
e1
e3
e4
(c)
e1
e2
e3
(d)
e5
e6
e2
(e)
create
switch
thermostat
state
create
machine
cool off heat
receive
process
create
transfer
release
transfer
create
transfer
release
transfer
fan temperature
receive
process
receive
transfer
state create
on auto
fan
release
transfer
e1
e2 e3
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
624 | p a g e
www.ijacsa.thesai.org
fig. 11. the switch representation in the 3-events (left) and 6-events
(right) designs of the thermostat.
fig. 11 contrasts the switch representation in the 3 and 6
designs.
the class notation given by riley and hunt [2] can be
viewed as mere names for data items and methods (processes)
that can be mapped to the tm, as shown in fig. 12. thus, we
can produce the class description from the tm representation.
the important point is that the object-oriented thinking
style, the class description, is produced before describing the
methods, whereas in the tm, the tm machines are developed
right from the beginning of the analysis. designing the
thermostat in terms of three events is the result of this object
orientation, which captures the three events because it does not
see all the possibilities of design.
fig. 12. tm and class entries.
consider the 3-events and 6-events designs. the 3-events
uses one wire between the thermostat and the cool/heat
machine, whereas the 6-events design uses three. each
implementation has its merits. the 3-events design is cheaper,
and the 6-events is more reliable. for example, in the 6-events
design, if heating does not work, the cooling feature will still
work when the link to the cool/heat machine is cut. the point
here is that the object-orientation, as discussed by riley and
hunt [2], does not seem to be aware of available alternative
designs. this is an important observation in the context of
thinking. according to do and gross [18], in design, ―drawing
is intimately bound with thinking.‖
iv. case study
the thermostat’s tm modeling is a small artificial example
of problem-solving by describing it conceptually. our case
study involves a large real problem: how to model a help desk
in a government ministry. in its actual environment (the
workplace of the second author), the maintenance process
starts when a user contacts the it department for help. the
department calls such a process the help desk process. it is a
problematic system that involves implicit contacts and
interactions in the alignment between it and business [19].
in this case study, the it department solved the help desk
problems using an ad-hoc technique that involves thinking of it
as a semi-automated system that is built piece by piece over
several years. there is no current documentation, even though
the manager of the help desk drew flowcharts that show the full
description of the processes behind how the help desk works
for different tasks, as shown in fig. 13. in projecting this
system on heidegger’s jug, in such an approach, this can be
viewed as failure to give thought to ―what the jug holds and
how it holds‖.
help desk operations are causing many types of
managerial, supervision, technical, and legal problems. a
possible solution is a holistic approach that involves all related
elements in the help desk system. it is a system that exists in
reality and needs a better understanding of its thinging. it is
misthinged or, in heideggerian language, a broken tool that
marks the annihilation of the ―equipmental thing‖ (it help
desk), in that helping cannot be gathered around it.
fig. 13. sample current documentation.
create
―cool‖
process
if cool if off if heat
release
transfer
transfer
receive
create create create
process process process
release
transfer
transfer
release
transfer
transfer
release
transfer
transfer
receive receive receive
cool off heat
cool off heat
create
―off‖
create
―heat‖
create
thermostat
state
create
machine
cool off heat
receive
process
create
transfer
release
transfer
create
transfer
release
transfer
receive
process
receive
transfer
state
create
on auto
fan
release
transfer
e3 e2
tempreture
setting: integer
setminfunction(f: cooloff/heat)
settempreture (t: integer)
setfan (b: on/auto)
fansetting
(on/auto)
heatswitchsetting(cool/off/hea
t)
e1
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
625 | p a g e
www.ijacsa.thesai.org
accordingly, we consider the question: ―how does the it
help desk operate?‖ we conceptualize it as a tm that creates,
processes, releases, transfers, and receives things. the helping
system includes things that are machines and machines that are
things unfolding an integrated wholeness that is itself part of
the ministry’s machinery. we focus next on thinging the it
help desk.
a. static model
accordingly, we model the help desk system, as shown in
fig. 14. in the figure, the user sends a request to the secretary
of the workshop (circle 1). the request is checked to decide
whether it is for repair (a) or for spare parts (b).
b. request for repair
the repair request flows to the workshop administrator (2),
where it is processed to do the following:
1) selecting a specific technician for this request: to
accomplish that, the list of technicians is processed (4) to
generate the name of a technician (5).
2) creating a task (ticket): additionally, the administrator
creates a new task form (6) that includes the request
description (7) and the technician’s name (8).
the task then flows (9) to the technician, who later
examines the task to decide on the following:
1) given that it is possible to call the user and solve the
problem by phone (10), the technician places a phone call (11)
to the user and guide the user step by step to solve the problem
through the phone (12).
2) the technician is required to go to the user’s workplace
(13) to solve the problem by him-/herself (14). the technician
moves from the workshop to the user’s location (15). the user
brings the computer to the technician to work on it and repair
it (16).
after processing the computer (17), the technician has one
of the two following outcomes:
1) the computer is not repaired (18), and the technician
takes it back to the workshop. there, it is fixed (19), and the
workshop admin (20) transfers the fixed computer back to the
user (21).
2) the computer is repaired (22) and transferred back to
the user (23 and 24).
both previous outcomes lead to (25), where the user gets
the computer and processes it to see whether it is repaired:
1) the computer works fine (26); as a result, the user
creates a report (27) to close the request and sends this report
to the workshop admin (28).
2) the computer repair is not satisfactory (29), and the
user creates a follow-up request (30) for repair and sends it to
the secretary (a).
request for spare parts
the spare parts request flows to the inventory department
(31), where it is processed (32) to extract the quantity of
current spare parts in the inventory (33) and to transfer it to a
program that checks this quantity of spare parts (34):
1) if the number is zero, the number of the pending
requests would be incremented by one (35). moreover, the
request would be released (36) and added to a queue of
pending requests (37).
2) if the number is greater than zero, the request is
processed again (38 and 39) to extract the requested quantity
of spare parts (40).
note that we renovated an existing system and did not
design the best model for this application. for example, it is
possible to define the minimum value of inventory instead of
permitting it to reach zero. thus, our thinging of the system is
tailored to the existing requirements.
both the numbers of the requested items (41) and current
quantity (42) are transferred to a program that calculates the
available quantity (43) that can be delivered to the requester. a
simple formula calculates what is called remaining quantity as
follows:
remaining quantity = current quantity – requested quantity (44)
accordingly, two possibilities arise:
1) the remaining quantity is greater than or is equal to
zero (45); in other words, the full requested quantity can be
provided to the user. in that case, the request is released (46)
and transferred to the storage, where it is received and
processed (47) and the stored spare parts are sent to the
requester (48).
2) the remaining quantity is less than zero (49); as a
result, a new quantity called pending is created and calculated
as the following:
pending = requested quantity – current quantity
accordingly, a new request that specifies the quantity that
is currently in the possession of the inventory department is
created (50) and forwarded to the storage, and then steps (46-
48) are repeated. also, a new request that specifies the number
of pending quantities is created and considered as a new
request (51).
in parallel, according to a certain schedule (52), the list of
pending requests is processed, and each request (the loop is
specified in the dynamic tm model) is taken out and processed
to create a pending request (53) that, in turn, is processed, thus
leading to the creation of an ordered quantity (54). the ordered
quantity is added to the total number of ordered items (55).
later, the total number of ordered items (56), along with the
current quantity (57), flows to a committee for examination,
and the evaluation of the need for new spare parts is processed
(58). hence, a decision is created (59) and processed for
making orders (60), which flow to the workshop admin (61).
in the workshop admin, the orders are processed to (62)
create orders to the suppliers (63) and transfer these orders to
the purchase department (64). there, each order is processed
(65) and put on hold while waiting to assign a budget (66). a
request for a budget is created (67) by the purchase department
and is transferred to the budget department (68). the budget 
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
626 | p a g e
www.ijacsa.thesai.org
department processes the budget request, (69) approves it, and
then sends the approval to the purchase department (70). in the
purchase department (71), the approval is processed, thus
leading to placing an order to the supplier (72).
fig. 14. the tm representation of the it department help desk system.
workshop admin
5
receive
transfer
process
3



 report to close request
computer
receive
process:
transfer
transfer
release receive
release
transfer
if not
repaired
if repaired
technician
with computer
if
acceptable
else
user
process:
technician
(in user place)
storage

budget department

order
budget approval workshop
inventory
department
orders

requester
process:
remaining quantity = current quantity –
requested quantity
if remaining < 0
pending = requested quantity – current
available = current
if remaining >= 0

 process:
 if current quantity is 0

 if current quantity is greater than 0

checking current quantity
requested quantity

current quantity

list of pending requests no. of requests in pending add 1
checking available quantity
release create
stored spare parts
-
release
create
receive
release
transfer
transfe
r
receive
transfer
requested quantity or
available quantity

release
transfer

create total ordered
items
transfer
transfer
pending request
create process

create process
ordered quantity
process

request budget
purchase department
transfer release create
receive
transfe receive
r
committee transfer receive
transfer
current
quantity
receive
transfer
process

create process
decision
supplier
release process
transfer
process
workshop
admin
receive
transfer
process
release
transfer
transfer
receive
transfer release create
transfer receive process transfer release create
transfe
r
receive process release transfe
r
transfer
process
 technician

receive transfer
transfer
phone call
process
him/herself
task
technician name
release
transfer
receive
transfer
transfer computer
receive transfer
transfer
transfer
receive
create release transfer
create
process:
if requires going
to user
else
technicians
list release
release
secretary

transfer
receive process
release
transfer
4
22
23
33
24
2
5
34
35
38
41
19
process
receive
transfer
transfer release create
create
transfe
r
transfer
1
15
20 26
27
30
28
31
request
release
create
create
2
6
release
release
process
16
17
18
create
29
32
36
37
39
40 43
42
44
4
5
46
47
48
4
9
50
51
52
53
a
b
release
transfer transfer
9
10 11
transfer
receive
7
transfer receive process
12
13
14
process
54 55
56
57
58 59
60
61
62
63
64
65 66
67
68
69
70
71
72
73
74
75
76
77
21
8
transfer
receive
receive
supplier
request for
parts
request for
repair
release
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
627 | p a g e
www.ijacsa.thesai.org
fig. 15. events of the tm representation of the it department help desk system (partial).
c. behavior model
as mentioned previously in the thermostat example,
behavior in a tm is represented by events. accordingly, we
can identify the following events in the static description of
fig. 14, as shown in fig. 15. to save space, we identify only
the upper part of fig. 14 (requesting parts):
 event 1 (e1): the secretary receives a request for
purchasing spare parts.
 event 2 (e2): the inventory department receives and
processes the request.
 event 3 (e3): the current quantity is retrieved and
processed.
 event 4 (e4): if the current quantity is 0, add the request
to the pending requests list and update the number of
pending requests.
 event 5 (e5): if the current quantity is greater than 0,
extract the requested quantity.
 event 6 (e6): find remaining (quantity = current
quantity – requested quantity) and process it.
 event 7 (e7): given that remaining > = 0, retrieve the
requested items from the storage.
 event 8 (e8): send the requested items to the requester.
 event 9 (e9): if remaining < 0, calculate pending =
requested (quantity–current), create a request for
pending items, and add the request to the list of pending
requests.
 event 10 (e10): if remaining < 0, calculate available =
current and retrieve the requested items from the
storage.
e4

a request
secretary
 e1
b
storage

requested quantity

receive
process
transfer release
request for
parts transfer
pending request
create process process
list of pending requests no. of requests in pending

transfer
e2
inventory
department
orders
release create
transfer

budget department

budget approval workshop

request budget
purchase department transfer receivetransfer process
process
transfer release create
transfe
r
receive process release transfe
r
create
transfer
workshop
admin transfer
release process
transfer
receive
e15
transfer
release
release create order
receive process transfer
current
quantity transfer
release
current quantity

release
transfer
transfe
receive
r
 process:
 if current quantity is 0

 if current quantity is greater than 0

e3 process
process:
remaining quantity = current quantity –
requested quantity
if remaining < 0
pending = requested quantity – current
available = current
if remaining >= 0
checking available quantity
create
transfer
receive
release
transfer
create
e5 e6
release
create
transfer e7
e9
e10
e e12
11

process

create process
decision
receive
committee
transfe er12
e13
total ordered
items
checking current quantity
add 1
ordered quantity
create process
e14
create
e8
requester
stored spare parts
-
requested quantity or
available quantity

receive
transfer
release process
e16
e17 e18
e19
e20
e21 receive
receive
receive
transfer 
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
628 | p a g e
www.ijacsa.thesai.org
 event 11 (e11): retrieve the pending requests and
extract the requested quantities.
 event 12 (e12): both requested pending quantities and
current quantities are sent to the ordering committee.
 event 13 (e13): the committee creates orders and sends
them to the workshop.
 event 14 (e14): orders are received by the workshop
and orders to the supplier are created.
 event 15 (e15): the purchase department receives
orders for the supplier.
 event 16 (e16): a request for budget is created.
 event 17 (e17): the request for budget flows to the
budget department.
 event 18 (e18): the budget is approved.
 event 19 (e19): orders for the supplier are sent.
 event 20 (e20): ordered items are received from the
supplier.
 event 21 (e21): items as sent to the storage.
fig. 16 shows the chronology of these events.
d. control
control can be superimposed onto the events of the tm
system. in the case study, suppose that we want to declare the
following warning messages related to the management of the
system:
1) if the time to order from the supplier in the workshop
exceeds t1, then create a warning message.
2) if the time to deliver items received from the supplier
to the requester exceeds t1, then create a warning message.
fig. 17 shows the declaration of these rules over the
chronology of events. in fig. 18, when the workshop receives
an order, the time of the order arrival is created. this time is
processed repeatedly. if the time exceeds t1—the time period
since the receiving of the order—then a warning is created. a
similar process is followed for the second rule.
fig. 16. the chronology of events of the case study.
fig. 17. examples of control in the case study.
e1 e2 e3
e4
e5 e6
e7
e8
e9
e10
e11 e12 e13 e14 e15 e16 e17 e18
e19
e20
e21
e13
budget department budget
approval
workshop
request budget
purchase department
receive
receive
transfer
transfer
process
process
release
transfer transfer release create
transfe
r
receiv
e
process release transfe
r
create
transfer release create
workshop
admin
transfer receive process
transfer
release process
supplier
order
supplier
transfer
receive
e13
storage
e14
e15
e16
e17
e18
e19
e20
transfer
receive
release
transfer
requester transfer
receive
e21
e8 e14 e15 e16 e17 e18 e19 e20 e21 e8
create
process
create process
if time is greater than
t1
send warning
cancel
time
cancel
if time is greater than
t2
time
send warning
(ijacsa) international journal of advanced computer science and applications,
vol. 10, no. 2, 2019
629 | p a g e
www.ijacsa.thesai.org
fig. 18. simplification of the tm representation of the it department help desk system by removing the stages transfer, release, and receive.
v. conclusion
we proposed using a new modeling technique, tm, as a
foundation in computational thinking. according to the tm
approach, a person’s ―thought machine‖ forms a train of
thought that excludes other modes such as procedural and
object-oriented modes of thinking. the paper emphasizes this
thinking style as a unifying method that could have diverse
applications. the tm is an underlying tool for expressing the
unified totality of a system’s things and machines analogous to
carpeting techniques where a ground fabric beneath the design
binds pieces and sews the patterns of fabric.
to substantiate our claim, we contrast the tm side by side
with diagrams of other approaches (e.g., the thermostat).
although we provided comprehensive evidence of our claim,
its inaccuracy or its partial value needs efforts beyond a single
researcher. however, the thermostat example and the case
study seem to point to some merits that deserve more
development.
fig. 14 of the case study may raise the issue of the tm
diagram’s complexity. the tm model can be specified at
various levels of granularity. for example, fig. 18 is a
simplified version of the lower part of fig. 14. the stages
transfer, release, and receive are deleted under the assumption
that the direction of the flow arrow is sufficient to represent
them.
references
[1] r. langacker, foundations of cognitive grammar: theoretical
prerequisites, vol. 1. palo alto, ca: stanford university press, 1987.
[2] d. riley and k. hunt, computational thinking for the modern problem
solver, second edition. boca raton, fl: taylor & francis group, llc,
2014.
[3] s. bocconi, a. chioccariello, g. dettori, a. ferrari, and k. engelhardt,
developing computational thinking in compulsory education,
luxembourg: publications office of the european union.
doi:10.2791/792158, 2016.
[4] j. m. wing, ―computational thinking and thinking about computing,
phil. trans. r. soc. a, mathematical, physical and engineering
sciences, vol. 366, pp. 3717–3725, 2008.
[5] a. mccormack, the e-skills manifesto. european schoolnet,
digitaleurope , brussels, 2014.
[6] r. c. anderson, ―the notion of schemata and educational enterprise:
general discussion of the conference,‖ in schooling and the acquisition
of knowledge, r. c. anderson, r. j. spiro, and w. e. montague, eds.
hillsdale: erlbaum, pp. 415-431 , 1977.
[7] m. heidegger, ―the thing,‖ in poetry, language, thought, a.
hofstadter, trans. new york: harper & row, 1975, pp. 161–184.
[8] s. al-fedaghi, ―thinging for software engineers,‖ international journal
of computer science and information security, vol. 16, no. 7, pp. 21-
29, 2018.
[9] s. al-fedaghi, ―thinging vs objectifying in software engineering,‖
international journal of computer science and information security,
vol. 16, no. 10, pp. 87-94, 2018.
[10] s. al-fedaghi and h. aljenfawi, ―a small company as a thinging
machine,‖ 10th int. conf. on info. mgmt. and eng. (icime), university
of salford, manchester, england, september 22–24, 2018.
[11] s. al-fedaghi and n. al-huwais, ―enterprise asset management as a
flow machine,‖ international journal of modeling and optimization, vol.
8, pp. 290–300, 2018.
[12] s. al-fedaghi, ―software engineering interpretation of information
processing regulations,‖ ieee 32nd annual international computer
software and applications conference (ieee compsac 2008), turku,
finland, pp. 271-274, july 28 - august 1, 2008.
[13] s. al-fedaghi, ""flow-based enterprise process modeling,"" international
journal of database theory and application, vol. 6, no. 3, pp. 59-70,
2013.
[14] g. deleuze and f. guattari, anti-oedipus: capitalism and
schizophrenia. minneapolis, mn: university of minnesota press, 1983.
[15] j. carreira, philosophy is not a luxury.
https://philosophyisnotaluxury.com/2011/03/02/to-thing-a-new-verb/,
last accessed 12/12/2018.
[16] b. latour, ―why has critique run out of steam? from matters of fact to
matters of concern‖ in critical inquiry, vol. 30, no. 2, pp.151-174,
winter 2004.
[17] l. thomas, m. ratcliffe, and b. j. thomasson, ―can object (instance)
diagrams help first year students understand program behaviour?‖
diagrams, international conference on theory and application of
diagrams, pp. 368–371, 2004.
[18] e. y.-l. do and m. d. gross, ―thinking with diagrams in architectural
design,‖ artif. intell. rev., vol. 15, pp. 135–149, 2001.
[19] o. ivarsson, ―quality management for it support services - a case study
of an it helpdesk service,‖ master thesis, department of technology
management and economics, chalmers university of technology,
gothenburg, sweden, 2013.



 report to close request
computer
process:
if not
repaired
if repaired
technician
with computer
if acceptable
else
user
process:
technician
(in user place)
workshop admin
 technician

phone call
process
him/herself
task
technician name computer
create
create
process:
if requires going
to user
else
secretary

create
create
process
request
process create
a
process
process
request for repair
technicians
list"
"full length article
which cognitive abilities underlie computational thinking? criterion
validity of the computational thinking test
marcos roman-gonz  alez  *
, juan-carlos perez-gonz  alez, carmen jim  enez-fern  andez 
universidad nacional de educacion a distancia (uned), faculty of education, c/ juan del rosal, n   14, c.p. 28040, madrid, spain
article info
article history:
received 17 april 2016
received in revised form
22 july 2016
accepted 29 august 2016
available online 22 september 2016
keywords:
computational thinking
computational thinking test
code literacy
computer science education
cognitive abilities
cognitive assessment
educational psychology
primary education
secondary education
abstract
computational thinking (ct) is being located at the focus of educational innovation, as a set of problemsolving skills that must be acquired by the new generations of students to thrive in a digital world full of
objects driven by software. however, there is still no consensus on a ct definition or how to measure it.
in response, we attempt to address both issues from a psychometric approach. on the one hand, a
computational thinking test (ctt) is administered on a sample of 1,251 spanish students from 5th to
10th grade, so its descriptive statistics and reliability are reported in this paper. on the second hand, the
criterion validity of the ctt is studied with respect to other standardized psychological tests: the primary
mental abilities (pma) battery, and the rp30 problem-solving test. thus, it is intended to provide a new
instrument for ct measurement and additionally give evidence of the nature of ct through its associations with key related psychological constructs. results show statistically significant correlations at least
moderately intense between ct and: spatial ability (r ¼ 0.44), reasoning ability (r ¼ 0.44), and problemsolving ability (r ¼ 0.67). these results are consistent with recent theoretical proposals linking ct to
some components of the cattel-horn-carroll (chc) model of intelligence, and corroborate the conceptualization of ct as a problem-solving ability.
© 2016 elsevier ltd. all rights reserved.
1. introduction
we live immersed in a digital ecosystem full of objects driven by
software (manovich, 2013). in this context, being able to handle the
language of computers is emerging as an inescapable skill, a new
literacy, which allows us to participate fully and effectively in the
digital reality that surrounds us: it is about to ‘program or be programmed’ (rushkoff, 2010); it is about to be ‘app-enabled or appdependent’ (gardner & davis, 2013). the term ‘code-literacy’ has
recently been coined to refer to the process of teaching and learning
to read-write with computer programming languages (prensky,
2008; rushkoff, 2012). thus, it is considered that a person is
code-literate when is able to read and write in the language of
computers and other machines, and to think computationally
(rom
an-gonzalez, 2014  ). if code-literacy refers ultimately to a new
read-write practice, computational thinking (ct) refers to the underlying problem-solving cognitive process that allows it. in other
words, computer programming is the fundamental way that
enables ct come alive (lye & koh, 2014); although ct can be
transferred to various types of problems that do not directly involve
programming tasks (wing, 2008).
given this current reality overrun by the digital, it is not surprising that there is renewed interest in many countries to introduce ct as a set of problem-solving skills to be acquired by the new
generations of students; even more, ct is becoming viewed at the
core of all stem (science, technology, engineering, & mathematics)
disciplines (henderson, cortina, & wing, 2007; weintrop et al.,
2016). although learn to think computationally has long been
recognized as important and positive for the cognitive development of students (liao & bright, 1991; mayer, 1988; papert, 1980), as
computation has become pervasive, underpinning communication,
science, culture and business in our society (howland & good,
2015), ct is increasingly seen as an essential skill to create rather
than just consume technology (resnick et al., 2009). thus, many
governments around the world are incorporating computer programming into their national educational curricula. the recent
decision to introduce computer science teaching from primary
school onwards in the uk (brown et al., 2013) and others european
countries (european schoolnet, 2015) reflects the growing recognition of the importance of ct.
* corresponding author.
e-mail addresses: mroman@edu.uned.es (m. roman-gonz  alez),  jcperez@edu.
uned.es (j.-c. perez-gonz  alez),  mjimenez@edu.uned.es (c. jimenez-fern  andez). 
contents lists available at sciencedirect
computers in human behavior
journal homepage: www.elsevier.com/locate/comphumbeh
http://dx.doi.org/10.1016/j.chb.2016.08.047
0747-5632/© 2016 elsevier ltd. all rights reserved.
computers in human behavior 72 (2017) 678e691
however, there is still little consensus on a formal definition of
ct (gouws, bradshaw, & wentworth, 2013; kalelioglu, gülbahar,  &
kukul, 2016), and disagreements over how it should be integrated
in educational curricula (lye & koh, 2014). similarly, there is a
worrying vacuum about how to measure and assess ct, fact that
must be addressed. without attention to assessment, ct can have
little hope of making its way successfully into any curriculum.
furthermore, in order to judge the effectiveness of any curriculum
incorporating ct, measures that would enable educators to assess
what the student has learned need to be validated (grover & pea,
2013).
in response, we attempt to address these issues from a psychometric approach. on the one hand, how our computational
thinking test (ctt) has been designed and developed is reported, as
well as its descriptive statistics and reliability derived from an
administration on a sample exceeding a thousand spanish students. on the other hand, the criterion validity (cronbach & meehl,
1955) of the ctt is studied with respect to already standardized
psychological tests of core cognitive abilities. thus, this paper is
aimed at providing a new instrument for measuring ct and additionally giving evidence of the correlations between ct and other
well-established psychological constructs in the study of cognitive
abilities.
1.1. computational thinking definitions
we can distinguish between: a) generic definitions; b) operational definitions; c) educational and curricular definitions.
1.1.1. generic definitions
one decade ago, in 2006, jeanette wing's foundational paper
defined that ct “involves solving problems, designing systems, and
understanding human behavior, by drawing on the concepts
fundamental to computer science” (wing, 2006, p. 33). thus, ct's
essence is thinking like a computer scientist when confronted with
a problem. but this first generic definition has been revisited and
specified in successive attempts over the last few years, still not
reaching an agreement (grover & pea, 2013; kalelioglu et al., 2016  ).
so, in 2011 wing clarified, ct “is the thought processes involved in
formulating problems and their solutions so that the solutions are
represented in a form that can be effectively carried out by an
information-processing agent” (wing, 2011; on-line). one year
later, this definition is simplified by aho, who conceptualizes ct as
the thought processes involved in formulating problems so “their
solutions can be represented as computational steps and algorithms” (aho, 2012, p. 832).
1.1.2. operational definitions
in 2011, the computer science teachers association (csta) and
the international society for technology in education (iste)
developed an operational definition of computational thinking that
provides a framework and common vocabulary for computer science k-12 educators: ct is a “problem-solving process that includes
(but is not limited to) the following characteristics: formulating
problems in a way that enables us to use a computer and other tools
to help solve them; logically organizing and analyzing data; representing data through abstractions such as models and simulations; automating solutions through algorithmic thinking (a series
of ordered steps); identifying, analyzing, and implementing
possible solutions with the goal of achieving the most efficient and
effective combination of steps and resources; generalizing and
transferring this problem solving process to a wide variety of
problems” (csta & iste, 2011; on-line).
1.1.3. educational-curricular definitions
more than definitions in the strict sense, frameworks for
developing ct in the classroom and other educational settings are
mentioned next. so, from the uk, the organization computing at
school (cas) states that ct involves six different concepts (logic,
algorithms, decomposition, patterns, abstraction, and evaluation),
and five approaches to working (tinkering, creating, debugging,
persevering, and collaborating) in the classroom (cas barefoot,
2014). moreover, from the united states, brennan and resnick
(2012) describe a ct framework that involves three key dimensions: ‘computational concepts’ (sequences, loops, events,
parallelism, conditionals, operators, and data); ‘computational
practices’ (experimenting and iterating, testing and debugging,
reusing and remixing, abstracting and modularizing); and
‘computational perspectives’ (expressing, connecting, and questioning). table 1 shows a crosstab intersecting the ct framework
dimensions (brennan & resnick, 2012) with the sampling domain
of our computational thinking test (ctt), which will be detailed in
sub-section 1.4.
1.2. computational thinking from the chc model of intelligence
while ct involves thinking skills to solve problems algorithmically (e.g., brennan & resnick, 2012; grover & pea, 2013), intelligence (i.e., general mental ability or general cognitive ability)
involves primarily the ability to reason, plan and solve problems
(gottfredson, 1997). even authors with alternative approaches to
the conceptualization of intelligence recognize intelligence as a
“computational capacity” or “the ability to process certain kinds of
information in the process of solving problems of fashioning
products” (gardner, 2006, p. 503).
within a cognitive approach, it has been recently suggested
(ambrosio, xavier, & georges, 2014) that computational thinking is
related to the following three abilities-factors from the cattellhorn-carroll (chc) model of intelligence (mcgrew, 2009;
schneider & mcgrew, 2012):
 fluid reasoning (gf), defined as: “the use of deliberate and
controlled mental operations to solve novel problems that
cannot be performed automatically. mental operations often
include drawing inferences, concept formation, classification,
generating and testing hypothesis, identifying relations, comprehending implications, problem solving, extrapolating, and
transforming information. inductive and deductive reasoning
are generally considered the hallmark indicators of gf” (mcgrew,
2009, p. 5)
 visual processing (gv), defined as “the ability to generate, store,
retrieve, and transform visual images and sensations. gv abilities
are typically measured by tasks (figural or geometric stimuli)
that require the perception and transformation of visual shapes,
forms, or images and/or tasks that require maintaining spatial
orientation with regard to objects that may change or move
through space” (mcgrew, 2009, p. 5)
 short-term memory (gsm), defined as “the ability to apprehend
and maintain awareness of a limited number of elements of
information in the immediate situation (events that occurred in
the last minute or so). a limited-capacity system that loses information quickly through the decay of memory traces, unless
an individual activates other cognitive resources to maintain the
information in immediate awareness” (mcgrew, 2009, p. 5).
therefore, it is expected that a computational thinking test
should correlate with other already validated tests aimed at
measuring cognitive abilities cited above.
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 679
1.3. computational thinking assessment
count on validated measurement instruments is something
necessary and valuable in any research area. however, for the
moment, there is still a large gap of tests relating to ct that have
undergone a comprehensive psychometric validation process
(mühling, ruf, & hubwieser, 2015). as buffum et al. (2015) say:
“developing assessments of student learning is an urgent area of
need for the relatively young computer science education community as it advances toward the ranks of more mature disciplines
such as physics that have established standardized assessments
over time” (buffum et al., 2015, p. 622). anyway, we find in recent
years some remarkable attempts to measure and assess ct in students from 5th to 10th grade, which are the ones of this paper's
interest.
from the university of california, comes the instrument fairy
assessment in alice (werner, denner, campe, & kawamoto, 2012),
which tries to measure the understanding and use of abstraction,
conditional logic, algorithmic thinking and other ct concepts that
middle school students utilize to solve problems. however, this
instrument is designed ad hoc to be used in the context of programming learning environment alice1 (graczynska, 2010  ), and it
has not been undergone to a psychometric validation process. the
research group from clemson university (south carolina) provides
a complementary perspective (daily, leonard, jorg, babu, € &
gundersen, 2014; leonard et al., 2015). these authors propose a
kinesthetic approach to learning (‘embodied learning’) and
assessment of ct with 5th and 6th grade students. to do so, they
alternate activities for programming motion sequences (choreographies) in the alice environment, with the representation of those
same sequences in a physical-kinesthetic environment. the
assessment tool also combines both settings, but its psychometric
properties have not been reported.
another interesting research line with middle school students is
provided by the group from the university of colorado. they work
with students in the video-game programming environment
agentsheets2 within a first group of studies (koh, basawapatna,
bennett, & repenning, 2010), these authors identify several
computational thinking patterns (ctp) that young programmers
abstract and develop during the creation of their video-games; in
this context, they design the computational thinking patterns
graph, an automated tool that analyzes the games programmed by
the students, and represents graphically how far each game has
involved the different ctp when compared with a model. within a
second group of studies (basawapatna, koh, repenning, webb, &
marshall, 2011), the authors try to assess whether students are
able to transfer the ctp acquired during video-game programming
to a new context of scientific simulations programming. for this
assessment, they develop ctp-quiz instrument, whose reliability or
validity have not been reported.
similarly, from the universidad rey juan carlos (madrid, spain)
dr. scratch3 is presented (moreno-leon & robles, 2015a, 2015b,
2014). dr. scratch is a free and open source web application
designed to analyze, simply and automatically, projects programmed with scratch4 (resnick et al., 2009), as well as it provides
feedback that can be used to improve programming skills and to
develop ct in middle school students (moreno-leon, robles,  &
roman-gonz  alez, 2015  ). in order to assign an overall ct score to
the project, dr. scratch infers the programmer competence along
the following seven ct dimensions: abstraction and problem
decomposition; parallelism; logical thinking; synchronization;
flow control; user interactivity; and data representation. therefore, dr. scratch is not strictly a cognitive test but a tool for the
formative assessment of scratch projects. dr. scratch is currently
under validation process, although its convergent validity with
respect to other traditional metrics of software quality and
complexity has been already reported (moreno-leon, robles,  &
roman-gonz  alez, 2016  ).
furthermore, we consider the bebras international contest,5 a
competition born in lithuania in 2003 which aims to promote the
interest and excellence of primary and secondary students around
the world in the field of computer science from a ct perspective
(cartelli, dagiene, & futschek, 2012; dagiene & futschek, 2008;
dagiene & stupuriene, 2014). each year, the contest proposes a set
of bebras tasks, whose overall approach is the resolution of real
problems, significant for the students, through the transfer and
projection of their ct over those. these bebras tasks are independent from any particular software or hardware, and can be administered to individuals without any prior programming experience.
table 1
crosstab intersecting ct framework (brennan & resnick, 2012) with the sampling domain of our ctt.
ct framework ctt
dimension description components sampling domain
computational concepts concepts students employ as they program sequences *
computational concept
addressed
loops *
events e
parallelism e
conditionals *
operators *
data e
computational practices problem-solving practices that occurs in the
process of programming
experimenting and iterating e
required task
testing and debugging /
reusing and remixing /
abstracting and modularizing /
computational perspectives students' understandings of themselves, their
relationships to others, and the digital world
around them
expressing e e
connecting e
questioning e
*
: yes, /: partly, -: no.
1 http://www.alice.org/index.php. 2 http://www.agentsheets.com/.
3 http://drscratch.org/. 4 https://scratch.mit.edu/. 5 http://www.bebras.org/.
680 m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691
for all these features, the bebras tasks have been pointed out as
more than likely embryo for a future pisa (programme for international student assessment) test in the field of computer science
(hubwieser & mühling, 2014; jaskova & kovacova, 2015  ). anyway,
the bebras international contest is, at the moment, an event for
promoting ct, not a measuring instrument; among other considerations, because it is not composed by a stable and determined set of
task-items, but a set that varies from year to year, with slight
modifications along the countries. however, its growing expansion
has aroused the interest of psychometry researchers, who have
begun to investigate its possible virtues as a ct measurement instrument. thus, descriptive studies about the student's performance
on bebras tasks have been recently published, referred to the corresponding editions of the bebras international contest held in
germany (hubwieser & mühling, 2014, 2015), italy (bellettini et al.,
2015), taiwan (lee, lin, & lin, 2014) or turkey (kalelioglu, gülbahar,
& madran, 2015). in all of them, and in most of the tasks studied,
significantly higher performances in the male group in comparison
with the female group were reported.
but strictly speaking, we only have knowledge of two tests
aimed to middle/high school students which are being fully subjected to the psychometric requirements; both instruments are
currently undergoing a validation process.
a. test for measuring basic programming abilities (mühling et al.,
2015): it is designed for bavarian students from 7th to 10th
grade. this test is aimed at measuring the students' ability to
execute a given program based on the so-called ‘flow control
structures’; which are considered at the core of the ct for this
age group: sequencing (doing one step after another); selection
(doing either one thing or another); repetition (doing one thing
once and again). these control structures lead to the following
ct concepts that are covered by the test: sequence of operations;
conditional statement with (if/else) and without (if) alternative;
loop with fixed number of iterations (repeat times); loop with
exit condition (conditional loop: while or repeat until); and the
nesting of these structures to create more complex programs.
b. commutative assessment (weintrop & wilensky, 2015): it is
designed for high-school students, from 9th to 12th grade. this
test is aimed at measuring students' understanding of different
computational concepts, depending on whether they occur
through scripts written in visual (block-based) or textual programming languages; which is a key transition to reach higher
levels of code-literacy. the test has a length of 28 items, and it
addresses the following ct concepts: conditionals; defined/fixed
loops; undefined/unfixed loops; simple functions; functions
with parameters/variables.
1.4. computational thinking test
overall, our computational thinking test (ctt) has been
developed following the practical guide to validating computer
science knowledge assessments with application to middle school
from buffum et al. (2015), which is aligned with the international
standards for psychological and educational testing (aera, apa, &
ncme, 2014). in addition, the ctt is consistent with other computational thinking tests under validation, aimed to middle/high
school, such as the test for measuring basic programming abilities
(mühling et al., 2015) or the commutative assessment (weintrop &
wilensky, 2015), just described in sub-section 1.3.
the ctt was initially designed with a length of 40 multiple choice
items (version 1.0, october 2014). after a content validation process
through twenty experts' judgement, this first version was refined to
the final one (version 2.0, december 2014) of 28 items length
(roman-gonz  
alez, 2015); which is built on the following principles:
 aim: ctt aims to measure the development level of ct in the
subject.
 operational definition of measured construct: ct involves the
ability to formulate and solve problems by relying on the
fundamental concepts of computing, and using logic-syntax of
programming languages: basic sequences, loops, iteration,
conditionals, functions and variables.
 target population: ctt is mainly designed and intended for
spanish students between 12 and 14 years old (7th and 8th
grade); although it can be also used in lower grades (5th and 6th
grade) and upper grades (9th and 10th grade).
 instrument type: multiple choice test with 4 answer options
(only one correct).
 length and estimated completion time: 28 items; 45 min.
each item of the ctt6 is designed and characterized according to
the following five dimensions of the sampling domain:
 computational concept addressed: each item addresses one or
more of the following seven computational concepts, ordered in
increasing difficulty: basic directions and sequences (4 items);
loopserepeat times (4 items); loopserepeat until (4 items);
ifesimple conditional (4 items); if/elseecomplex conditional (4
items); while conditional (4 items); simple functions (4 items).
these ‘computational concepts’ are aligned with some of the ct
framework (brennan & resnick, 2012; see table 1) and with the
csta computer science standards for 7th and 8th grade (csta,
2011).
 environment-interface of the item: ctt items are presented in
any of the following two environments-interfaces: ‘the maze’
(23 items) or ‘the canvas’ (5 items). both interfaces are common
in popular sites for learning programming such as code.org
(kalelioglu, 2015  ).
 answer alternatives style: in each item, the response alternatives may be presented in any of these two styles: visual arrows
(8 items) or visual blocks (20 items). both styles are also common in popular sites for learning programming such as code.org
(kalelioglu, 2015  ).
 existence or non-existence of nesting: depending on whether
the item solution involves a script with (19 items) or without (9
items) nesting computational concepts (a concept embedded in
another to a higher hierarchy level) (mühling et al., 2015).
 required task: depending on which of the following cognitive
tasks is required for solving the item: sequencing: the student
must sequence, stating in an orderly manner, a set of commands
(14 items); completion: the student must complete an incomplete given set of commands (9 items); debugging: the student
must debug an incorrect given set of commands (5 items). this
dimension is partially aligned with the aforementioned
‘computational practices’ from the ct framework (brennan &
resnick, 2012; see table 1).
the ctt is administered collectively and on-line, and it can be
performed both via non-mobile or mobile electronic devices. preliminary results about the ctt psychometric properties after its
administration on a sample of 400 spanish students (7th and 8th
grade) have been already reported (roman-gonz  alez, p  erez- 
6 available at http://goo.gl/iyekmb (spanish version). other forms and versions
of ctt are available, free of charge, only for research purposes, from the first author. 7 https://studio.code.org/s/20-hour. 8 https://studio.code.org/s/course2.
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 681
gonz
alez, & jimenez-fern  
andez, 2015). examples of definitive ctt
items translated into english are shown in figs. 1e4; with their
specifications detailed below.
2. method
2.1. participants
the ctt was administered on a total sample of 1,251 spanish
students, boys and girls from 24 different schools enrolled from 5th
to 10th grade. the distribution of the subjects by gender, grade and
age is shown in table 2. from the total sample, 825 (65.9%) students
belong to public schools, and 426 (34.1%) belong to private schools.
considering the device on which the ctt was administered, 1,001
students did it on a personal computer (80.0%) and 250 students
(20.0%) did it so on a tablet. none of the subjects had prior programming formal experience when the ctt was administered.
the sampling procedure is not probabilistic and intentional.
depending on the reasons that led to sample the different subjects,
these can be divided into four sub-samples.
 sub-sample a (n ¼ 418): it is composed of individuals belonging
to classrooms that subsequently enrolled in the accelerated
intro to cs course from code.org7
 sub-sample b (n ¼ 48): it is composed of individuals belonging
to classrooms that subsequently enrolled in the cs fundamentals course 2 from code.org8
 sub-sample c (n ¼ 194): it is composed of individuals belonging
to classrooms that subsequently started to learn programming
with scratch.
 sub-sample d (n ¼ 591): it is composed of individuals belonging
to classrooms that, although they did not subsequently start to
learn programming, were interested on measuring the ct of the
students.
in addition to our ctt, other standardized tests were administered concurrently to a part of the above subjects. specifically for
this paper, administrations of primary mental abilities (pma) battery (141  n  166) and rp30 problem-solving test (n ¼ 56) are
considered; all of these additional administrations are performed
on subjects belonging to sub-sample a. in the following subsection 2.2, both standardized tests, pma and rp30, are described.
2.2. instruments
in order to address the criterion validation of the ctt, another
two standardized instruments are administered: the primary
mental abilities (pma) battery, and the rp30 problem-solving test;
which are described next.
2.2.1. primary mental abilities (pma) battery
the pma battery is aimed at appreciating the basic cognitive
abilities through four different subtests, which allow an estimate of
the main components of intelligence. this is a well-known measure
of cognitive abilities (e.g., hertzog & bleckley, 2001; quiroga et al.,
2015) developed by thurstone (1938). its maximum administration
time is 26 min, and it can be used from 10 years old onwards. the
spanish technical manual (tea ediciones, 2007) reports excellent
reliability and validity coefficients about the four subtests. the pma
provides a precise measurement of the following cognitive abilities:
 verbal factor (pma-v): ability to understand and express ideas
with words. pma-v items involve selecting the accurate synonym of a word given.
 spatial factor (pma-s): ability to imagine and devise objects in
two and three dimensions. pma-s items involve selecting equal
figures to a given model, after having been rotated.
 reasoning factor (pma-r): ability to solve logical problems, to
understand and plan. pma-r items involve selecting the option
which continues a logical series given.
 numerical factor (pma-n): ability to handle numbers and
quantitative concepts. pma-n items involve checking mentally
the sum of four two-digit numbers.
2.2.2. rp30 problem-solving test
rp30 problem-solving test is aimed to assess speed and flexibility
in performing logical operations. its maximum administration time
is 17 min, and it can be used from 12 years old onwards. the spanish
technical manual (seisdedos, 2002) reports excellent reliability
values for rp30 (rxx > 0.90; through the split-half method), as well as
its criterion validity regarding to changes test of cognitive flexibility9 (rxy ¼ 0.38) or to dat10-spatial (rxy ¼ 0.34).
fig. 1. ctt, item 6: loopserepeat times; ‘the maze’; visual arrows; no-nesting; completion.
9 test cambios de flexibilidad cognitiva [changes test of cognitive flexibility]
(seisdedos, 1994). 10 dat: differential aptitude tests (bennett, 1952).
682 m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691
fig. 2. ctt, item 7: loopserepeat times; ‘the canvas’; visual blocks; no-nesting; debugging.
fig. 3. ctt, item 14: loopserepeat until þ ifesimple conditional; ‘the maze’; visual blocks; yes-nesting; sequencing.
fig. 4. ctt, item 25: loopserepeat times þ simple functions; ‘the canvas’; visual blocks; yes-nesting; sequencing.
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 683
rp30 appreciates a high-level cognitive ability, by which a series
of logical relations given are understood by the subject in order to
determine whether these relations are met in several simple
structures. rp30 is closely related to the non-verbal aspects of intelligence, it seems to be an important predictor to many school or
professional activities, and it has been previously used as a proxy of
the general mental ability (e.g., barros, kausel, cuadra, & díaz,
2014; caceres  & conejeros, 2011). rp30 items involve five structures in which the subject must decide whether the problem conditions are satisfied (fig. 5). rp30 requires enough concentration as
errors are penalized. it is considered that there are three cognitive
abilities underlying rp30 performance (seisdedos, 2002):
 reasoning, due to the fact that the logical relations which may
satisfy the structures must be previously understood by the
subject.
 spatial ability, as the subject must process the small circles and
squares contained in each structure, in order to decide if the
condition is satisfied.
 working memory, which allows the subject to retain the given
logical relation without need of constantly consulting it.
2.3. procedure
participating subjects in our research were enrolled in the
elective subject of computer science, which is held twice a week
(1 h each). typically, the ctt was administered during the first of
the two weekly classes. in the groups in which another standardized instrument was further administered, it was done during the
second weekly class.
for the ctt collective administration, the computer science
teacher followed the instructions which were sent by email in the
week before, containing the url to access the on-line test. the
student's direct answers to the ctt items were stored in the google
drive database linked with the instrument, which was subsequently downloaded as an excel.xls file.
for the collective administration of the standardized instrument
(pma or rp30), students were previously signed in the on-line
platform from the publishing house,11 holder of these tests' commercial rights. come the administration day, the subjects logged in
the platform and performed the corresponding instrument, pma
battery or rp30 test (never both). afterwards, from our administrator profile, we could download the subjects' results as an
excel.xls file.
finally, all .xls files generated during data collection were
exported to a single .sav file, which constitutes the data matrix
under analysis with spss software (version 22). from this analysis
arise the results exposed below.
3. results and discussion
3.1. descriptive statistics
table 3 shows the main descriptive statistics of the ctt score
(calculated as the sum of correct answers along the 28 items of the
test) for the entire sample (n ¼ 1,251).
in fig. 6 (left), a histogram showing the distribution of the ctt
score along the sample is depicted. as it can be seen, the aforementioned distribution fits remarkably the normal curve; although,
given the very large size of the sample, the small existing maladjustments are penalized by the kolmogorov-smirnov test which
rejects the null hypothesis of normality (zk-s ¼ 0.052; p < 0.01).
in fig. 6 (right), we show the success rate per item (expressed in
per unit) or item difficulty index, that confirms empirically the
progressive difficulty of the ctt; which was already anticipated by
the experts during the content validation process (roman- 
gonzalez, 2015  ). the average success rate along the 28 items is
p ¼ 0.59 (medium difficulty); ranging from p ¼ 0.16 (item 23; very
high difficulty) to p ¼ 0.96 (item 1; very low difficulty).
summarizing, it can be stated that: a) the ctt score is almost
normally distributed (i.e. symmetrically distributed; skewness
z0), showing proper variability so that is possible to construct
suitable scales (percentiles) for the target population; b) the ctt has
an appropriate degree of difficulty (medium) for the target population, with an increasing difficulty along its items, as recommended in the design of abilities' tests (e.g., carpenter, just, & shell,
1990; elithorn & telford, 1969).
3.1.1. differences by grade
when the sample is segmented regarding to grade, the
descriptive statistics shown in table 4 are obtained. specifically,
results in table 4 are split according to the spanish educational
system by the end of primary education (5th and 6th grade), the
start of secondary education (7th and 8th grade), and the end of
secondary education (9th and 10th grade).
box plots for the ctt score split by aforementioned grades are
shown in fig. 7. the outlier belongs to a case from 6th grade, which
obtained ctt score equal to 26 (i.e., z3 standard deviations above
the mean of its reference group). the anova test shows statistically
significant differences in the ctt score regarding to grade (f(2,
1248) ¼ 50.514; p < 0.01). the post-hoc tukey test additionally shows
statistically significant differences between all possible pairs of
means (p < 0.01).
hence, it can be stated that the performance on the ctt increases as it does the grade; this result is consistent with our
assumption that the ct is a problem-solving ability that it should be
therefore linked to the cognitive development and maturity of the
subjects (ackerman & rolfhus, 1999; mayer, caruso, & salovey,
1999).
3.1.2. gender differences
about the possible differential performance on the ctt
regarding to gender, we find a statistically significant difference in
the ctt score in favor of the male group (t ¼ 5.374; p < 0.01),
resulting an effect size measured through cohen's d (cohen, 1992)
equal to 0.31 (table 5); that can be considered as a low-moderate
effect. if the aforementioned difference is analyzed along grades
(table 5), higher means in the ctt score are always found in the
table 2
distribution of the total sample (n ¼ 1,251) by gender, grade and age.
gender total
boys girls
grade 5th age 10e11 y/o count 50 53 103
% of total 4.0% 4.2% 8.2%
6th 11e12 y/o count 28 45 73
% of total 2.2% 3.6% 5.8%
7th 12e13 y/o count 263 170 433
% of total 21.0% 13.6% 34.6%
8th 13-14 y/o count 187 115 302
% of total 14.9% 9.2% 24.1%
9th 14e15 y/o count 112 87 199
% of total 9.0% 7.0% 15.9%
10th 15e16 y/o count 90 51 141
% of total 7.2% 4.1% 11.3%
total count 730 521 1,251
% of total 58.4% 41.6% 100.0%
11 http://www.e-teaediciones.com/.
684 m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691
male group, although these gender differences are only statistically
significant from 7th and 8th grade (t ¼ 2.928; p < 0.01) onwards;
being more intense in 9th and 10th grade (t ¼ 3.451; p < 0.01).
hence, it seems that there is a progressive gender gap over the ctt
performance, as we advance along the grades (fig. 8).
these gender differences are consistent with those found in
previous research with bebras tasks, on which most of the investigations report higher yields of the male group, as described in
sub-section 1.3.
fig. 5. item example from the rp30 problem-solving test.
table 3
descriptive statistics of the ctt score for the entire sample (n ¼ 1,251).
mean 16.38
std. error of mean .136
median 16.00
mode 17
std. deviation 4.824
variance 23.271
skewness .058
kurtosis .446
minimum 3
maximum 28
percentiles 10 10.00
20 12.00
25 13.00
30 14.00
40 15.00
50 16.00
60 17.00
70 19.00
75 20.00
80 21.00
90 23.00
fig. 6. histogram of the ctt score (left); item difficulty index for each item of the ctt (right).
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 685
3.2. reliability
reliability as internal consistency of the ctt, measured by
cronbach's alfa is a ¼ 0.793 z 0.80; that can be considered as good
reliability (nunnally & bernstein, 1994). when reliability is studied
regarding to grade and administration's device (table 6) we find
that: a) reliability increases as it does the grade; which is coherent
with the greater accuracy and consistency often shown by the answers coming from the upper grades' students (anastasi, 1968); b)
reliability increases when ctt is administered through mobile devices such as tablets, perhaps because these devices allow the
subject to rotate the screen to one side and another, reducing the
spatial cognitive load of the items and avoiding that the subjects
commit unexpected errors on the same. this interpretation is
supported by the results obtained when comparing the average
yield in the ctt between subjects who performed it on a computer
and subjects who did it so on a tablet: for instance, in 7th and 8th
grade, xcomputer ¼ 16.01 vs. xtablet ¼ 18.24 (t ¼ 4.116; p < 0.01;
d ¼ 0.50). in the future, if we achieve a larger sample of subjects
who perform the ctt on tablet, and if these aforementioned significant differences between devices continue, it will be necessary
to construct different scales for the ctt depending on the administration device.
3.3. criterion validity
3.3.1. relative to primary mental abilities (pma) battery
correlations between the ctt and the various tests of the pma
battery are shown in table 7. as it can be seen, the ctt has a positive
statistically significant correlation (p < 0.01), moderately intense
with pma-r (reasoning factor) and pma-s (spatial factor), and
slightly intense with pma-v (verbal factor). there is no statistically
significant correlation between ctt and pma-n (numerical factor).
corresponding scatter plots are shown in fig. 9.
at this point, we perform a multiple linear regression over the
ctt score (considered as the dependent variable) based on the
pma-v, pma-s, pma-r and pma-n scores (considered as predictors). table 8 summarizes de regression model, which is calculated through the ‘enter’ method. this regression model, based on
the pma battery, correlates r ¼ 0.540 with the ctt; which means an
adjusted r2 ¼ 0.27. that is, the 27.0% of the ctt scores' variance is
explained from a linear combination of the primary mental abilities
measured through the pma battery. normality of the regression
model residuals was verified.
the regression model is able to explain, statistically significant,
the differences in the ctt scores, as f(4, 131) ¼ 13.457 (p < 0.01).
however, as shown in following table 9 which contains the coefficients of the regression model, only pma-s (spatial factor) and
pma-r (reasoning factor) are capable, specifically and statistically
significant (p < 0.01), to explain differences in the dependent variable (ctt). the standardized coefficients of the model are, from
highest to lowest value, b(pma-s) ¼ 0.308; b(pma-r) ¼ 0.265; b(pmav) ¼ 0.134; b(pma-n) ¼ 0.051.
from our perspective, these results point out two important
issues:
 firstly, there is still a 73.0% of the ctt scores' variance that is not
explained by the primary mental abilities measured through the
pma battery; which suggests certain independence of ct as a
psychological construct, distinct from the traditional aptitudes.
 secondly, the cognitive abilities with higher explanatory power
about ct are reasoning ability and spatial ability; from both
there is abundant evidence in the literature that reports certain
male superiority. regarding to the former, kuhn and holling
(2009) recently report gender differences in reasoning ability
favoring males in german students from 7th to 10th grade.
regarding to the latter, there are some meta-analysis that
demonstrate higher male spatial ability, especially in tasks that
involve mentally rotation of figures (linn & petersen, 1985;
voyer, voyer, & bryden, 1995). all the above could explain the
higher yield of the boys in the ctt seen in sub-section 3.1.2.
3.3.2. relative to rp30 problem-solving test
correlation between ctt and rp30 problem-solving test is
shown in table 10. as it can be seen, we find a positive, statistically
significant, and moderately-strongly intense correlation (r ¼ 0.669;
p < 0.01) between both instruments. corresponding scatter plot is
shown in fig. 10, such as the coefficient of determination r2 ¼ 0.447
(i.e., 44.7% of shared variance between both scores). recall that
rp30 test appreciates a high-level cognitive ability and it has been
previously used as a proxy of the general mental ability. our results
table 4
descriptive statistics of the ctt score split by grades.
grades
5th & 6th 7th & 8th 9th & 10th
n 176 735 340
mean 13.76 16.24 18.05
std. error of mean .326 .167 .274
median 14.00 16.00 18.00
mode 15 18 17
std. deviation 4.330 4.519 5.049
variance 18.746 20.419 25.496
skewness .125 .018 .097
kurtosis .148 .453 .577
minimum 3 3 3
maximum 26 27 28
percentiles 10 8.00 10.00 12.00
20 10.00 12.00 13.20
25 11.00 13.00 14.00
30 11.00 14.00 15.00
40 13.00 15.00 17.00
50 14.00 16.00 18.00
60 15.00 17.00 19.00
70 16.00 19.00 21.00
75 16.75 20.00 22.00
80 17.00 20.00 23.00
90 20.00 22.00 25.00
fig. 7. box plots for the ctt score split by grades.
686 m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691
indicate that ctt correlate more intensely with rp30 than with any
of the primary mental abilities measured through pma battery
(table 11). hence, it seems that computational thinking could be
fundamentally linked with general mental ability (particularly with
fluid intelligence); and to a lesser extent with different cognitive
aptitudes, such as logical reasoning and spatial ability.
when results of preceding sub-sections 3.3.1 and 3.3.2 are
triangulated, we find a clear consistency between the magnitude of
the correlations ctt*
pma and ctt*
rp30, and the expected composition of computational thinking from the chc model of intelligence exposed in sub-section 1.2 (table 11). from our point of view,
this is a powerful evidence of the criterion concurrent validity of
our ctt, as well as an empirical confirmation of the computational
thinking construct's composition proposed by ambrosio et al.
(2014).
4. implications and limitations
the ctt has some strengths like: it can be administered in
pretest conditions to measure the initial development level of ct in
students without prior programming experience from 5th to 10th
grade; it can be collectively administered so it could be used in
massive screenings and early detection of students with high
abilities (or special needs) for programming tasks; it can be utilized
for collecting quantitative data in pre-post evaluations of the efficacy of curricula or programs aimed at fostering ct, which would be
a desirable practice versus the qualitative approach that has been
mostly used in the literature so far (lye & koh, 2014); and it could
be used along academic and professional guidance processes towards stem disciplines. however, the ctt also has obvious limitations and weaknesses:
 the ctt provides a static and decontextualized assessment.
therefore, we recommend to complement its use with other ct
assessment tools designed from a formative perspective, such as
dr. scratch (moreno-leon et al., 2015  )
 in terms of ct framework (brennan & resnick, 2012), the ctt is
overly focused on ‘computational concepts’, only covers
‘computational practices’ partly, and ignores ‘computational
perspectives’.
 the ctt only demands the projection of computational thinking
over logical and visuospatial problems, such as solving mazes or
designing geometric patterns. this implies a clear bias of the
ctt, as computational thinking can also be projected over
problems with different features, such as: modeling scientific
simulations (weintrop et al., 2016); algorithmic composition of
computational music (edwards, 2011); or digital interactive
storytelling (burke, 2012; howland & good, 2015). the latter
authors report significantly higher values in the computational
complexity of scripts written by girls from 7th and 8th grade in
comparison with their male peers within narrative tasks; this
table 5
gender differences in ctt score.
n mean std. deviation student's t effect size cohen's d
entire sample boys 730 16.99 4.802 5.374** 0.31
girls 521 15.52 4.727
grades 5th & 6th boys 78 14.40 4.185 1.765 0.27
girls 98 13.24 4.396
7th & 8th boys 450 16.62 4.463 2.928** 0.22
girls 285 15.63 4.547
9th & 10th boys 202 18.82 5.115 3.451** 0.38
girls 138 16.93 4.749
**p < 0.01.
fig. 8. box plots for the ctt score split by gender and along grades.
table 6
reliability as internal consistency of the ctt.
cronbach's alpha n cronbach's alpha n
entire sample 0.793 1,251 computer 0.786 1,001
tablet 0.817 250
grades 5th & 6th 0.721 176 computer 0.719 66
tablet 0.712 110
7th & 8th 0.762 735 computer 0.744 659
tablet 0.836 76
9th & 10th 0.824 340 computer 0.824 276
tablet 0.825 64
table 7
correlations (pearson's r) between ctt and pma battery.
pma-v pma-s pma-r pma-n
ctt 0.273** 0.439** 0.442** 0.157
pma-v 0.225** 0.334** 0.020
pma-s 0.356** 0.164*
pma-r 0.030
141  n  166; **p < 0.01; *
p < 0.05.
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 687
result is consistent with the (slight) female superiority in tasks
involving verbal ability reported in the classical literature (hyde
& linn, 1988). it seems, therefore, that the direction of gender
differences in ct may vary depending on the type of problems
on which such ability is projected.
 finally, as the ctt is entirely designed with multiple choice
items, it might be measuring ct at its lower cognitive
complexity levels (‘recognize’ and ‘understand’) (gouws et al.,
fig. 9. scatter plots between ctt and pma battery.
table 8
summary of the regression model of the ctt onto the pma subtests.
model r r square adjusted r square std. error of the estimate
1 0.540a 0.291 0.270 3.391
a predictors: (constant), pma-v, pma-s, pma-r, pma-n.
table 9
standardized coefficientsa of the regression model of the ctt onto the pma subtests.
model b standardized coefficients student's t
1 (constant) 9.006**
pma-v 0.134 1.715
pma-s 0.308 3.865**
pma-r 0.265 3.253**
pma-n 0.051 0.688
**p < 0.01. a dependent variable: ctt.
688 m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691
2013). an instrument intended to measure ct also at higher
levels of complexity (‘apply’ and ‘assimilate’) should include
items which require not only recognize but also evoke the correct algorithm; as well as open complex problems whose resolution demands students to creatively transfer ct towards
different domains.
5. conclusions and further research
in this paper we have provided evidences of reliability and criterion validity of a new instrument for the assessment of ct and
additionally we expanded our understanding of the ct nature
through the theory-driven exploration of its associations with
other established psychological constructs in the cognitive sphere.
we have found expected positive small or moderate significant
correlations (0.27 < r < 0.44) between ct and three of the four
primary mental abilities of the thurstone (1938) model of intelligence, as well as a high correlation (r ¼ 0.67) between ct and
problem-solving ability as a proxy of general mental ability. our
findings are consistent with recent theoretical proposals by
ambrosio et al. (2014) linking ct with some core elements of the
chc model of intelligence (mcgrew, 2009), especially with respect
to gf (fluid intelligence) and gv (visual processing). furthermore,
our results support the statement that ct is fundamentally linked
with general mental ability; and also, though to a lesser extent,
with specific cognitive aptitudes, such as inductive reasoning,
spatial and verbal abilities. this corroborates the conceptualization
of ct as a problem-solving ability (e.g., brennan & resnick, 2012;
lye & koh, 2014; wing, 2006, 2008); and it is consistent with the
framework recently described by kalelioglu et al. (2016)  , in which
ct is defined as a complex and high-order thinking skill involved in
problem-solving processes.
overall, it should be noted that this paper contributes to the
establishment of the nomological net (cronbach & meehl, 1955) of
computational thinking as an emergent scientific construct. future
research might expand this nomological net exploring how ct is
related to other cognitive and computational variables, such as
working memory, executive functions, or specific programming
skills, among others. finally, we plan the following further research
lines concerning the ctt: a) convergent validity studies between
ctt and other alternative ct assessment tools, such as dr. scratch
(moreno-leon & robles, 2015b, 2015a), bebras tasks (dagiene &
stupuriene, 2014), the test for measuring basic programming
abilities (mühling et al., 2015), or the commutative assessment
(weintrop & wilensky, 2015); b) ctt adaptation and translation
into other languages (already underway adaptations-translations
into english and portuguese), and replications of our psychometric studies in other populations; c) enhanced ctt versions including
items that require the subject the evocation of algorithms and/or
items that demand to project and transfer ct on scientific, narrative
and musical relevant problems.
acknowledgements
we thank professor dr. kate howland (university of sussex) for
collaborating in the adaptation and translation of ctt items from
the spanish language to the english language.
references
ackerman, p. l., & rolfhus, e. l. (1999). the locus of adult intelligence: knowledge,
abilities, and nonability traits. psychology and aging, 14(2), 314e330. http://
dx.doi.org/10.1037/0882-7974.14.2.314.
aera, apa, & ncme. (2014). standards for educational and psychological testing.
washington, dc: aera.
aho, a. v. (2012). computation and computational thinking. the computer journal,
table 10
correlation between ctt and rp30 problem-solving test.
rp30
ctt pearson correlation 0.669**
sig. (2-tailed) 0.000
n 56
**p < 0.01.
fig. 10. scatter plot between ctt and rp30.
table 11
correlations ctt*
pma and ctt*
rp30, and contingency with gf, gv, and gsm components of chc model.
pma-n pma-v pma-s pma-r rp30
ctt 0.157 0.273** 0.439** 0.442** 0.669**
selected components of the
chc model of intelligence
gf is it measured in the following
instruments?
no no no yes yes
gv no no yes no yes
gsm no no no no yes
**p < 0.01.
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 689
55(7), 832e835. http://dx.doi.org/10.1093/comjnl/bxs074.
ambrosio, a. p., xavier, c., & georges, f. (2014). digital ink for cognitive assessment
of computational thinking. in frontiers in education conference (fie), 2014 ieee
(pp. 1e7). http://dx.doi.org/10.1109/fie.2014.7044237.
anastasi, a. (1968). psychological testing (3rd ed.). oxford, england: macmillan.
barefoot, c. a. s. (2014). computational thinking [web page]. retrieved from. http://
barefootcas.org.uk/barefoot-primary-computing-resources/concepts/
computational-thinking/.
barros, e., kausel, e. e., cuadra, f., & díaz, d. a. (2014). using general mental ability
and personality traits to predict job performance in three chilean organizations.
international journal of selection and assessment, 22(4), 432e438. http://
dx.doi.org/10.1111/ijsa.12089.
basawapatna, a., koh, k. h., repenning, a., webb, d. c., & marshall, k. s. (2011).
recognizing computational thinking patterns. proceedings of the 42nd acm
technical symposium on computer science education, 245e250. http://
dx.doi.org/10.1145/1953163.1953241.
bellettini, c., lonati, v., malchiodi, d., monga, m., morpurgo, a., & torelli, m. (2015).
how challenging are bebras tasks? an irt analysis based on the performance of
italian students. in proceedings of the 2015 acm conference on innovation and
technology in computer science education (pp. 27e32). http://dx.doi.org/10.1145/
2729094.2742603.
bennett, g. k. (1952). differential aptitude tests [technical manual]. new york: psychological corporation.
brennan, k., & resnick, m. (2012). new frameworks for studying and assessing the
development of computational thinking. in proceedings of the 2012 annual
meeting of the american educational research association (vancouver: canada).
retrieved from: http://scratched.gse.harvard.edu/ct/files/aera2012.pdf.
brown, n. c. c., kolling, m., crick, t., peyton jones, s., humphreys, s., & sentance, s. €
(2013). bringing computer science back into schools: lessons from the uk. in
proceeding of the 44th acm technical symposium on computer science education
(pp. 269e274). http://dx.doi.org/10.1145/2445196.2445277.
buffum, p. s., lobene, e. v., frankosky, m. h., boyer, k. e., wiebe, e. n., & lester, j. c.
(2015). a practical guide to developing and validating computer science
knowledge assessments with application to middle school. in proceedings of the
46th acm technical symposium on computer science education (pp. 622e627).
http://dx.doi.org/10.1145/2676723.2677295.
burke, q. (2012). the markings of a new pencil: introducing programming-aswriting in the middle school classroom. the journal of media literacy education, 4(2), 121e135. retrieved from:http://eric.ed.gov/?id¼ej985683.
caceres, p. a., & conejeros, m. l. (2011). efecto de un modelo de metodología 
centrada en el aprendizaje sobre el pensamiento crítico, el pensamiento creativo y la capacidad de resolucion de problemas en estudiantes con talento 
academico.  revista espanola de pedagogía, 69 ~ (248), 39e55. retrieved from:
http://www.jstor.org/stable/23766382.
carpenter, p. a., just, m. a., & shell, p. (1990). what one intelligence test measures: a
theoretical account of the processing in the raven progressive matrices test.
psychological review, 97(3), 404e431. http://dx.doi.org/10.1037/0033-295x.97.3.
404.
cartelli, a., dagiene, v., & futschek, g. (2012). bebras contest and digital competence assessment: analysis of frameworks. in a. cartelli (ed.), current trends and
future practices for digital literacy and competence (pp. 35e46). hershey, pa: igi
global.
cohen, j. (1992). a power primer. psychological bulletin, 112(1), 155e159. http://
dx.doi.org/10.1037/0033-2909.112.1.155.
cronbach, l. j., & meehl, p. e. (1955). construct validity in psychological tests. psychological bulletin, 52(4), 281e302. http://dx.doi.org/10.1037/h0040957.
csta. (2011). ke12 computer science standards. retrieved from http://csta.acm.org/
curriculum/sub/currfiles/csta_k-12_css.pdf.
csta, & iste. (2011). operational definition of computational thinking for ke12 education. retrieved from: http://csta.acm.org/curriculum/sub/currfiles/
compthinkingflyer.pdf.
dagiene, v., & futschek, g. (2008). bebras international contest on informatics and
computer literacy: criteria for good tasks. in r. t. mittermeir, & m. m. sysło
(eds.), informatics education-supporting computational thinking (pp. 19e30).
berlin: springer.
dagiene, v., & stupuriene, g. (2014). informatics education based on solving
attractive tasks through a contest. in proceedings of keycit 2014ekey competencies in informatics and ict (pp. 51e62). retrieved from: http://www.bebras.
org/sites/default/files/documents/publications/dagiene%2c%202014.pdf.
daily, s. b., leonard, a. e., jorg, s., babu, s., & gundersen, k. (2014). dancing alice: €
exploring embodied pedagogical strategies for learning computational
thinking. in proceedings of the 45th acm technical symposium on computer science education (pp. 91e96). http://dx.doi.org/10.1145/2538862.2538917.
ediciones, t. e. a. (2007). pma: aptitudes mentales primarias (manual tecnico) [pma:
primary mental abilities. (technical manual)]. madrid: tea ediciones.
edwards, m. (2011). algorithmic composition: computational thinking in music.
communications of the acm, 54(7), 58e67. http://dx.doi.org/10.1145/
1965724.1965742.
elithorn, a., & telford, a. (1969). computer analysis of intellectual skills. international journal of man-machine studies, 1(2), 189e209. http://dx.doi.org/10.1016/
s0020-7373(69)80021-0.
european schoolnet. (2015). computing our future. computer programming and
coding: priorities, school curricula and initiatives across europe [technical
report]. retrieved from:http://www.eun.org/publications/detail?
publicationid¼661.
gardner, h. (2006). on failing to grasp the core of mi theory: a response to visser
et al. intelligence, 34(5), 503e505. http://dx.doi.org/10.1016/j.intell.2006.04.002.
gardner, h., & davis, k. (2013). the app generation: how today's youth navigate
identity, intimacy, and imagination in a digital world. new haven: yale university
press.
gottfredson, l. s. (1997). why g matters: the complexity of everyday life. intelligence, 24(1), 79e132. http://dx.doi.org/10.1016/s0160-2896(97)90014-3.
gouws, l. a., bradshaw, k., & wentworth, p. (2013). computational thinking in
educational activities: an evaluation of the educational game light-bot. in
proceedings of the 18th acm conference on innovation and technology in computer
science education (pp. 10e15). http://dx.doi.org/10.1145/2462476.2466518.
graczynska, e. (2010). alice as a tool for programming at schools.  natural science,
2(2), 124e129. http://dx.doi.org/10.4236/ns.2010.22021.
grover, s., & pea, r. (2013). computational thinking in ke12: a review of the state of
the field. educational researcher, 42(1), 38e43. http://dx.doi.org/10.3102/
0013189x12463051.
henderson, p. b., cortina, t. j., & wing, j. m. (2007). computational thinking. acm
sigcse bulletin, 39(1), 195e196. http://dx.doi.org/10.1145/1227504.1227378.
hertzog, c., & bleckley, m. k. (2001). age differences in the structure of intelligence:
influences of information processing speed. intelligence, 29(3), 191e217. http://
dx.doi.org/10.1016/s0160-2896(00)00050-7.
howland, k., & good, j. (2015). learning to communicate computationally with flip:
a bi-modal programming language for game creation. computers & education,
80, 224e240. http://dx.doi.org/10.1016/j.compedu.2014.08.014.
hubwieser, p., & mühling, a. (2014). playing pisa with bebras. in proceedings of the
9th workshop in primary and secondary computing education (pp. 128e129).
http://dx.doi.org/10.1145/2670757.2670759.
hubwieser, p., & mühling, a. (2015). investigating the psychometric structure of
bebras contest: towards measuring computational thinking skills. in international conference on learning and teaching in computing and engineering (latice)
(pp. 62e69). http://dx.doi.org/10.1109/latice.2015.19.
hyde, j. s., & linn, m. c. (1988). gender differences in verbal ability: a meta-analysis. psychological bulletin, 104(1), 53e69. http://dx.doi.org/10.1037/0033-
2909.104.1.53.
jaskova, l., & kov  
acov
a, n. (2015). bebras contest for blind pupils. in proceedings of
the 10th workshop in primary and secondary computing education (pp. 92e95).
http://dx.doi.org/10.1145/2818314.2818324.
kalelioglu, f. (2015). a new way of teaching programming skills to k-12 students:
code.org. computers in human behavior, 52, 200e210. http://dx.doi.org/10.1016/
j.chb.2015.05.047.
kalelioglu, f., gülbahar, y., & kukul, v. (2016). a framework for computational
thinking based on a systematic research review. baltic journal of modern
computing, 4(3), 583e596. retrieved from http://www.bjmc.lu.lv/fileadmin/
user_upload/lu_portal/projekti/bjmc/contents/4_3_15_kalelioglu.pdf.
kalelioglu, f., gülbahar, y., & madran, o. (2015). a snapshot of the  first implementation of bebras international informatics contest in turkey. in a. brodnik,
& j. vahrenhold (eds.), informatics in schools. curricula, competences, and competitions (pp. 131e140). berna: springer. http://dx.doi.org/10.1007/978-3-319-
25396-1_12.
koh, k. h., basawapatna, a., bennett, v., & repenning, a. (2010). towards the
automatic recognition of computational thinking for adaptive visual language
learning. in visual languages and human-centric computing (vl/hcc), 2010 ieee
symposium (pp. 59e66). http://dx.doi.org/10.1109/vlhcc.2010.17.
kuhn, j., & holling, h. (2009). gender, reasoning ability, and scholastic achievement:
a multilevel mediation analysis. learning and individual differences, 19(2),
229e233. http://dx.doi.org/10.1016/j.lindif.2008.11.007.
lee, g., lin, y., & lin, j. (2014). assessment of computational thinking skill among
high school and vocational school students in taiwan. in world conference on
educational multimedia, hypermedia and telecommunications (pp. 173e180).
retrieved from: http://www.editlib.org/p/147499/.
leonard, a. e., dsouza, n., babu, s. v., daily, s. b., jorg, s., waddell, c., et al. (2015). €
embodying and programming a constellation of multimodal literacy practices:
computational thinking, creative movement, biology, & virtual environment
interactions. journal of language and literacy education, 11(2), 64e93. retrieved
from http://jolle.coe.uga.edu/wp-content/uploads/2015/10/leonard_templatefinal-fixed-links.pdf.
liao, y. c., & bright, g. w. (1991). effects of computer programming on cognitive
outcomes: a meta-analysis. journal of educational computing research, 7(3),
251e268. http://dx.doi.org/10.2190/e53g-hh8k-ajrr-k69m.
linn, m. c., & petersen, a. c. (1985). emergence and characterization of sex differences in spatial ability: a meta-analysis. child development, 56(6), 1479e1498.
http://dx.doi.org/10.2307/1130467.
lye, s. y., & koh, j. h. l. (2014). review on teaching and learning of computational
thinking through programming: what is next for k-12? computers in human
behavior, 41, 51e61. http://dx.doi.org/10.1016/j.chb.2014.09.012.
manovich, l. (2013). software takes command. new york: bloomsbury.
mayer, r. e. (1988). teaching and learning computer programming: multiple research
perspectives. new york: routledge.
mayer, j. d., caruso, d. r., & salovey, p. (1999). emotional intelligence meets
traditional standards for an intelligence. intelligence, 27(4), 267e298. http://
dx.doi.org/10.1016/s0160-2896(99)00016-1.
mcgrew, k. s. (2009). chc theory and the human cognitive abilities project:
standing on the shoulders of the giants of psychometric intelligence research.
intelligence, 37(1), 1e10. http://dx.doi.org/10.1016/j.intell.2008.08.004.
moreno-leon, j., & robles, g. (2014). automatic detection of bad programming 
690 m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691
habits in scratch: a preliminary study. frontiers in education conference (fie),
2014 ieee, 1e4. http://dx.doi.org/10.1109/fie.2014.7044055.
moreno-leon, j., & robles, g. (2015a).  analyze your scratch projects with dr. scratch
and assess your computational thinking skills. scratch conference (pp. 12e15).
retrieved from http://jemole.me/replication/2015scratch/inferct.pdf.
moreno-leon, j., & robles, g. (2015b). dr. scratch: a web tool to automatically 
evaluate scratch projects. in proceedings of the 10th workshop in primary and
secondary computing education (pp. 132e133). http://dx.doi.org/10.1145/
2818314.2818338.
moreno-leon, j., robles, g., & rom  an-gonz  alez, m. (2015). dr. scratch: automatic 
analysis of scratch projects to assess and foster computational thinking. red.
revista de educacion a distancia, 46  . retrieved from http://www.um.es/ead/red/
46/moreno_robles.pdf.
moreno-leon, j., robles, g., & rom  an-gonz  alez, m. (2016). comparing computa- 
tional thinking development assessment scores with software complexity
metrics. in 2016 ieee global engineering education conference (educon) (pp.
1040e1045). http://dx.doi.org/10.1109/educon.2016.7474681.
mühling, a., ruf, a., & hubwieser, p. (2015). design and first results of a psychometric test for measuring basic programming abilities. in proceedings of the 10th
workshop in primary and secondary computing education (pp. 2e10). http://
dx.doi.org/10.1145/2818314.2818320.
nunnally, j. c., & bernstein, i. h. (1994). psychometric theory (3rd ed.). new york:
mcgraw-hill.
papert, s. (1980). mindstorms: children, computers, and powerful ideas. new york:
basic books.
prensky, m. (2008, january 13). programming is the new literacy [blog post]. retrieved
fromhttp://www.edutopia.org/literacy-computer-programming.
quiroga, m.a., escorial, s., rom  
an, f. j., morillo, d., jarabo, a., privado, j., & colom, r.
(2015). can we reliably measure the general factor of intelligence (g) through
commercial video games? yes, we can! intelligence, 53, 1e7. http://dx.doi.org/
10.1016/j.intell.2015.08.004.
resnick, m., maloney, j., monroy-hern
andez, a., rusk, n., eastmond, e., brennan, k.,
& silverman, b. (2009). scratch: programming for all. communications of the
acm, 52(11), 60e67. http://dx.doi.org/10.1145/1592761.1592779.
roman-gonz  alez, m. (2014). aprender a programar  ‘apps’ como enriquecimiento
curricular en alumnado de alta capacidad. bordon.  revista de pedagogía, 66(4),
135e155. http://dx.doi.org/10.13042/bordon.2014.66401.
roman-gonz  alez, m. (2015). computational thinking test: design guidelines and 
content validation. in 7th annual international conference on education and new
learning technologies (barcelona: spain). http://dx.doi.org/10.13140/
rg.2.1.4203.4329.
roman-gonz  alez, m., p  erez-gonz  alez, j. c., & jim  enez-fern  
andez, c. (2015). test de
pensamiento computacional: diseno y psicometría general [computational ~
thinking test: design & general psychometry]. in iii congreso internacional sobre
aprendizaje, innovacion y competitividad, cinaic2015 (madrid: spain)  . http://
dx.doi.org/10.13140/rg.2.1.3056.5521.
rushkoff, d. (2012, november 13). code literacy: a 21st-century requirement [blog
post]. retrieved from http://www.edutopia.org/blog/code-literacy-21stcentury-requirement-douglas-rushkoff.
rushkoff, d. (2010). program or be programmed. new york: or books.
schneider, w. j., & mcgrew, k. s. (2012). the cattell-horn-carroll model of intelligence. in d. flanagan, & p. harrison (eds.), contemporary intellectual assessment:
theories, tests, and issues (3rd ed., pp. 99e144). new york: guilford.
seisdedos, n. (1994). cambios: test de flexibilidad cognitiva (manual tecnico)
[changes: cognitive flexibility test (technical manual)]. madrid: tea ediciones.
seisdedos, n. (2002). rp30: test de resolucion de problemas (manual t  ecnico) [rp30:
problem-solving test (technical manual)]. madrid: tea ediciones.
thurstone, l. l. (1938). primary mental abilities. chicago: university of chicago press.
voyer, d., voyer, s., & bryden, m. p. (1995). magnitude of sex differences in spatial
abilities: a meta-analysis and consideration of critical variables. psychological
bulletin, 117(2), 250e270. http://dx.doi.org/10.1037/0033-2909.117.2.250.
weintrop, d., beheshti, e., horn, m., orton, k., jona, k., trouille, l., et al. (2016).
defining computational thinking for mathematics and science classrooms.
journal of science education and technology, 25(1), 127e147. http://dx.doi.org/
10.1007/s10956-015-9581-5.
weintrop, d., & wilensky, u. (2015). using commutative assessments to compare
conceptual understanding in blocks-based and text-based programs. in proceedings of the eleventh annual international conference on international
computing education research, icer15 (pp. 101e110). http://dx.doi.org/10.1145/
2787622.2787721.
werner, l., denner, j., campe, s., & kawamoto, d. c. (2012). the fairy performance
assessment: measuring computational thinking in middle school. in proceedings
of the 43rd acm technical symposium on computer science education (pp.
215e220). http://dx.doi.org/10.1145/2157136.2157200.
wing, j. m. (2006). computational thinking. communications of the acm, 49(3),
33e35. http://dx.doi.org/10.1145/1118178.1118215.
wing, j. m. (2008). computational thinking and thinking about computing. philosophical transactions. series a, mathematical. physical, and engineering sciences, 366(1881), 3717e3725. http://dx.doi.org/10.1098/rsta.2008.0118.
wing, j. m. (2011). research notebook: computational thinkingewhat and why? the
link. the magazine of the carnegie mellon university school of computer science. retrieved from http://www.cs.cmu.edu/link/research-notebookcomputational-thinking-what-and-why.
m. roman-gonz  alez et al. / computers in human behavior 72 (2017) 678  e691 691"
